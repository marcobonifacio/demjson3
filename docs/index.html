<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>demjson3 API documentation</title>
<meta name="description" content="A JSON data encoder and decoder â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>demjson3</code></h1>
</header>
<section id="section-intro">
<p>A JSON data encoder and decoder.</p>
<p>This Python module implements the JSON (<a href="http://json.org/">http://json.org/</a>) data
encoding format; a subset of ECMAScript (aka JavaScript) for encoding
primitive data types (numbers, strings, booleans, lists, and
associative arrays) in a language-neutral simple text-based syntax.</p>
<p>It can encode or decode between JSON formatted strings and native
Python data types.
Normally you would use the encode() and decode()
functions defined by this module, but if you want more control over
the processing you can use the JSON class.</p>
<p>This implementation tries to be as completely cormforming to all
intricacies of the standards as possible.
It can operate in strict
mode (which only allows JSON-compliant syntax) or a non-strict mode
(which allows much more of the whole ECMAScript permitted syntax).
This includes complete support for Unicode strings (including
surrogate-pairs for non-BMP characters), and all number formats
including negative zero and IEEE 754 non-numbers such a NaN or
Infinity.</p>
<p>The JSON/ECMAScript to Python type mappings are:
&mdash;JSON&mdash;
&mdash;Python&mdash;
null
None
undefined
undefined
(note 1)
Boolean (true,false)
bool
(True or False)
Integer
int or long
(note 2)
Float
float
String
str or unicode
( "&hellip;" or u"&hellip;" )
Array [a, &hellip;]
list
( [&hellip;] )
Object {a:b, &hellip;}
dict
( {&hellip;} )</p>
<p>&ndash; Note 1. an 'undefined' object is declared in this module which
represents the native Python value for this type when in
non-strict mode.</p>
<p>&ndash; Note 2. some ECMAScript integers may be up-converted to Python
floats, such as 1e+40.
Also integer -0 is converted to
float -0, so as to preserve the sign (which ECMAScript requires).</p>
<p>&ndash; Note 3. numbers requiring more significant digits than can be
represented by the Python float type will be converted into a
Python Decimal type, from the standard 'decimal' module.</p>
<p>In addition, when operating in non-strict mode, several IEEE 754
non-numbers are also handled, and are mapped to specific Python
objects declared in this module:</p>
<pre><code>NaN (not a number)     nan    (float('nan'))
Infinity, +Infinity    inf    (float('inf'))
-Infinity              neginf (float('-inf'))
</code></pre>
<p>When encoding Python objects into JSON, you may use types other than
native lists or dictionaries, as long as they support the minimal
interfaces required of all sequences or mappings.
This means you can
use generators and iterators, tuples, UserDict subclasses, etc.</p>
<p>To make it easier to produce JSON encoded representations of user
defined classes, if the object has a method named json_equivalent(),
then it will call that method and attempt to encode the object
returned from it instead.
It will do this recursively as needed and
before any attempt to encode the object using it's default
strategies.
Note that any json_equivalent() method should return
"equivalent" Python objects to be encoded, not an already-encoded
JSON-formatted string.
There is no such aid provided to decode
JSON back into user-defined classes as that would dramatically
complicate the interface.</p>
<p>When decoding strings with this module it may operate in either
strict or non-strict mode.
The strict mode only allows syntax which
is conforming to RFC 7159 (JSON), while the non-strict allows much
more of the permissible ECMAScript syntax.</p>
<p>The following are permitted when processing in NON-STRICT mode:</p>
<ul>
<li>Unicode format control characters are allowed anywhere in the input.</li>
<li>All Unicode line terminator characters are recognized.</li>
<li>All Unicode white space characters are recognized.</li>
<li>The 'undefined' keyword is recognized.</li>
<li>Hexadecimal number literals are recognized (e.g., 0xA6, 0177).</li>
<li>String literals may use either single or double quote marks.</li>
<li>Strings may contain \x (hexadecimal) escape sequences, as well as the
\v and \0 escape sequences.</li>
<li>Lists may have omitted (elided) elements, e.g., [,,,,,], with
missing elements interpreted as 'undefined' values.</li>
<li>Object properties (dictionary keys) can be of any of the
types: string literals, numbers, or identifiers (the later of
which are treated as if they are string literals)&mdash;as permitted
by ECMAScript.
JSON only permits strings literals as keys.</li>
</ul>
<p>Concerning non-strict and non-ECMAScript allowances:</p>
<ul>
<li>
<p>Octal numbers: If you allow the 'octal_numbers' behavior (which
is never enabled by default), then you can use octal integers
and octal character escape sequences (per the ECMAScript
standard Annex B.1.2).
This behavior is allowed, if enabled,
because it was valid JavaScript at one time.</p>
</li>
<li>
<p>Multi-line string literals:
Strings which are more than one
line long (contain embedded raw newline characters) are never
permitted. This is neither valid JSON nor ECMAScript.
Some other
JSON implementations may allow this, but this module considers
that behavior to be a mistake.</p>
</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>JSON (JavaScript Object Notation)
<a href="http://json.org/">http://json.org/</a></li>
<li>RFC 7159. The application/json Media Type for JavaScript Object Notation (JSON)
<a href="http://www.ietf.org/rfc/rfc7159.txt">http://www.ietf.org/rfc/rfc7159.txt</a></li>
<li>ECMA-262 3rd edition (1999)
<a href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf</a></li>
<li>IEEE 754-1985: Standard for Binary Floating-Point Arithmetic.
<a href="http://www.cs.berkeley.edu/~ejr/Projects/ieee754/">http://www.cs.berkeley.edu/~ejr/Projects/ieee754/</a></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
r&#34;&#34;&#34; A JSON data encoder and decoder.

 This Python module implements the JSON (http://json.org/) data
 encoding format; a subset of ECMAScript (aka JavaScript) for encoding
 primitive data types (numbers, strings, booleans, lists, and
 associative arrays) in a language-neutral simple text-based syntax.
 
 It can encode or decode between JSON formatted strings and native
 Python data types.  Normally you would use the encode() and decode()
 functions defined by this module, but if you want more control over
 the processing you can use the JSON class.

 This implementation tries to be as completely cormforming to all
 intricacies of the standards as possible.  It can operate in strict
 mode (which only allows JSON-compliant syntax) or a non-strict mode
 (which allows much more of the whole ECMAScript permitted syntax).
 This includes complete support for Unicode strings (including
 surrogate-pairs for non-BMP characters), and all number formats
 including negative zero and IEEE 754 non-numbers such a NaN or
 Infinity.

 The JSON/ECMAScript to Python type mappings are:
    ---JSON---             ---Python---
    null                   None
    undefined              undefined  (note 1)
    Boolean (true,false)   bool  (True or False)
    Integer                int or long  (note 2)
    Float                  float
    String                 str or unicode  ( &#34;...&#34; or u&#34;...&#34; )
    Array [a, ...]         list  ( [...] )
    Object {a:b, ...}      dict  ( {...} )
    
    -- Note 1. an &#39;undefined&#39; object is declared in this module which
       represents the native Python value for this type when in
       non-strict mode.

    -- Note 2. some ECMAScript integers may be up-converted to Python
       floats, such as 1e+40.  Also integer -0 is converted to
       float -0, so as to preserve the sign (which ECMAScript requires).

    -- Note 3. numbers requiring more significant digits than can be
       represented by the Python float type will be converted into a
       Python Decimal type, from the standard &#39;decimal&#39; module.

 In addition, when operating in non-strict mode, several IEEE 754
 non-numbers are also handled, and are mapped to specific Python
 objects declared in this module:

     NaN (not a number)     nan    (float(&#39;nan&#39;))
     Infinity, +Infinity    inf    (float(&#39;inf&#39;))
     -Infinity              neginf (float(&#39;-inf&#39;))

 When encoding Python objects into JSON, you may use types other than
 native lists or dictionaries, as long as they support the minimal
 interfaces required of all sequences or mappings.  This means you can
 use generators and iterators, tuples, UserDict subclasses, etc.

 To make it easier to produce JSON encoded representations of user
 defined classes, if the object has a method named json_equivalent(),
 then it will call that method and attempt to encode the object
 returned from it instead.  It will do this recursively as needed and
 before any attempt to encode the object using it&#39;s default
 strategies.  Note that any json_equivalent() method should return
 &#34;equivalent&#34; Python objects to be encoded, not an already-encoded
 JSON-formatted string.  There is no such aid provided to decode
 JSON back into user-defined classes as that would dramatically
 complicate the interface.
 
 When decoding strings with this module it may operate in either
 strict or non-strict mode.  The strict mode only allows syntax which
 is conforming to RFC 7159 (JSON), while the non-strict allows much
 more of the permissible ECMAScript syntax.

 The following are permitted when processing in NON-STRICT mode:

    * Unicode format control characters are allowed anywhere in the input.
    * All Unicode line terminator characters are recognized.
    * All Unicode white space characters are recognized.
    * The &#39;undefined&#39; keyword is recognized.
    * Hexadecimal number literals are recognized (e.g., 0xA6, 0177).
    * String literals may use either single or double quote marks.
    * Strings may contain \x (hexadecimal) escape sequences, as well as the
      \v and \0 escape sequences.
    * Lists may have omitted (elided) elements, e.g., [,,,,,], with
      missing elements interpreted as &#39;undefined&#39; values.
    * Object properties (dictionary keys) can be of any of the
      types: string literals, numbers, or identifiers (the later of
      which are treated as if they are string literals)---as permitted
      by ECMAScript.  JSON only permits strings literals as keys.

 Concerning non-strict and non-ECMAScript allowances:

    * Octal numbers: If you allow the &#39;octal_numbers&#39; behavior (which
      is never enabled by default), then you can use octal integers
      and octal character escape sequences (per the ECMAScript
      standard Annex B.1.2).  This behavior is allowed, if enabled,
      because it was valid JavaScript at one time.

    * Multi-line string literals:  Strings which are more than one
      line long (contain embedded raw newline characters) are never
      permitted. This is neither valid JSON nor ECMAScript.  Some other
      JSON implementations may allow this, but this module considers
      that behavior to be a mistake.

 References:
    * JSON (JavaScript Object Notation)
      &lt;http://json.org/&gt;
    * RFC 7159. The application/json Media Type for JavaScript Object Notation (JSON)
      &lt;http://www.ietf.org/rfc/rfc7159.txt&gt;
    * ECMA-262 3rd edition (1999)
      &lt;http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf&gt;
    * IEEE 754-1985: Standard for Binary Floating-Point Arithmetic.
      &lt;http://www.cs.berkeley.edu/~ejr/Projects/ieee754/&gt;
    
&#34;&#34;&#34;

__author__ = &#34;Deron Meranda &lt;http://deron.meranda.us/&gt;, Niels MÃ¼ndler&#34;
__homepage__ = &#34;http://nielstron.github.io/demjson3/&#34;

__date__ = &#34;2021-09-08&#34;
__version__ = &#34;3.0.5&#34;
__version_info__ = (3, 0, 5)  # Will be converted into a namedtuple below

__credits__ = &#34;&#34;&#34;Copyright (c) 2006-2021 Deron E. Meranda &lt;http://deron.meranda.us/&gt;, Niels MÃ¼ndler

Licensed under GNU LGPL (GNU Lesser General Public License) version 3.0
or later.  See LICENSE.txt included with this software.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;
or &lt;http://www.fsf.org/licensing/&gt;.

&#34;&#34;&#34;

# ----------------------------------------------------------------------

# Set demjson version
try:
    from collections import namedtuple as _namedtuple

    __version_info__ = _namedtuple(&#34;version_info&#34;, [&#34;major&#34;, &#34;minor&#34;, &#34;micro&#34;])(
        *__version_info__
    )
except ImportError:
    raise ImportError(&#34;demjson %s requires a Python 2.6 or later&#34; % __version__)

version, version_info = __version__, __version_info__


# Determine Python version
import sys

vi = sys.version_info
try:
    _py_major, _py_minor = vi.major, vi.minor
except AttributeError:
    _py_major, _py_minor = vi[0], vi[1]

# ----------------------------------------------------------------------
# Useful global constants

content_type = &#34;application/json&#34;
file_ext = &#34;json&#34;


class _dummy_context_manager(object):
    &#34;&#34;&#34;A context manager that does nothing on entry or exit.&#34;&#34;&#34;

    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_val, exc_tb):
        return False


_dummy_context_manager = _dummy_context_manager()


# ----------------------------------------------------------------------
# Decimal and float types.
#
# If a JSON number can not be stored in a Python float without loosing
# precision and the Python has the decimal type, then we will try to
# use decimal instead of float.  To make this determination we need to
# know the limits of the float type, but Python doesn&#39;t have an easy
# way to tell what the largest floating-point number it supports.  So,
# we detemine the precision and scale of the float type by testing it.

# decimal module was introduced in Python 2.4
import decimal


def determine_float_limits(number_type=float):
    &#34;&#34;&#34;Determines the precision and range of the given float type.

    The passed in &#39;number_type&#39; argument should refer to the type of
    floating-point number.  It should either be the built-in &#39;float&#39;,
    or decimal context or constructor; i.e., one of:

        # 1. FLOAT TYPE
        determine_float_limits( float )

        # 2. DEFAULT DECIMAL CONTEXT
        determine_float_limits( decimal.Decimal )

        # 3. CUSTOM DECIMAL CONTEXT
        ctx = decimal.Context( prec=75 )
        determine_float_limits( ctx )

    Returns a named tuple with components:

         ( significant_digits,
           max_exponent,
           min_exponent )

    Where:
        * significant_digits -- maximum number of *decimal* digits
             that can be represented without any loss of precision.
             This is conservative, so if there are 16 1/2 digits, it
             will return 16, not 17.

        * max_exponent -- The maximum exponent (power of 10) that can
             be represented before an overflow (or rounding to
             infinity) occurs.

        * min_exponent -- The minimum exponent (negative power of 10)
             that can be represented before either an underflow
             (rounding to zero) or a subnormal result (loss of
             precision) occurs.  Note this is conservative, as
             subnormal numbers are excluded.

    &#34;&#34;&#34;
    numeric_exceptions = (ValueError, decimal.Overflow, decimal.Underflow)

    if number_type == decimal.Decimal:
        number_type = decimal.DefaultContext

    if isinstance(number_type, decimal.Context):
        # Passed a decimal Context, extract the bound creator function.
        create_num = number_type.create_decimal
        decimal_ctx = decimal.localcontext(number_type)
        is_zero_or_subnormal = lambda n: n.is_zero() or n.is_subnormal()
    elif number_type == float:
        create_num = number_type
        decimal_ctx = _dummy_context_manager
        is_zero_or_subnormal = lambda n: n == 0
    else:
        raise TypeError(&#34;Expected a float type, e.g., float or decimal context&#34;)

    with decimal_ctx:
        zero = create_num(&#34;0.0&#34;)

        # Find signifianct digits by comparing floats of increasing
        # number of digits, differing in the last digit only, until
        # they numerically compare as being equal.
        sigdigits = None
        n = 0
        while True:
            n = n + 1
            pfx = &#34;0.&#34; + &#34;1&#34; * n
            a = create_num(pfx + &#34;0&#34;)
            for sfx in &#34;123456789&#34;:  # Check all possible last digits to
                # avoid any partial-decimal.
                b = create_num(pfx + sfx)
                if (a + zero) == (b + zero):
                    sigdigits = n
                    break
            if sigdigits:
                break

        # Find exponent limits.  First find order of magnitude and
        # then use a binary search to find the exact exponent.
        base = &#34;1.&#34; + &#34;1&#34; * (sigdigits - 1)
        base0 = &#34;1.&#34; + &#34;1&#34; * (sigdigits - 2)
        minexp, maxexp = None, None

        for expsign in (&#34;+&#34;, &#34;-&#34;):
            minv = 0
            maxv = 10
            # First find order of magnitude of exponent limit
            while True:
                try:
                    s = base + &#34;e&#34; + expsign + str(maxv)
                    s0 = base0 + &#34;e&#34; + expsign + str(maxv)
                    f = create_num(s) + zero
                    f0 = create_num(s0) + zero
                except numeric_exceptions:
                    f = None
                if (
                    not f
                    or not str(f)[0].isdigit()
                    or is_zero_or_subnormal(f)
                    or f == f0
                ):
                    break
                else:
                    minv = maxv
                    maxv = maxv * 10

            # Now do a binary search to find exact limit
            while True:
                if minv + 1 == maxv:
                    if expsign == &#34;+&#34;:
                        maxexp = minv
                    else:
                        minexp = minv
                    break
                elif maxv &lt; minv:
                    if expsign == &#34;+&#34;:
                        maxexp = None
                    else:
                        minexp = None
                    break
                m = (minv + maxv) // 2
                try:
                    s = base + &#34;e&#34; + expsign + str(m)
                    s0 = base0 + &#34;e&#34; + expsign + str(m)
                    f = create_num(s) + zero
                    f0 = create_num(s0) + zero
                except numeric_exceptions:
                    f = None
                else:
                    if not f or not str(f)[0].isdigit():
                        f = None
                    elif is_zero_or_subnormal(f) or f == f0:
                        f = None
                if not f:
                    # infinite
                    maxv = m
                else:
                    minv = m

    return _namedtuple(
        &#34;float_limits&#34;, [&#34;significant_digits&#34;, &#34;max_exponent&#34;, &#34;min_exponent&#34;]
    )(sigdigits, maxexp, -minexp)


float_sigdigits, float_maxexp, float_minexp = determine_float_limits(float)


# For backwards compatibility with older demjson versions:
def determine_float_precision():
    v = determine_float_limits(float)
    return (v.significant_digits, v.max_exponent)


# ----------------------------------------------------------------------
# The undefined value.
#
# ECMAScript has an undefined value (similar to yet distinct from null).
# Neither Python or strict JSON have support undefined, but to allow
# JavaScript behavior we must simulate it.


class _undefined_class(object):
    &#34;&#34;&#34;Represents the ECMAScript &#39;undefined&#39; value.&#34;&#34;&#34;

    __slots__ = []

    def __repr__(self):
        return self.__module__ + &#34;.undefined&#34;

    def __str__(self):
        return &#34;undefined&#34;

    def __bool__(self):
        return False


undefined = _undefined_class()
syntax_error = _undefined_class()  # same as undefined, but has separate identity
del _undefined_class


# ----------------------------------------------------------------------
# Non-Numbers: NaN, Infinity, -Infinity
#
# ECMAScript has official support for non-number floats, although
# strict JSON does not.  Python doesn&#39;t either.  So to support the
# full JavaScript behavior we must try to add them into Python, which
# is unfortunately a bit of black magic.  If our python implementation
# happens to be built on top of IEEE 754 we can probably trick python
# into using real floats.  Otherwise we must simulate it with classes.


def _nonnumber_float_constants():
    &#34;&#34;&#34;Try to return the Nan, Infinity, and -Infinity float values.

    This is necessarily complex because there is no standard
    platform-independent way to do this in Python as the language
    (opposed to some implementation of it) doesn&#39;t discuss
    non-numbers.  We try various strategies from the best to the
    worst.

    If this Python interpreter uses the IEEE 754 floating point
    standard then the returned values will probably be real instances
    of the &#39;float&#39; type.  Otherwise a custom class object is returned
    which will attempt to simulate the correct behavior as much as
    possible.

    &#34;&#34;&#34;
    try:
        # First, try (mostly portable) float constructor.  Works under
        # Linux x86 (gcc) and some Unices.
        nan = float(&#34;nan&#34;)
        inf = float(&#34;inf&#34;)
        neginf = float(&#34;-inf&#34;)
    except ValueError:
        try:
            # Try the AIX (PowerPC) float constructors
            nan = float(&#34;NaNQ&#34;)
            inf = float(&#34;INF&#34;)
            neginf = float(&#34;-INF&#34;)
        except ValueError:
            try:
                # Next, try binary unpacking.  Should work under
                # platforms using IEEE 754 floating point.
                import struct, sys

                xnan = bytes(
                    bytearray.fromhex(&#34;7ff8000000000000&#34;).decode()
                )  # Quiet NaN
                xinf = bytes(bytearray.fromhex(&#34;7ff0000000000000&#34;).decode())
                xcheck = bytes(
                    bytearray.fromhex(&#34;bdc145651592979d&#34;).decode()
                )  # -3.14159e-11
                # Could use float.__getformat__, but it is a new python feature,
                # so we use sys.byteorder.
                if sys.byteorder == &#34;big&#34;:
                    nan = struct.unpack(&#34;d&#34;, xnan)[0]
                    inf = struct.unpack(&#34;d&#34;, xinf)[0]
                    check = struct.unpack(&#34;d&#34;, xcheck)[0]
                else:
                    nan = struct.unpack(&#34;d&#34;, xnan[::-1])[0]
                    inf = struct.unpack(&#34;d&#34;, xinf[::-1])[0]
                    check = struct.unpack(&#34;d&#34;, xcheck[::-1])[0]
                neginf = -inf
                if check != -3.14159e-11:
                    raise ValueError(&#34;Unpacking raw IEEE 754 floats does not work&#34;)
            except (ValueError, TypeError):
                # Punt, make some fake classes to simulate.  These are
                # not perfect though.  For instance nan * 1.0 == nan,
                # as expected, but 1.0 * nan == 0.0, which is wrong.
                class nan(float):
                    &#34;&#34;&#34;An approximation of the NaN (not a number) floating point number.&#34;&#34;&#34;

                    def __repr__(self):
                        return &#34;nan&#34;

                    def __str__(self):
                        return &#34;nan&#34;

                    def __add__(self, x):
                        return self

                    def __radd__(self, x):
                        return self

                    def __sub__(self, x):
                        return self

                    def __rsub__(self, x):
                        return self

                    def __mul__(self, x):
                        return self

                    def __rmul__(self, x):
                        return self

                    def __div__(self, x):
                        return self

                    def __rdiv__(self, x):
                        return self

                    def __divmod__(self, x):
                        return (self, self)

                    def __rdivmod__(self, x):
                        return (self, self)

                    def __mod__(self, x):
                        return self

                    def __rmod__(self, x):
                        return self

                    def __pow__(self, exp):
                        return self

                    def __rpow__(self, exp):
                        return self

                    def __neg__(self):
                        return self

                    def __pos__(self):
                        return self

                    def __abs__(self):
                        return self

                    def __lt__(self, x):
                        return False

                    def __le__(self, x):
                        return False

                    def __eq__(self, x):
                        return False

                    def __neq__(self, x):
                        return True

                    def __ge__(self, x):
                        return False

                    def __gt__(self, x):
                        return False

                    def __complex__(self, *a):
                        raise NotImplementedError(
                            &#34;NaN can not be converted to a complex&#34;
                        )

                nan = decimal.Decimal(&#34;NaN&#34;)

                class inf(float):
                    &#34;&#34;&#34;An approximation of the +Infinity floating point number.&#34;&#34;&#34;

                    def __repr__(self):
                        return &#34;inf&#34;

                    def __str__(self):
                        return &#34;inf&#34;

                    def __add__(self, x):
                        return self

                    def __radd__(self, x):
                        return self

                    def __sub__(self, x):
                        return self

                    def __rsub__(self, x):
                        return self

                    def __mul__(self, x):
                        if x is neginf or x &lt; 0:
                            return neginf
                        elif x == 0:
                            return nan
                        else:
                            return self

                    def __rmul__(self, x):
                        return self.__mul__(x)

                    def __div__(self, x):
                        if x == 0:
                            raise ZeroDivisionError(&#34;float division&#34;)
                        elif x &lt; 0:
                            return neginf
                        else:
                            return self

                    def __rdiv__(self, x):
                        if x is inf or x is neginf or x is nan:
                            return nan
                        return 0.0

                    def __divmod__(self, x):
                        if x == 0:
                            raise ZeroDivisionError(&#34;float divmod()&#34;)
                        elif x &lt; 0:
                            return (nan, nan)
                        else:
                            return (self, self)

                    def __rdivmod__(self, x):
                        if x is inf or x is neginf or x is nan:
                            return (nan, nan)
                        return (0.0, x)

                    def __mod__(self, x):
                        if x == 0:
                            raise ZeroDivisionError(&#34;float modulo&#34;)
                        else:
                            return nan

                    def __rmod__(self, x):
                        if x is inf or x is neginf or x is nan:
                            return nan
                        return x

                    def __pow__(self, exp):
                        if exp == 0:
                            return 1.0
                        else:
                            return self

                    def __rpow__(self, x):
                        if -1 &lt; x &lt; 1:
                            return 0.0
                        elif x == 1.0:
                            return 1.0
                        elif x is nan or x is neginf or x &lt; 0:
                            return nan
                        else:
                            return self

                    def __neg__(self):
                        return neginf

                    def __pos__(self):
                        return self

                    def __abs__(self):
                        return self

                    def __lt__(self, x):
                        return False

                    def __le__(self, x):
                        if x is self:
                            return True
                        else:
                            return False

                    def __eq__(self, x):
                        if x is self:
                            return True
                        else:
                            return False

                    def __neq__(self, x):
                        if x is self:
                            return False
                        else:
                            return True

                    def __ge__(self, x):
                        return True

                    def __gt__(self, x):
                        return True

                    def __complex__(self, *a):
                        raise NotImplementedError(
                            &#34;Infinity can not be converted to a complex&#34;
                        )

                if decimal:
                    inf = decimal.Decimal(&#34;Infinity&#34;)
                else:
                    inf = inf()

                class neginf(float):
                    &#34;&#34;&#34;An approximation of the -Infinity floating point number.&#34;&#34;&#34;

                    def __repr__(self):
                        return &#34;-inf&#34;

                    def __str__(self):
                        return &#34;-inf&#34;

                    def __add__(self, x):
                        return self

                    def __radd__(self, x):
                        return self

                    def __sub__(self, x):
                        return self

                    def __rsub__(self, x):
                        return self

                    def __mul__(self, x):
                        if x is self or x &lt; 0:
                            return inf
                        elif x == 0:
                            return nan
                        else:
                            return self

                    def __rmul__(self, x):
                        return self.__mul__(self)

                    def __div__(self, x):
                        if x == 0:
                            raise ZeroDivisionError(&#34;float division&#34;)
                        elif x &lt; 0:
                            return inf
                        else:
                            return self

                    def __rdiv__(self, x):
                        if x is inf or x is neginf or x is nan:
                            return nan
                        return -0.0

                    def __divmod__(self, x):
                        if x == 0:
                            raise ZeroDivisionError(&#34;float divmod()&#34;)
                        elif x &lt; 0:
                            return (nan, nan)
                        else:
                            return (self, self)

                    def __rdivmod__(self, x):
                        if x is inf or x is neginf or x is nan:
                            return (nan, nan)
                        return (-0.0, x)

                    def __mod__(self, x):
                        if x == 0:
                            raise ZeroDivisionError(&#34;float modulo&#34;)
                        else:
                            return nan

                    def __rmod__(self, x):
                        if x is inf or x is neginf or x is nan:
                            return nan
                        return x

                    def __pow__(self, exp):
                        if exp == 0:
                            return 1.0
                        else:
                            return self

                    def __rpow__(self, x):
                        if x is nan or x is inf or x is inf:
                            return nan
                        return 0.0

                    def __neg__(self):
                        return inf

                    def __pos__(self):
                        return self

                    def __abs__(self):
                        return inf

                    def __lt__(self, x):
                        return True

                    def __le__(self, x):
                        return True

                    def __eq__(self, x):
                        if x is self:
                            return True
                        else:
                            return False

                    def __neq__(self, x):
                        if x is self:
                            return False
                        else:
                            return True

                    def __ge__(self, x):
                        if x is self:
                            return True
                        else:
                            return False

                    def __gt__(self, x):
                        return False

                    def __complex__(self, *a):
                        raise NotImplementedError(
                            &#34;-Infinity can not be converted to a complex&#34;
                        )

                if decimal:
                    neginf = decimal.Decimal(&#34;-Infinity&#34;)
                else:
                    neginf = neginf(0)
    return nan, inf, neginf


nan, inf, neginf = _nonnumber_float_constants()
del _nonnumber_float_constants


# ----------------------------------------------------------------------
# Integers


class json_int(int):  # Have to specify base this way to satisfy 2to3
    &#34;&#34;&#34;A subclass of the Python int/long that remembers its format (hex,octal,etc).

    Initialize it the same as an int, but also accepts an additional keyword
    argument &#39;number_format&#39; which should be one of the NUMBER_FORMAT_* values.

        n = json_int( x[, base, number_format=NUMBER_FORMAT_DECIMAL] )

    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if &#34;number_format&#34; in kwargs:
            number_format = kwargs[&#34;number_format&#34;]
            del kwargs[&#34;number_format&#34;]
            if number_format not in (
                NUMBER_FORMAT_DECIMAL,
                NUMBER_FORMAT_HEX,
                NUMBER_FORMAT_OCTAL,
                NUMBER_FORMAT_LEGACYOCTAL,
                NUMBER_FORMAT_BINARY,
            ):
                raise TypeError(&#34;json_int(): Invalid value for number_format argument&#34;)
        else:
            number_format = NUMBER_FORMAT_DECIMAL
        obj = super(json_int, cls).__new__(cls, *args, **kwargs)
        obj._jsonfmt = number_format
        return obj

    @property
    def number_format(self):
        &#34;&#34;&#34;The original radix format of the number&#34;&#34;&#34;
        return self._jsonfmt

    def json_format(self):
        &#34;&#34;&#34;Returns the integer value formatted as a JSON literal&#34;&#34;&#34;
        fmt = self._jsonfmt
        if fmt == NUMBER_FORMAT_HEX:
            return format(self, &#34;#x&#34;)
        elif fmt == NUMBER_FORMAT_OCTAL:
            return format(self, &#34;#o&#34;)
        elif fmt == NUMBER_FORMAT_BINARY:
            return format(self, &#34;#b&#34;)
        elif fmt == NUMBER_FORMAT_LEGACYOCTAL:
            if self == 0:
                return &#34;0&#34;  # For some reason Python&#39;s int doesn&#39;t do &#39;00&#39;
            elif self &lt; 0:
                return &#34;-0%o&#34; % (-self)
            else:
                return &#34;0%o&#34; % self
        else:
            return str(self)


# ----------------------------------------------------------------------
# String processing helpers


def skipstringsafe(s, start=0, end=None):
    i = start
    # if end is None:
    #    end = len(s)
    unsafe = helpers.unsafe_string_chars
    while i &lt; end and s[i] not in unsafe:
        # c = s[i]
        # if c in unsafe_string_chars:
        #    break
        i += 1
    return i


def skipstringsafe_slow(s, start=0, end=None):
    i = start
    if end is None:
        end = len(s)
    while i &lt; end:
        c = s[i]
        if c == &#39;&#34;&#39; or c == &#34;&#39;&#34; or c == &#34;\\&#34; or ord(c) &lt;= 0x1F:
            break
        i += 1
    return i


def extend_list_with_sep(orig_seq, extension_seq, sepchar=&#34;&#34;):
    if not sepchar:
        orig_seq.extend(extension_seq)
    else:
        for i, x in enumerate(extension_seq):
            if i &gt; 0:
                orig_seq.append(sepchar)
            orig_seq.append(x)


def extend_and_flatten_list_with_sep(orig_seq, extension_seq, separator=&#34;&#34;):
    for i, part in enumerate(extension_seq):
        if i &gt; 0 and separator:
            orig_seq.append(separator)
        orig_seq.extend(part)


# ----------------------------------------------------------------------
# Unicode UTF-32
# ----------------------------------------------------------------------


def _make_raw_bytes(byte_list):
    &#34;&#34;&#34;Takes a list of byte values (numbers) and returns a bytes (Python 3) or string (Python 2)&#34;&#34;&#34;
    return bytes(byte_list)


import codecs


class utf32(codecs.CodecInfo):
    &#34;&#34;&#34;Unicode UTF-32 and UCS4 encoding/decoding support.

    This is for older Pythons whch did not have UTF-32 codecs.

    JSON requires that all JSON implementations must support the
    UTF-32 encoding (as well as UTF-8 and UTF-16).  But earlier
    versions of Python did not provide a UTF-32 codec, so we must
    implement UTF-32 ourselves in case we need it.

    See http://en.wikipedia.org/wiki/UTF-32

    &#34;&#34;&#34;

    BOM_UTF32_BE = _make_raw_bytes([0, 0, 0xFE, 0xFF])  #&#39;\x00\x00\xfe\xff&#39;
    BOM_UTF32_LE = _make_raw_bytes([0xFF, 0xFE, 0, 0])  #&#39;\xff\xfe\x00\x00&#39;

    @staticmethod
    def lookup(name):
        &#34;&#34;&#34;A standard Python codec lookup function for UCS4/UTF32.

        If if recognizes an encoding name it returns a CodecInfo
        structure which contains the various encode and decoder
        functions to use.

        &#34;&#34;&#34;
        ci = None
        name = name.upper()
        if name in (
            &#34;UCS4BE&#34;,
            &#34;UCS-4BE&#34;,
            &#34;UCS-4-BE&#34;,
            &#34;UTF32BE&#34;,
            &#34;UTF-32BE&#34;,
            &#34;UTF-32-BE&#34;,
        ):
            ci = codecs.CodecInfo(
                utf32.utf32be_encode, utf32.utf32be_decode, name=&#34;utf-32be&#34;
            )
        elif name in (
            &#34;UCS4LE&#34;,
            &#34;UCS-4LE&#34;,
            &#34;UCS-4-LE&#34;,
            &#34;UTF32LE&#34;,
            &#34;UTF-32LE&#34;,
            &#34;UTF-32-LE&#34;,
        ):
            ci = codecs.CodecInfo(
                utf32.utf32le_encode, utf32.utf32le_decode, name=&#34;utf-32le&#34;
            )
        elif name in (&#34;UCS4&#34;, &#34;UCS-4&#34;, &#34;UTF32&#34;, &#34;UTF-32&#34;):
            ci = codecs.CodecInfo(utf32.encode, utf32.decode, name=&#34;utf-32&#34;)
        return ci

    @staticmethod
    def encode(obj, errors=&#34;strict&#34;, endianness=None, include_bom=True):
        &#34;&#34;&#34;Encodes a Unicode string into a UTF-32 encoded byte string.

        Returns a tuple: (bytearray, num_chars)

        The errors argument should be one of &#39;strict&#39;, &#39;ignore&#39;, or &#39;replace&#39;.

        The endianness should be one of:
            * &#39;B&#39;, &#39;&gt;&#39;, or &#39;big&#39;     -- Big endian
            * &#39;L&#39;, &#39;&lt;&#39;, or &#39;little&#39;  -- Little endien
            * None                   -- Default, from sys.byteorder

        If include_bom is true a Byte-Order Mark will be written to
        the beginning of the string, otherwise it will be omitted.

        &#34;&#34;&#34;
        import sys, struct

        # Make a container that can store bytes
        f = bytearray()
        write = f.extend

        def tobytes():
            return bytes(f)

        if not endianness:
            endianness = sys.byteorder

        if endianness.upper()[0] in (&#34;B&gt;&#34;):
            big_endian = True
        elif endianness.upper()[0] in (&#34;L&lt;&#34;):
            big_endian = False
        else:
            raise ValueError(
                &#34;Invalid endianness %r: expected &#39;big&#39;, &#39;little&#39;, or None&#34; % endianness
            )

        pack = struct.pack
        packspec = &#34;&gt;L&#34; if big_endian else &#34;&lt;L&#34;

        num_chars = 0

        if include_bom:
            if big_endian:
                write(utf32.BOM_UTF32_BE)
            else:
                write(utf32.BOM_UTF32_LE)
            num_chars += 1

        for pos, c in enumerate(obj):
            n = ord(c)
            if 0xD800 &lt;= n &lt;= 0xDFFF:  # surrogate codepoints are prohibited by UTF-32
                if errors == &#34;ignore&#34;:
                    pass
                elif errors == &#34;replace&#34;:
                    n = 0xFFFD
                else:
                    raise UnicodeEncodeError(
                        &#34;utf32&#34;,
                        obj,
                        pos,
                        pos + 1,
                        &#34;surrogate code points from U+D800 to U+DFFF are not allowed&#34;,
                    )
            write(pack(packspec, n))
            num_chars += 1

        return (tobytes(), num_chars)

    @staticmethod
    def utf32le_encode(obj, errors=&#34;strict&#34;, include_bom=False):
        &#34;&#34;&#34;Encodes a Unicode string into a UTF-32LE (little endian) encoded byte string.&#34;&#34;&#34;
        return utf32.encode(obj, errors=errors, endianness=&#34;L&#34;, include_bom=include_bom)

    @staticmethod
    def utf32be_encode(obj, errors=&#34;strict&#34;, include_bom=False):
        &#34;&#34;&#34;Encodes a Unicode string into a UTF-32BE (big endian) encoded byte string.&#34;&#34;&#34;
        return utf32.encode(obj, errors=errors, endianness=&#34;B&#34;, include_bom=include_bom)

    @staticmethod
    def decode(obj, errors=&#34;strict&#34;, endianness=None):
        &#34;&#34;&#34;Decodes a UTF-32 byte string into a Unicode string.

        Returns tuple (bytearray, num_bytes)

        The errors argument shold be one of &#39;strict&#39;, &#39;ignore&#39;,
        &#39;replace&#39;, &#39;backslashreplace&#39;, or &#39;xmlcharrefreplace&#39;.

        The endianness should either be None (for auto-guessing), or a
        word that starts with &#39;B&#39; (big) or &#39;L&#39; (little).

        Will detect a Byte-Order Mark. If a BOM is found and endianness
        is also set, then the two must match.

        If neither a BOM is found nor endianness is set, then big
        endian order is assumed.

        &#34;&#34;&#34;
        import struct, sys

        maxunicode = sys.maxunicode
        unpack = struct.unpack

        # Detect BOM
        if obj.startswith(utf32.BOM_UTF32_BE):
            bom_endianness = &#34;B&#34;
            start = len(utf32.BOM_UTF32_BE)
        elif obj.startswith(utf32.BOM_UTF32_LE):
            bom_endianness = &#34;L&#34;
            start = len(utf32.BOM_UTF32_LE)
        else:
            bom_endianness = None
            start = 0

        num_bytes = start

        if endianness == None:
            if bom_endianness == None:
                endianness = sys.byteorder.upper()[0]  # Assume platform default
            else:
                endianness = bom_endianness
        else:
            endianness = endianness[0].upper()
            if bom_endianness and endianness != bom_endianness:
                raise UnicodeDecodeError(
                    &#34;utf32&#34;, obj, 0, start, &#34;BOM does not match expected byte order&#34;
                )

        # Check for truncated last character
        if ((len(obj) - start) % 4) != 0:
            raise UnicodeDecodeError(
                &#34;utf32&#34;, obj, start, len(obj), &#34;Data length not a multiple of 4 bytes&#34;
            )

        # Start decoding characters
        chars = []
        packspec = &#34;&gt;L&#34; if endianness == &#34;B&#34; else &#34;&lt;L&#34;
        i = 0
        for i in range(start, len(obj), 4):
            seq = obj[i : i + 4]
            n = unpack(packspec, seq)[0]
            num_bytes += 4

            if n &gt; maxunicode or (0xD800 &lt;= n &lt;= 0xDFFF):
                if errors == &#34;strict&#34;:
                    raise UnicodeDecodeError(
                        &#34;utf32&#34;, obj, i, i + 4, &#34;Invalid code point U+%04X&#34; % n
                    )
                elif errors == &#34;replace&#34;:
                    chars.append(chr(0xFFFD))
                elif errors == &#34;backslashreplace&#34;:
                    if n &gt; 0xFFFF:
                        esc = &#34;\\u%04x&#34; % (n,)
                    else:
                        esc = &#34;\\U%08x&#34; % (n,)
                    for esc_c in esc:
                        chars.append(esc_c)
                elif errors == &#34;xmlcharrefreplace&#34;:
                    esc = &#34;&amp;#%d;&#34; % (n,)
                    for esc_c in esc:
                        chars.append(esc_c)
                else:  # ignore
                    pass
            else:
                chars.append(helpers.safe_unichr(n))
        return (&#34;&#34;.join(chars), num_bytes)

    @staticmethod
    def utf32le_decode(obj, errors=&#34;strict&#34;):
        &#34;&#34;&#34;Decodes a UTF-32LE (little endian) byte string into a Unicode string.&#34;&#34;&#34;
        return utf32.decode(obj, errors=errors, endianness=&#34;L&#34;)

    @staticmethod
    def utf32be_decode(obj, errors=&#34;strict&#34;):
        &#34;&#34;&#34;Decodes a UTF-32BE (big endian) byte string into a Unicode string.&#34;&#34;&#34;
        return utf32.decode(obj, errors=errors, endianness=&#34;B&#34;)


# ----------------------------------------------------------------------
# Helper functions
# ----------------------------------------------------------------------


def _make_unsafe_string_chars():
    import unicodedata

    unsafe = []
    for c in [chr(i) for i in range(0x100)]:
        if c == &#39;&#34;&#39; or c == &#34;\\&#34; or unicodedata.category(c) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]:
            unsafe.append(c)
    return &#34;&#34;.join(unsafe)


class helpers(object):
    &#34;&#34;&#34;A set of utility functions.&#34;&#34;&#34;

    hexdigits = &#34;0123456789ABCDEFabcdef&#34;
    octaldigits = &#34;01234567&#34;
    unsafe_string_chars = _make_unsafe_string_chars()

    import sys

    maxunicode = sys.maxunicode

    always_use_custom_codecs = False  # If True use demjson&#39;s codecs
    # before system codecs. This
    # is mainly here for testing.

    javascript_reserved_words = frozenset(
        [
            # Keywords (plus &#34;let&#34;)  (ECMAScript 6 section 11.6.2.1)
            &#34;break&#34;,
            &#34;case&#34;,
            &#34;catch&#34;,
            &#34;class&#34;,
            &#34;const&#34;,
            &#34;continue&#34;,
            &#34;debugger&#34;,
            &#34;default&#34;,
            &#34;delete&#34;,
            &#34;do&#34;,
            &#34;else&#34;,
            &#34;export&#34;,
            &#34;extends&#34;,
            &#34;finally&#34;,
            &#34;for&#34;,
            &#34;function&#34;,
            &#34;if&#34;,
            &#34;import&#34;,
            &#34;in&#34;,
            &#34;instanceof&#34;,
            &#34;let&#34;,
            &#34;new&#34;,
            &#34;return&#34;,
            &#34;super&#34;,
            &#34;switch&#34;,
            &#34;this&#34;,
            &#34;throw&#34;,
            &#34;try&#34;,
            &#34;typeof&#34;,
            &#34;var&#34;,
            &#34;void&#34;,
            &#34;while&#34;,
            &#34;with&#34;,
            &#34;yield&#34;,
            # Future reserved words (ECMAScript 6 section 11.6.2.2)
            &#34;enum&#34;,
            &#34;implements&#34;,
            &#34;interface&#34;,
            &#34;package&#34;,
            &#34;private&#34;,
            &#34;protected&#34;,
            &#34;public&#34;,
            &#34;static&#34;,
            # null/boolean literals
            &#34;null&#34;,
            &#34;true&#34;,
            &#34;false&#34;,
        ]
    )

    @staticmethod
    def make_raw_bytes(byte_list):
        &#34;&#34;&#34;Constructs a byte array (bytes in Python 3, str in Python 2) from a list of byte values (0-255).&#34;&#34;&#34;
        return _make_raw_bytes(byte_list)

    @staticmethod
    def is_hex_digit(c):
        &#34;&#34;&#34;Determines if the given character is a valid hexadecimal digit (0-9, a-f, A-F).&#34;&#34;&#34;
        return c in helpers.hexdigits

    @staticmethod
    def is_octal_digit(c):
        &#34;&#34;&#34;Determines if the given character is a valid octal digit (0-7).&#34;&#34;&#34;
        return c in helpers.octaldigits

    @staticmethod
    def is_binary_digit(c):
        &#34;&#34;&#34;Determines if the given character is a valid binary digit (0 or 1).&#34;&#34;&#34;
        return c == &#34;0&#34; or c == &#34;1&#34;

    @staticmethod
    def char_is_json_ws(c):
        &#34;&#34;&#34;Determines if the given character is a JSON white-space character&#34;&#34;&#34;
        return c in &#34; \t\n\r&#34;

    @staticmethod
    def safe_unichr(codepoint):
        &#34;&#34;&#34;Just like Python&#39;s unichr() but works in narrow-Unicode Pythons.&#34;&#34;&#34;
        if codepoint &gt;= 0x10000 and codepoint &gt; helpers.maxunicode:
            # Narrow-Unicode python, construct a UTF-16 surrogate pair.
            w1, w2 = helpers.make_surrogate_pair(codepoint)
            if w2 is None:
                c = chr(w1)
            else:
                c = chr(w1) + chr(w2)
        else:
            c = chr(codepoint)
        return c

    @staticmethod
    def char_is_unicode_ws(c):
        &#34;&#34;&#34;Determines if the given character is a Unicode space character&#34;&#34;&#34;
        if not isinstance(c, str):
            c = str(c)
        if c in &#34; \t\n\r\f\v&#34;:
            return True
        import unicodedata

        return unicodedata.category(c) == &#34;Zs&#34;

    @staticmethod
    def char_is_json_eol(c):
        &#34;&#34;&#34;Determines if the given character is a JSON line separator&#34;&#34;&#34;
        return c in &#34;\n\r&#34;

    @staticmethod
    def char_is_unicode_eol(c):
        &#34;&#34;&#34;Determines if the given character is a Unicode line or
        paragraph separator. These correspond to CR and LF as well as
        Unicode characters in the Zl or Zp categories.

        &#34;&#34;&#34;
        return c in &#34;\r\n\u2028\u2029&#34;

    @staticmethod
    def char_is_identifier_leader(c):
        &#34;&#34;&#34;Determines if the character may be the first character of a
        JavaScript identifier.
        &#34;&#34;&#34;
        return c.isalpha() or c in &#34;_$&#34;

    @staticmethod
    def char_is_identifier_tail(c):
        &#34;&#34;&#34;Determines if the character may be part of a JavaScript
        identifier.
        &#34;&#34;&#34;
        return c.isalnum() or c in &#34;_$\u200c\u200d&#34;

    @staticmethod
    def extend_and_flatten_list_with_sep(orig_seq, extension_seq, separator=&#34;&#34;):
        for i, part in enumerate(extension_seq):
            if i &gt; 0 and separator:
                orig_seq.append(separator)
            orig_seq.extend(part)

    @staticmethod
    def strip_format_control_chars(txt):
        &#34;&#34;&#34;Filters out all Unicode format control characters from the string.

        ECMAScript permits any Unicode &#34;format control characters&#34; to
        appear at any place in the source code.  They are to be
        ignored as if they are not there before any other lexical
        tokenization occurs.  Note that JSON does not allow them,
        except within string literals.

        * Ref. ECMAScript section 7.1.
        * http://en.wikipedia.org/wiki/Unicode_control_characters

        There are dozens of Format Control Characters, for example:
            U+00AD   SOFT HYPHEN
            U+200B   ZERO WIDTH SPACE
            U+2060   WORD JOINER

        &#34;&#34;&#34;
        import unicodedata

        txt2 = [c for c in txt if unicodedata.category(str(c)) != &#34;Cf&#34;]

        # 2to3 NOTE: The following is needed to work around a broken
        # Python3 conversion in which filter() will be transformed
        # into a list rather than a string.
        if not isinstance(txt2, str):
            txt2 = &#34;&#34;.join(txt2)
        return txt2

    @staticmethod
    def lookup_codec(encoding):
        &#34;&#34;&#34;Wrapper around codecs.lookup().

        Returns None if codec not found, rather than raising a LookupError.
        &#34;&#34;&#34;
        import codecs

        if isinstance(encoding, codecs.CodecInfo):
            return encoding
        encoding = encoding.lower()
        import codecs

        if helpers.always_use_custom_codecs:
            # Try custom utf32 first, then standard python codecs
            cdk = utf32.lookup(encoding)
            if not cdk:
                try:
                    cdk = codecs.lookup(encoding)
                except LookupError:
                    cdk = None
        else:
            # Try standard python codecs first, then custom utf32
            try:
                cdk = codecs.lookup(encoding)
            except LookupError:
                cdk = utf32.lookup(encoding)
        return cdk

    @staticmethod
    def auto_detect_encoding(s):
        &#34;&#34;&#34;Takes a string (or byte array) and tries to determine the Unicode encoding it is in.

        Returns the encoding name, as a string.

        &#34;&#34;&#34;
        if not s or len(s) == 0:
            return &#34;utf-8&#34;

        # Get the byte values of up to the first 4 bytes
        ords = []
        for i in range(0, min(len(s), 4)):
            x = s[i]
            if isinstance(x, str):
                x = ord(x)
            ords.append(x)

        # Look for BOM marker
        import sys, codecs

        bom2, bom3, bom4 = None, None, None
        if len(s) &gt;= 2:
            bom2 = s[:2]
        if len(s) &gt;= 3:
            bom3 = s[:3]
        if len(s) &gt;= 4:
            bom4 = s[:4]

        # Assign values of first four bytes to: a, b, c, d; and last byte to: z
        a, b, c, d, z = None, None, None, None, None
        if len(s) &gt;= 1:
            a = ords[0]
        if len(s) &gt;= 2:
            b = ords[1]
        if len(s) &gt;= 3:
            c = ords[2]
        if len(s) &gt;= 4:
            d = ords[3]

        z = s[-1]
        if isinstance(z, str):
            z = ord(z)

        if bom4 and (
            (hasattr(codecs, &#34;BOM_UTF32_LE&#34;) and bom4 == codecs.BOM_UTF32_LE)
            or (bom4 == utf32.BOM_UTF32_LE)
        ):
            encoding = &#34;utf-32le&#34;
            s = s[4:]
        elif bom4 and (
            (hasattr(codecs, &#34;BOM_UTF32_BE&#34;) and bom4 == codecs.BOM_UTF32_BE)
            or (bom4 == utf32.BOM_UTF32_BE)
        ):
            encoding = &#34;utf-32be&#34;
            s = s[4:]
        elif bom2 and bom2 == codecs.BOM_UTF16_LE:
            encoding = &#34;utf-16le&#34;
            s = s[2:]
        elif bom2 and bom2 == codecs.BOM_UTF16_BE:
            encoding = &#34;utf-16be&#34;
            s = s[2:]
        elif bom3 and bom3 == codecs.BOM_UTF8:
            encoding = &#34;utf-8&#34;
            s = s[3:]

        # No BOM, so autodetect encoding used by looking at first four
        # bytes according to RFC 4627 section 3.  The first and last bytes
        # in a JSON document will be ASCII.  The second byte will be ASCII
        # unless the first byte was a quotation mark.

        elif (
            len(s) &gt;= 4 and a == 0 and b == 0 and c == 0 and d != 0
        ):  # UTF-32BE  (0 0 0 x)
            encoding = &#34;utf-32be&#34;
        elif (
            len(s) &gt;= 4 and a != 0 and b == 0 and c == 0 and d == 0 and z == 0
        ):  # UTF-32LE  (x 0 0 0 [... 0])
            encoding = &#34;utf-32le&#34;
        elif len(s) &gt;= 2 and a == 0 and b != 0:  # UTF-16BE  (0 x)
            encoding = &#34;utf-16be&#34;
        elif len(s) &gt;= 2 and a != 0 and b == 0 and z == 0:  # UTF-16LE  (x 0 [... 0])
            encoding = &#34;utf-16le&#34;
        elif ord(&#34;\t&#34;) &lt;= a &lt;= 127:
            # First byte appears to be ASCII, so guess UTF-8.
            encoding = &#34;utf8&#34;
        else:
            raise ValueError(&#34;Can not determine the Unicode encoding for byte stream&#34;)

        return encoding

    @staticmethod
    def unicode_decode(txt, encoding=None):
        &#34;&#34;&#34;Takes a string (or byte array) and tries to convert it to a Unicode string.

        Returns a named tuple:  (string, codec, bom)

        The &#39;encoding&#39; argument, if supplied, should either the name of
        a character encoding, or an instance of codecs.CodecInfo.  If
        the encoding argument is None or &#34;auto&#34; then the encoding is
        automatically determined, if possible.

        Any BOM (Byte Order Mark) that is found at the beginning of the
        input will be stripped off and placed in the &#39;bom&#39; portion of
        the returned value.

        &#34;&#34;&#34;
        if isinstance(txt, str):
            res = _namedtuple(&#34;DecodedString&#34;, [&#34;string&#34;, &#34;codec&#34;, &#34;bom&#34;])(
                txt, None, None
            )
        else:
            if encoding is None or encoding == &#34;auto&#34;:
                encoding = helpers.auto_detect_encoding(txt)

            cdk = helpers.lookup_codec(encoding)
            if not cdk:
                raise LookupError(&#34;Can not find codec for encoding %r&#34; % encoding)

            try:
                # Determine if codec takes arguments; try a decode of nothing
                cdk.decode(helpers.make_raw_bytes([]), errors=&#34;strict&#34;)
            except TypeError:
                cdk_kw = {}  # This coded doesn&#39;t like the errors argument
            else:
                cdk_kw = {&#34;errors&#34;: &#34;strict&#34;}

            unitxt, numbytes = cdk.decode(txt, **cdk_kw)  # DO THE DECODE HERE!

            # Remove BOM if present
            if len(unitxt) &gt; 0 and unitxt[0] == &#34;\uFEFF&#34;:
                bom = cdk.encode(unitxt[0])[0]
                unitxt = unitxt[1:]
            elif len(unitxt) &gt; 0 and unitxt[0] == &#34;\uFFFE&#34;:  # Reversed BOM
                raise UnicodeDecodeError(
                    cdk.name, txt, 0, 0, &#34;Wrong byte order, found reversed BOM U+FFFE&#34;
                )
            else:
                bom = None

            res = _namedtuple(&#34;DecodedString&#34;, [&#34;string&#34;, &#34;codec&#34;, &#34;bom&#34;])(
                unitxt, cdk, bom
            )
        return res

    @staticmethod
    def surrogate_pair_as_unicode(c1, c2):
        &#34;&#34;&#34;Takes a pair of unicode surrogates and returns the equivalent unicode character.

        The input pair must be a surrogate pair, with c1 in the range
        U+D800 to U+DBFF and c2 in the range U+DC00 to U+DFFF.

        &#34;&#34;&#34;
        n1, n2 = ord(c1), ord(c2)
        if n1 &lt; 0xD800 or n1 &gt; 0xDBFF or n2 &lt; 0xDC00 or n2 &gt; 0xDFFF:
            raise JSONDecodeError(&#34;illegal Unicode surrogate pair&#34;, (c1, c2))
        a = n1 - 0xD800
        b = n2 - 0xDC00
        v = (a &lt;&lt; 10) | b
        v += 0x10000
        return helpers.safe_unichr(v)

    @staticmethod
    def unicode_as_surrogate_pair(c):
        &#34;&#34;&#34;Takes a single unicode character and returns a sequence of surrogate pairs.

        The output of this function is a tuple consisting of one or two unicode
        characters, such that if the input character is outside the BMP range
        then the output is a two-character surrogate pair representing that character.

        If the input character is inside the BMP then the output tuple will have
        just a single character...the same one.

        &#34;&#34;&#34;
        n = ord(c)
        w1, w2 = helpers.make_surrogate_pair(n)
        if w2 is None:
            return (chr(w1),)
        else:
            return (chr(w1), chr(w2))

    @staticmethod
    def make_surrogate_pair(codepoint):
        &#34;&#34;&#34;Given a Unicode codepoint (int) returns a 2-tuple of surrogate codepoints.&#34;&#34;&#34;
        if codepoint &lt; 0x10000:
            return (codepoint, None)  # in BMP, surrogate pair not required
        v = codepoint - 0x10000
        vh = (v &gt;&gt; 10) &amp; 0x3FF  # highest 10 bits
        vl = v &amp; 0x3FF  # lowest 10 bits
        w1 = 0xD800 | vh
        w2 = 0xDC00 | vl
        return (w1, w2)

    @staticmethod
    def isnumbertype(obj):
        &#34;&#34;&#34;Is the object of a Python number type (excluding complex)?&#34;&#34;&#34;
        return (
            isinstance(obj, (int, float))
            and not isinstance(obj, bool)
            or obj is nan
            or obj is inf
            or obj is neginf
            or (decimal and isinstance(obj, decimal.Decimal))
        )

    @staticmethod
    def is_negzero(n):
        &#34;&#34;&#34;Is the number value a negative zero?&#34;&#34;&#34;
        if isinstance(n, float):
            return n == 0.0 and repr(n).startswith(&#34;-&#34;)
        elif decimal and isinstance(n, decimal.Decimal):
            return n.is_zero() and n.is_signed()
        else:
            return False

    @staticmethod
    def is_nan(n):
        &#34;&#34;&#34;Is the number a NaN (not-a-number)?&#34;&#34;&#34;
        if isinstance(n, float):
            return n is nan or n.hex() == &#34;nan&#34; or n != n
        elif decimal and isinstance(n, decimal.Decimal):
            return n.is_nan()
        else:
            return False

    @staticmethod
    def is_infinite(n):
        &#34;&#34;&#34;Is the number infinite?&#34;&#34;&#34;
        if isinstance(n, float):
            return n is inf or n is neginf or n.hex() in (&#34;inf&#34;, &#34;-inf&#34;)
        elif decimal and isinstance(n, decimal.Decimal):
            return n.is_infinite()
        else:
            return False

    @staticmethod
    def isstringtype(obj):
        &#34;&#34;&#34;Is the object of a Python string type?&#34;&#34;&#34;
        if isinstance(obj, str):
            return True
        # Must also check for some other pseudo-string types
        import types, collections

        return isinstance(obj, (str,)) or isinstance(obj, collections.UserString)
        ## or isinstance(obj, UserString.MutableString)

    @staticmethod
    def decode_hex(hexstring):
        &#34;&#34;&#34;Decodes a hexadecimal string into it&#39;s integer value.&#34;&#34;&#34;
        # We don&#39;t use the builtin &#39;hex&#39; codec in python since it can
        # not handle odd numbers of digits, nor raise the same type
        # of exceptions we want to.
        n = 0
        for c in hexstring:
            if &#34;0&#34; &lt;= c &lt;= &#34;9&#34;:
                d = ord(c) - ord(&#34;0&#34;)
            elif &#34;a&#34; &lt;= c &lt;= &#34;f&#34;:
                d = ord(c) - ord(&#34;a&#34;) + 10
            elif &#34;A&#34; &lt;= c &lt;= &#34;F&#34;:
                d = ord(c) - ord(&#34;A&#34;) + 10
            else:
                raise ValueError(&#34;Not a hexadecimal number&#34;, hexstring)
            # Could use ((n &lt;&lt; 4 ) | d), but python 2.3 issues a FutureWarning.
            n = (n * 16) + d
        return n

    @staticmethod
    def decode_octal(octalstring):
        &#34;&#34;&#34;Decodes an octal string into it&#39;s integer value.&#34;&#34;&#34;
        n = 0
        for c in octalstring:
            if &#34;0&#34; &lt;= c &lt;= &#34;7&#34;:
                d = ord(c) - ord(&#34;0&#34;)
            else:
                raise ValueError(&#34;Not an octal number&#34;, octalstring)
            # Could use ((n &lt;&lt; 3 ) | d), but python 2.3 issues a FutureWarning.
            n = (n * 8) + d
        return n

    @staticmethod
    def decode_binary(binarystring):
        &#34;&#34;&#34;Decodes a binary string into it&#39;s integer value.&#34;&#34;&#34;
        n = 0
        for c in binarystring:
            if c == &#34;0&#34;:
                d = 0
            elif c == &#34;1&#34;:
                d = 1
            else:
                raise ValueError(&#34;Not an binary number&#34;, binarystring)
            # Could use ((n &lt;&lt; 3 ) | d), but python 2.3 issues a FutureWarning.
            n = (n * 2) + d
        return n

    @staticmethod
    def format_timedelta_iso(td):
        &#34;&#34;&#34;Encodes a datetime.timedelta into ISO-8601 Time Period format.&#34;&#34;&#34;
        d = td.days
        s = td.seconds
        ms = td.microseconds
        m, s = divmod(s, 60)
        h, m = divmod(m, 60)
        a = [&#34;P&#34;]
        if d:
            a.append(&#34;%dD&#34; % d)
        if h or m or s or ms:
            a.append(&#34;T&#34;)
        if h:
            a.append(&#34;%dH&#34; % h)
        if m:
            a.append(&#34;%dM&#34; % m)
        if s or ms:
            if ms:
                a.append(&#34;%d.%06d&#34; % (s, ms))
            else:
                a.append(&#34;%d&#34; % s)
        if len(a) == 1:
            a.append(&#34;T0S&#34;)
        return &#34;&#34;.join(a)


# ----------------------------------------------------------------------
# File position indicator
# ----------------------------------------------------------------------


class position_marker(object):
    &#34;&#34;&#34;A position marks a specific place in a text document.
    It consists of the following attributes:

        * line - The line number, starting at 1
        * column - The column on the line, starting at 0
        * char_position - The number of characters from the start of
                          the document, starting at 0
        * text_after - (optional) a short excerpt of the text of
                       document starting at the current position

    Lines are separated by any Unicode line separator character. As an
    exception a CR+LF character pair is treated as being a single line
    separator demarcation.

    Columns are simply a measure of the number of characters after the
    start of a new line, starting at 0.  Visual effects caused by
    Unicode characters such as combining characters, bidirectional
    text, zero-width characters and so on do not affect the
    computation of the column regardless of visual appearance.

    The char_position is a count of the number of characters since the
    beginning of the document, starting at 0. As used within the
    buffered_stream class, if the document starts with a Unicode Byte
    Order Mark (BOM), the BOM prefix is NOT INCLUDED in the count.

    &#34;&#34;&#34;

    def __init__(self, offset=0, line=1, column=0, text_after=None):
        self.__char_position = offset
        self.__line = line
        self.__column = column
        self.__text_after = text_after
        self.__at_end = False
        self.__last_was_cr = False

    @property
    def line(self):
        &#34;&#34;&#34;The current line within the document, starts at 1.&#34;&#34;&#34;
        return self.__line

    @property
    def column(self):
        &#34;&#34;&#34;The current character column from the beginning of the
        document, starts at 0.
        &#34;&#34;&#34;
        return self.__column

    @property
    def char_position(self):
        &#34;&#34;&#34;The current character offset from the beginning of the
        document, starts at 0.
        &#34;&#34;&#34;
        return self.__char_position

    @property
    def at_start(self):
        &#34;&#34;&#34;Returns True if the position is at the start of the document.&#34;&#34;&#34;
        return self.char_position == 0

    @property
    def at_end(self):
        &#34;&#34;&#34;Returns True if the position is at the end of the document.

        This property must be set by the user.
        &#34;&#34;&#34;
        return self.__at_end

    @at_end.setter
    def at_end(self, b):
        &#34;&#34;&#34;Sets the at_end property to True or False.&#34;&#34;&#34;
        self.__at_end = bool(b)

    @property
    def text_after(self):
        &#34;&#34;&#34;Returns a textual excerpt starting at the current position.

        This property must be set by the user.
        &#34;&#34;&#34;
        return self.__at_end

    @text_after.setter
    def text_after(self, value):
        &#34;&#34;&#34;Sets the text_after property to a given string.&#34;&#34;&#34;
        self.__text_after = value

    def __repr__(self):
        s = &#34;%s(offset=%r,line=%r,column=%r&#34; % (
            self.__class__.__name__,
            self.__char_position,
            self.__line,
            self.__column,
        )
        if self.text_after:
            s += &#34;,text_after=%r&#34; % (self.text_after,)
        s += &#34;)&#34;
        return s

    def describe(self, show_text=True):
        &#34;&#34;&#34;Returns a human-readable description of the position, in English.&#34;&#34;&#34;
        s = &#34;line %d, column %d, offset %d&#34; % (
            self.__line,
            self.__column,
            self.__char_position,
        )
        if self.at_start:
            s += &#34; (AT-START)&#34;
        elif self.at_end:
            s += &#34; (AT-END)&#34;
        if show_text and self.text_after:
            s += &#34;, text %r&#34; % (self.text_after)
        return s

    def __str__(self):
        &#34;&#34;&#34;Same as the describe() function.&#34;&#34;&#34;
        return self.describe(show_text=True)

    def copy(self):
        &#34;&#34;&#34;Create a copy of the position object.&#34;&#34;&#34;
        p = self.__class__()
        p.__char_position = self.__char_position
        p.__line = self.__line
        p.__column = self.__column
        p.text_after = self.__text_after
        p.at_end = self.at_end
        p.__last_was_cr = self.__last_was_cr
        return p

    def rewind(self):
        &#34;&#34;&#34;Set the position to the start of the document.&#34;&#34;&#34;
        if not self.at_start:
            self.text_after = None
            self.at_end = False
        self.__char_position = 0
        self.__line = 1
        self.__column = 0
        self.__last_was_cr = False

    def advance(self, s):
        &#34;&#34;&#34;Advance the position from its current place according to
        the given string of characters.

        &#34;&#34;&#34;
        if s:
            self.text_after = None
        for c in s:
            self.__char_position += 1
            if c == &#34;\n&#34; and self.__last_was_cr:
                self.__last_was_cr = False
            elif helpers.char_is_unicode_eol(c):
                self.__line += 1
                self.__column = 0
                self.__last_was_cr = c == &#34;\r&#34;
            else:
                self.__column += 1
                self.__last_was_cr = False


# ----------------------------------------------------------------------
# Buffered Stream Reader
# ----------------------------------------------------------------------


class buffered_stream(object):
    &#34;&#34;&#34;A helper class for the JSON parser.

    It allows for reading an input document, while handling some
    low-level Unicode issues as well as tracking the current position
    in terms of line and column position.

    &#34;&#34;&#34;

    def __init__(self, txt=&#34;&#34;, encoding=None):
        self.reset()
        self.set_text(txt, encoding)

    def reset(self):
        &#34;&#34;&#34;Clears the state to nothing.&#34;&#34;&#34;
        self.__pos = position_marker()
        self.__saved_pos = []  # Stack of saved positions
        self.__bom = helpers.make_raw_bytes(
            []
        )  # contains copy of byte-order mark, if any
        self.__codec = None  # The CodecInfo
        self.__encoding = None  # The name of the codec&#39;s encoding
        self.__input_is_bytes = False
        self.__rawbuf = None
        self.__raw_bytes = None
        self.__cmax = 0
        self.num_ws_skipped = 0

    def save_position(self):
        self.__saved_pos.append(self.__pos.copy())
        return True

    def clear_saved_position(self):
        if self.__saved_pos:
            self.__saved_pos.pop()
            return True
        else:
            return False

    def restore_position(self):
        try:
            old_pos = self.__saved_pos.pop()  # Can raise IndexError
        except IndexError as err:
            raise IndexError(&#34;Attempt to restore buffer position that was never saved&#34;)
        else:
            self.__pos = old_pos
            return True

    def _find_codec(self, encoding):
        if encoding is None:
            self.__codec = None
            self.__encoding = None
        elif isinstance(encoding, codecs.CodecInfo):
            self.__codec = encoding
            self.__encoding = self.__codec.name
        else:
            self.__encoding = encoding
            self.__codec = helpers.lookup_codec(encoding)
            if not self.__codec:
                raise JSONDecodeError(
                    &#34;no codec available for character encoding&#34;, encoding
                )
        return self.__codec

    def set_text(self, txt, encoding=None):
        &#34;&#34;&#34;Changes the input text document and rewinds the position to
        the start of the new document.

        &#34;&#34;&#34;
        import sys

        self.rewind()
        self.__codec = None
        self.__bom = None
        self.__rawbuf = &#34;&#34;
        self.__cmax = 0  # max number of chars in input
        try:
            decoded = helpers.unicode_decode(txt, encoding)
        except JSONError:
            raise
        except Exception as err:
            # Re-raise as a JSONDecodeError
            newerr = JSONDecodeError(&#34;a Unicode decoding error occurred&#34;)
            raise newerr from err
        else:
            self.__codec = decoded.codec
            self.__bom = decoded.bom
            self.__rawbuf = decoded.string
            self.__cmax = len(self.__rawbuf)

    def __repr__(self):
        return &#34;&lt;%s at %r text %r&gt;&#34; % (
            self.__class__.__name__,
            self.__pos,
            self.text_context,
        )

    def rewind(self):
        &#34;&#34;&#34;Resets the position back to the start of the input text.&#34;&#34;&#34;
        self.__pos.rewind()

    @property
    def codec(self):
        &#34;&#34;&#34;The codec object used to perform Unicode decoding, or None.&#34;&#34;&#34;
        return self.__codec

    @property
    def bom(self):
        &#34;&#34;&#34;The Unicode Byte-Order Mark (BOM), if any, that was present
        at the start of the input text.  The returned BOM is a string
        of the raw bytes, and is not Unicode-decoded.

        &#34;&#34;&#34;
        return self.__bom

    @property
    def cpos(self):
        &#34;&#34;&#34;The current character offset from the start of the document.&#34;&#34;&#34;
        return self.__pos.char_position

    @property
    def position(self):
        &#34;&#34;&#34;The current position (as a position_marker object).
        Returns a copy.

        &#34;&#34;&#34;
        p = self.__pos.copy()
        p.text_after = self.text_context
        p.at_end = self.at_end
        return p

    @property
    def at_start(self):
        &#34;&#34;&#34;Returns True if the position is currently at the start of
        the document, or False otherwise.

        &#34;&#34;&#34;
        return self.__pos.at_start

    @property
    def at_end(self):
        &#34;&#34;&#34;Returns True if the position is currently at the end of the
        document, of False otherwise.

        &#34;&#34;&#34;
        c = self.peek()
        return not c

    def at_ws(self, allow_unicode_whitespace=True):
        &#34;&#34;&#34;Returns True if the current position contains a white-space
        character.

        &#34;&#34;&#34;
        c = self.peek()
        if not c:
            return False
        elif allow_unicode_whitespace:
            return helpers.char_is_unicode_ws(c)
        else:
            return helpers.char_is_json_ws(c)

    def at_eol(self, allow_unicode_eol=True):
        &#34;&#34;&#34;Returns True if the current position contains an
        end-of-line control character.

        &#34;&#34;&#34;
        c = self.peek()
        if not c:
            return True  # End of file is treated as end of line
        elif allow_unicode_eol:
            return helpers.char_is_unicode_eol(c)
        else:
            return helpers.char_is_json_eol(c)

    def peek(self, offset=0):
        &#34;&#34;&#34;Returns the character at the current position, or at a
        given offset away from the current position.  If the position
        is beyond the limits of the document size, then an empty
        string &#39;&#39; is returned.

        &#34;&#34;&#34;
        i = self.cpos + offset
        if i &lt; 0 or i &gt;= self.__cmax:
            return &#34;&#34;
        return self.__rawbuf[i]

    def peekstr(self, span=1, offset=0):
        &#34;&#34;&#34;Returns one or more characters starting at the current
        position, or at a given offset away from the current position,
        and continuing for the given span length.  If the offset and
        span go outside the limit of the current document size, then
        the returned string may be shorter than the requested span
        length.

        &#34;&#34;&#34;
        i = self.cpos + offset
        j = i + span
        if i &lt; 0 or i &gt;= self.__cmax:
            return &#34;&#34;
        return self.__rawbuf[i:j]

    @property
    def text_context(self, context_size=20):
        &#34;&#34;&#34;A short human-readable textual excerpt of the document at
        the current position, in English.

        &#34;&#34;&#34;
        context_size = max(context_size, 4)
        s = self.peekstr(context_size + 1)
        if not s:
            return &#34;&#34;
        if len(s) &gt; context_size:
            s = s[: context_size - 3] + &#34;...&#34;
        return s

    def startswith(self, s):
        &#34;&#34;&#34;Determines if the text at the current position starts with
        the given string.

        See also method: pop_if_startswith()

        &#34;&#34;&#34;
        s2 = self.peekstr(len(s))
        return s == s2

    def skip(self, span=1):
        &#34;&#34;&#34;Advances the current position by one (or the given number)
        of characters.  Will not advance beyond the end of the
        document.  Returns the number of characters skipped.

        &#34;&#34;&#34;

        i = self.cpos
        self.__pos.advance(self.peekstr(span))
        return self.cpos - i

    def skipuntil(self, testfn):
        &#34;&#34;&#34;Advances the current position until a given predicate test
        function succeeds, or the end of the document is reached.

        Returns the actual number of characters skipped.

        The provided test function should take a single unicode
        character and return a boolean value, such as:

            lambda c : c == &#39;.&#39;   # Skip to next period

        See also methods: skipwhile() and popuntil()

        &#34;&#34;&#34;
        i = self.cpos
        while True:
            c = self.peek()
            if not c or testfn(c):
                break
            else:
                self.__pos.advance(c)
        return self.cpos - i

    def skipwhile(self, testfn):
        &#34;&#34;&#34;Advances the current position until a given predicate test
        function fails, or the end of the document is reached.

        Returns the actual number of characters skipped.

        The provided test function should take a single unicode
        character and return a boolean value, such as:

            lambda c : c.isdigit()   # Skip all digits

        See also methods: skipuntil() and popwhile()

        &#34;&#34;&#34;
        return self.skipuntil(lambda c: not testfn(c))

    def skip_to_next_line(self, allow_unicode_eol=True):
        &#34;&#34;&#34;Advances the current position to the start of the next
        line.  Will not advance beyond the end of the file.  Note that
        the two-character sequence CR+LF is recognized as being just a
        single end-of-line marker.

        &#34;&#34;&#34;
        ln = self.__pos.line
        while True:
            c = self.pop()
            if not c or self.__pos.line &gt; ln:
                if c == &#34;\r&#34; and self.peek() == &#34;\n&#34;:
                    self.skip()
                break

    def skipws(self, allow_unicode_whitespace=True):
        &#34;&#34;&#34;Advances the current position past all whitespace, or until
        the end of the document is reached.

        &#34;&#34;&#34;
        if allow_unicode_whitespace:
            n = self.skipwhile(helpers.char_is_unicode_ws)
        else:
            n = self.skipwhile(helpers.char_is_json_ws)
        self.num_ws_skipped += n
        return n

    def pop(self):
        &#34;&#34;&#34;Returns the character at the current position and advances
        the position to the next character.  At the end of the
        document this function returns an empty string.

        &#34;&#34;&#34;
        c = self.peek()
        if c:
            self.__pos.advance(c)
        return c

    def popstr(self, span=1, offset=0):
        &#34;&#34;&#34;Returns a string of one or more characters starting at the
        current position, and advances the position to the following
        character after the span.  Will not go beyond the end of the
        document, so the returned string may be shorter than the
        requested span.

        &#34;&#34;&#34;
        s = self.peekstr(span)
        if s:
            self.__pos.advance(s)
        return s

    def popif(self, testfn):
        &#34;&#34;&#34;Just like the pop() function, but only returns the
        character if the given predicate test function succeeds.
        &#34;&#34;&#34;
        c = self.peek()
        if c and testfn(c):
            self.__pos.advance(c)
            return c
        return &#34;&#34;

    def pop_while_in(self, chars):
        &#34;&#34;&#34;Pops a sequence of characters at the current position
        as long as each of them is in the given set of characters.

        &#34;&#34;&#34;
        if not isinstance(chars, (set, frozenset)):
            chars = set(chars)
        c = self.peek()
        if c and c in chars:
            s = self.popwhile(lambda c: c and c in chars)
            return s
        return None

    def pop_identifier(self, match=None):
        &#34;&#34;&#34;Pops the sequence of characters at the current position
        that match the syntax for a JavaScript identifier.

        &#34;&#34;&#34;
        c = self.peek()
        if c and helpers.char_is_identifier_leader(c):
            s = self.popwhile(helpers.char_is_identifier_tail)
            return s
        return None

    def pop_if_startswith(self, s):
        &#34;&#34;&#34;Pops the sequence of characters if they match the given string.

        See also method: startswith()

        &#34;&#34;&#34;
        s2 = self.peekstr(len(s))
        if s2 != s:
            return None
        self.__pos.advance(s2)
        return s2

    def popwhile(self, testfn, maxchars=None):
        &#34;&#34;&#34;Pops all the characters starting at the current position as
        long as each character passes the given predicate function
        test.  If maxchars a numeric value instead of None then then
        no more than that number of characters will be popped
        regardless of the predicate test.

        See also methods: skipwhile() and popuntil()

        &#34;&#34;&#34;
        s = []
        i = 0
        while maxchars is None or i &lt; maxchars:
            c = self.popif(testfn)
            if not c:
                break
            s.append(c)
            i += 1
        return &#34;&#34;.join(s)

    def popuntil(self, testfn, maxchars=None):
        &#34;&#34;&#34;Just like popwhile() method except the predicate function
        should return True to stop the sequence rather than False.

        See also methods: skipuntil() and popwhile()

        &#34;&#34;&#34;
        return self.popwhile(lambda c: not testfn(c), maxchars=maxchars)

    def __getitem__(self, index):
        &#34;&#34;&#34;Returns the character at the given index relative to the current position.

        If the index goes beyond the end of the input, or prior to the
        start when negative, then &#39;&#39; is returned.

        If the index provided is a slice object, then that range of
        characters is returned as a string. Note that a stride value other
        than 1 is not supported in the slice.  To use a slice, do:

            s = my_stream[ 1:4 ]

        &#34;&#34;&#34;
        if isinstance(index, slice):
            return self.peekstr(index.stop - index.start, index.start)
        else:
            return self.peek(index)


# ----------------------------------------------------------------------
# Exception classes.
# ----------------------------------------------------------------------


class JSONException(Exception):
    &#34;&#34;&#34;Base class for all JSON-related exceptions.&#34;&#34;&#34;

    pass


class JSONSkipHook(JSONException):
    &#34;&#34;&#34;An exception to be raised by user-defined code within hook
    callbacks to indicate the callback does not want to handle the
    situation.

    &#34;&#34;&#34;

    pass


class JSONStopProcessing(JSONException):
    &#34;&#34;&#34;Can be raised by anyplace, including inside a hook function, to
    cause the entire encode or decode process to immediately stop
    with an error.

    &#34;&#34;&#34;

    pass


class JSONAbort(JSONException):
    pass


class JSONError(JSONException):
    &#34;&#34;&#34;Base class for all JSON-related errors.

    In addition to standard Python exceptions, these exceptions may
    also have additional properties:

        * severity - One of: &#39;fatal&#39;, &#39;error&#39;, &#39;warning&#39;, &#39;info&#39;
        * position - An indication of the position in the input where the error occured.
        * outer_position - A secondary position (optional) that gives
          the location of the outer data item in which the error
          occured, such as the beginning of a string or an array.
        * context_description - A string that identifies the context
          in which the error occured.  Default is &#34;Context&#34;.
    &#34;&#34;&#34;

    severities = frozenset([&#34;fatal&#34;, &#34;error&#34;, &#34;warning&#34;, &#34;info&#34;])

    def __init__(self, message, *args, **kwargs):
        self.severity = &#34;error&#34;
        self._position = None
        self.outer_position = None
        self.context_description = None
        for kw, val in list(kwargs.items()):
            if kw == &#34;severity&#34;:
                if val not in self.severities:
                    raise TypeError(
                        &#34;%s given invalid severity %r&#34; % (self.__class__.__name__, val)
                    )
                self.severity = val
            elif kw == &#34;position&#34;:
                self.position = val
            elif kw == &#34;outer_position&#34;:
                self.outer_position = val
            elif kw == &#34;context_description&#34; or kw == &#34;context&#34;:
                self.context_description = val
            else:
                raise TypeError(
                    &#34;%s does not accept %r keyword argument&#34;
                    % (self.__class__.__name__, kw)
                )
        super(JSONError, self).__init__(message, *args)
        self.message = message

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, pos):
        if pos == 0:
            self._position = 0  # position_marker() # start of input
        else:
            self._position = pos

    def __repr__(self):
        s = &#34;%s(%r&#34; % (self.__class__.__name__, self.message)
        for a in self.args[1:]:
            s += &#34;, %r&#34; % (a,)
        if self.position:
            s += &#34;, position=%r&#34; % (self.position,)
        if self.outer_position:
            s += &#34;, outer_position=%r&#34; % (self.outer_position,)
        s += &#34;, severity=%r)&#34; % (self.severity,)
        return s

    def pretty_description(self, show_positions=True, filename=None):
        if filename:
            pfx = filename.rstrip().rstrip(&#34;:&#34;) + &#34;:&#34;
        else:
            pfx = &#34;&#34;
        # Print file position as numeric abbreviation
        err = pfx
        if self.position == 0:
            err += &#34;0:0:&#34;
        elif self.position:
            err += &#34;%d:%d:&#34; % (self.position.line, self.position.column)
        else:
            err += &#34;    &#34;
        # Print severity and main error message
        err += &#34; %s: %s&#34; % (self.severity.capitalize(), self.message)
        if len(self.args) &gt; 1:
            err += &#34;: &#34;
            for anum, a in enumerate(self.args[1:]):
                if anum &gt; 1:
                    err += &#34;, &#34;
                astr = repr(a)
                if len(astr) &gt; 30:
                    astr = astr[:30] + &#34;...&#34;
                err += astr
        # Print out exception chain
        e2 = self
        while e2:
            if hasattr(e2, &#34;__cause__&#34;) and isinstance(e2.__cause__, Exception):
                e2 = e2.__cause__
                e2desc = str(e2).strip()
                if not e2desc:
                    e2desc = repr(e2).strip()
                err += &#34;\n   |  Cause: %s&#34; % e2desc.strip().replace(
                    &#34;\n&#34;, &#34;\n   |         &#34;
                )
            else:
                e2 = None
        # Show file position
        if show_positions and self.position is not None:
            if self.position == 0:
                err += &#34;\n   |  At start of input&#34;
            else:
                err += &#34;\n   |  At %s&#34; % (self.position.describe(show_text=False),)
                if self.position.text_after:
                    err += &#34;\n   |    near text: %r&#34; % (self.position.text_after,)
        # Show context
        if show_positions and self.outer_position:
            if self.context_description:
                cdesc = self.context_description.capitalize()
            else:
                cdesc = &#34;Context&#34;
            err += &#34;\n   |  %s started at %s&#34; % (
                cdesc,
                self.outer_position.describe(show_text=False),
            )
            if self.outer_position.text_after:
                err += &#34;\n   |    with text: %r&#34; % (self.outer_position.text_after,)
        return err


class JSONDecodeError(JSONError):
    &#34;&#34;&#34;An exception class raised when a JSON decoding error (syntax error) occurs.&#34;&#34;&#34;

    pass


class JSONDecodeHookError(JSONDecodeError):
    &#34;&#34;&#34;An exception that occured within a decoder hook.

    The original exception is available in the &#39;hook_exception&#39; attribute.
    &#34;&#34;&#34;

    def __init__(self, hook_name, exc_info, encoded_obj, *args, **kwargs):
        self.hook_name = hook_name
        if not exc_info:
            exc_info = (None, None, None)
        exc_type, self.hook_exception, self.hook_traceback = exc_info
        self.object_type = type(encoded_obj)
        msg = &#34;Hook %s raised %r while decoding type &lt;%s&gt;&#34; % (
            hook_name,
            self.hook_exception.__class__.__name__
            if self.hook_exception is not None
            else None,
            self.object_type.__name__,
        )
        if len(args) &gt;= 1:
            msg += &#34;: &#34; + str(args[0])
            args = args[1:]
        super(JSONDecodeHookError, self).__init__(msg, *args, **kwargs)


class JSONEncodeError(JSONError):
    &#34;&#34;&#34;An exception class raised when a python object can not be encoded as a JSON string.&#34;&#34;&#34;

    pass


class JSONEncodeHookError(JSONEncodeError):
    &#34;&#34;&#34;An exception that occured within an encoder hook.

    The original exception is available in the &#39;hook_exception&#39; attribute.
    &#34;&#34;&#34;

    def __init__(self, hook_name, exc_info, encoded_obj, *args, **kwargs):
        self.hook_name = hook_name
        if not exc_info:
            exc_info = (None, None, None)
        exc_type, self.hook_exception, self.hook_traceback = exc_info
        self.object_type = type(encoded_obj)
        msg = &#34;Hook %s raised %r while encoding type &lt;%s&gt;&#34; % (
            self.hook_name,
            self.hook_exception.__class__.__name__
            if self.hook_exception is not None
            else None,
            self.object_type.__name__,
        )
        if len(args) &gt;= 1:
            msg += &#34;: &#34; + str(args[0])
            args = args[1:]
        super(JSONEncodeHookError, self).__init__(msg, *args, **kwargs)


# ----------------------------------------------------------------------
# Encoder state object
# ----------------------------------------------------------------------


class encode_state(object):
    &#34;&#34;&#34;An internal transient object used during JSON encoding to
    record the current construction state.

    &#34;&#34;&#34;

    def __init__(self, jsopts=None, parent=None):
        import sys

        self.chunks = []
        if not parent:
            self.parent = None
            self.nest_level = 0
            self.options = jsopts
            self.escape_unicode_test = False  # or a function f(unichar)=&gt;True/False
        else:
            self.parent = parent
            self.nest_level = parent.nest_level + 1
            self.escape_unicode_test = parent.escape_unicode_test
            self.options = parent.options

    def make_substate(self):
        return encode_state(parent=self)

    def join_substate(self, other_state):
        self.chunks.extend(other_state.chunks)
        other_state.chunks = []

    def append(self, s):
        &#34;&#34;&#34;Adds a string to the end of the current JSON document&#34;&#34;&#34;
        self.chunks.append(s)

    def combine(self):
        &#34;&#34;&#34;Returns the accumulated string and resets the state to empty&#34;&#34;&#34;
        s = &#34;&#34;.join(self.chunks)
        self.chunks = []
        return s

    def __eq__(self, other_state):
        return (
            self.nest_level == other_state.nest_level
            and self.chunks == other_state.chunks
        )

    def __lt__(self, other_state):
        if self.nest_level != other_state.nest_level:
            return self.nest_level &lt; other_state.nest_level
        return self.chunks &lt; other_state.chunks


# ----------------------------------------------------------------------
# Decoder statistics
# ----------------------------------------------------------------------


class decode_statistics(object):
    &#34;&#34;&#34;An object that records various statistics about a decoded JSON document.&#34;&#34;&#34;

    int8_max = 0x7F
    int8_min = -0x7F - 1
    int16_max = 0x7FFF
    int16_min = -0x7FFF - 1
    int32_max = 0x7FFFFFFF
    int32_min = -0x7FFFFFFF - 1
    int64_max = 0x7FFFFFFFFFFFFFFF
    int64_min = -0x7FFFFFFFFFFFFFFF - 1

    double_int_max = 2 ** 53 - 1
    double_int_min = -(2 ** 53 - 1)

    def __init__(self):
        # Nesting
        self.max_depth = 0
        self.max_items_in_array = 0
        self.max_items_in_object = 0
        # Integer stats
        self.num_ints = 0
        self.num_ints_8bit = 0
        self.num_ints_16bit = 0
        self.num_ints_32bit = 0
        self.num_ints_53bit = 0  # ints which will overflow IEEE doubles
        self.num_ints_64bit = 0
        self.num_ints_long = 0
        self.num_negative_zero_ints = 0
        self.total_chars = 0
        # Floating-point stats
        self.num_negative_zero_floats = 0
        self.num_floats = 0
        self.num_floats_decimal = 0  # overflowed &#39;float&#39;
        # String stats
        self.num_strings = 0
        self.max_string_length = 0
        self.total_string_length = 0
        self.min_codepoint = None
        self.max_codepoint = None
        # Other data type stats
        self.num_arrays = 0
        self.num_objects = 0
        self.num_bools = 0
        self.num_nulls = 0
        self.num_undefineds = 0
        self.num_nans = 0
        self.num_infinities = 0
        self.num_comments = 0
        self.num_identifiers = 0  # JavaScript identifiers
        self.num_excess_whitespace = 0

    @property
    def num_infinites(self):
        &#34;&#34;&#34;Misspelled &#39;num_infinities&#39; for backwards compatibility&#34;&#34;&#34;
        return self.num_infinities

    def pretty_description(self, prefix=&#34;&#34;):
        import unicodedata

        lines = [
            &#34;Number of integers:&#34;,
            &#34;    8-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_8bit, self.int8_min, self.int8_max),
            &#34;   16-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_16bit, self.int16_min, self.int16_max),
            &#34;   32-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_32bit, self.int32_min, self.int32_max),
            &#34; &gt; 53-bit:     %5d   (%d to %d - overflows JavaScript)&#34;
            % (self.num_ints_53bit, self.double_int_min, self.double_int_max),
            &#34;   64-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_64bit, self.int64_min, self.int64_max),
            &#39; &gt; 64 bit:     %5d   (not portable, may require a &#34;Big Num&#34; package)&#39;
            % self.num_ints_long,
            &#34;   total ints: %5d&#34; % self.num_ints,
            &#34;   Num -0:     %5d   (negative-zero integers are not portable)&#34;
            % self.num_negative_zero_ints,
            &#34;Number of floats:&#34;,
            &#34;   doubles:    %5d&#34; % self.num_floats,
            &#34; &gt; doubles:    %5d   (will overflow IEEE doubles)&#34;
            % self.num_floats_decimal,
            &#34;   total flts: %5d&#34; % (self.num_floats + self.num_floats_decimal),
            &#34;   Num -0.0:   %5d   (negative-zero floats are usually portable)&#34;
            % self.num_negative_zero_floats,
            &#34;Number of:&#34;,
            &#34;   nulls:      %5d&#34; % self.num_nulls,
            &#34;   booleans:   %5d&#34; % self.num_bools,
            &#34;   arrays:     %5d&#34; % self.num_arrays,
            &#34;   objects:    %5d&#34; % self.num_objects,
            &#34;Strings:&#34;,
            &#34;   number:         %5d strings&#34; % self.num_strings,
            &#34;   max length:     %5d characters&#34; % self.max_string_length,
            &#34;   total chars:    %5d across all strings&#34; % self.total_string_length,
        ]

        if self.min_codepoint is not None:
            cp = &#34;U+%04X&#34; % self.min_codepoint
            try:
                charname = unicodedata.name(chr(self.min_codepoint))
            except ValueError:
                charname = &#34;? UNKNOWN CHARACTER&#34;
            lines.append(&#34;   min codepoint: %6s  (%s)&#34; % (cp, charname))
        else:
            lines.append(&#34;   min codepoint: %6s&#34; % (&#34;n/a&#34;,))

        if self.max_codepoint is not None:
            cp = &#34;U+%04X&#34; % self.max_codepoint
            try:
                charname = unicodedata.name(chr(self.max_codepoint))
            except ValueError:
                charname = &#34;? UNKNOWN CHARACTER&#34;
            lines.append(&#34;   max codepoint: %6s  (%s)&#34; % (cp, charname))
        else:
            lines.append(&#34;   max codepoint: %6s&#34; % (&#34;n/a&#34;,))

        lines.extend(
            [
                &#34;Other JavaScript items:&#34;,
                &#34;   NaN:         %5d&#34; % self.num_nans,
                &#34;   Infinite:    %5d&#34; % self.num_infinities,
                &#34;   undefined:   %5d&#34; % self.num_undefineds,
                &#34;   Comments:    %5d&#34; % self.num_comments,
                &#34;   Identifiers: %5d&#34; % self.num_identifiers,
                &#34;Max items in any array: %5d&#34; % self.max_items_in_array,
                &#34;Max keys in any object: %5d&#34; % self.max_items_in_object,
                &#34;Max nesting depth:      %5d&#34; % self.max_depth,
            ]
        )
        if self.total_chars == 0:
            lines.append(&#34;Unnecessary whitespace:     0 of 0 characters&#34;)
        else:
            lines.append(
                &#34;Unnecessary whitespace: %5d of %d characters (%.2f%%)&#34;
                % (
                    self.num_excess_whitespace,
                    self.total_chars,
                    self.num_excess_whitespace * 100.0 / self.total_chars,
                )
            )
        if prefix:
            return &#34;\n&#34;.join([prefix + s for s in lines]) + &#34;\n&#34;
        else:
            return &#34;\n&#34;.join(lines) + &#34;\n&#34;


# ----------------------------------------------------------------------
# Decoder state object
# ----------------------------------------------------------------------


class decode_state(object):
    &#34;&#34;&#34;An internal transient object used during JSON decoding to
    record the current parsing state and error messages.

    &#34;&#34;&#34;

    def __init__(self, options=None):
        self.reset()
        self.options = options

    def reset(self):
        &#34;&#34;&#34;Clears all errors, statistics, and input text.&#34;&#34;&#34;
        self.buf = None
        self.errors = []
        self.obj = None
        self.cur_depth = 0  # how deep in nested structures are we?
        self.stats = decode_statistics()
        self._have_warned_nonbmp = False
        self._have_warned_long_string = False
        self._have_warned_max_depth = False

    @property
    def should_stop(self):
        if self.has_fatal:
            return True
        return False

    @property
    def has_errors(self):
        &#34;&#34;&#34;Have any errors been seen already?&#34;&#34;&#34;
        return (
            len([err for err in self.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)]) &gt; 0
        )

    @property
    def has_fatal(self):
        &#34;&#34;&#34;Have any errors been seen already?&#34;&#34;&#34;
        return len([err for err in self.errors if err.severity in (&#34;fatal&#34;,)]) &gt; 0

    def set_input(self, txt, encoding=None):
        &#34;&#34;&#34;Initialize the state by setting the input document text.&#34;&#34;&#34;
        import sys

        self.reset()
        try:
            self.buf = buffered_stream(txt, encoding=encoding)
        except JSONError as err:
            err.position = 0  # set position to start of file
            err.severity = &#34;fatal&#34;
            self.push_exception(err)
        except Exception as err:
            # Re-raise as JSONDecodeError
            e2 = sys.exc_info()
            newerr = JSONDecodeError(
                &#34;Error while reading input&#34;, position=0, severity=&#34;fatal&#34;
            )
            self.push_exception(err)
            self.buf = None
        else:
            if self.buf.bom:
                self.push_cond(
                    self.options.bom,
                    &#34;JSON document was prefixed by a BOM (Byte Order Mark)&#34;,
                    self.buf.bom,
                )
        if not self.buf:
            self.push_fatal(&#34;Aborting, can not read JSON document.&#34;, position=0)

    def push_exception(self, exc):
        &#34;&#34;&#34;Add an already-built exception to the error list.&#34;&#34;&#34;
        self.errors.append(exc)

    def push_fatal(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create a fatal error.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;fatal&#34;
        self.__push_err(message, *args, **kwargs)

    def push_error(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create an error.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;error&#34;
        self.__push_err(message, *args, **kwargs)

    def push_warning(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create a warning.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;warning&#34;
        self.__push_err(message, *args, **kwargs)

    def push_info(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create a informational message.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;info&#34;
        self.__push_err(message, *args, **kwargs)

    def push_cond(self, behavior_value, message, *args, **kwargs):
        &#34;&#34;&#34;Creates an conditional error or warning message.

        The behavior value (from json_options) controls whether
        a message will be pushed and whether it is an error
        or warning message.

        &#34;&#34;&#34;
        if behavior_value == ALLOW:
            return
        elif behavior_value == WARN:
            kwargs[&#34;severity&#34;] = &#34;warning&#34;
        else:
            kwargs[&#34;severity&#34;] = &#34;error&#34;
        self.__push_err(message, *args, **kwargs)

    def __push_err(self, message, *args, **kwargs):
        &#34;&#34;&#34;Stores an error in the error list.&#34;&#34;&#34;
        position = None
        outer_position = None
        severity = &#34;error&#34;
        context_description = None
        for kw, val in list(kwargs.items()):
            if kw == &#34;position&#34;:
                position = val
            elif kw == &#34;outer_position&#34;:
                outer_position = val
            elif kw == &#34;severity&#34;:
                severity = val
            elif kw == &#34;context_description&#34; or kw == &#34;context&#34;:
                context_description = val
            else:
                raise TypeError(&#34;Unknown keyword argument&#34;, kw)
        if position is None and self.buf:
            position = self.buf.position  # Current position
        err = JSONDecodeError(
            message,
            position=position,
            outer_position=outer_position,
            context_description=context_description,
            severity=severity,
            *args
        )
        self.push_exception(err)

    def update_depth_stats(self, **kwargs):
        st = self.stats
        st.max_depth = max(st.max_depth, self.cur_depth)
        if (
            not self._have_warned_max_depth
            and self.cur_depth &gt; self.options.warn_max_depth
        ):
            self._have_warned_max_depth = True
            self.push_cond(
                self.options.non_portable,
                &#34;Arrays or objects nested deeper than %d levels may not be portable&#34;
                % self.options.warn_max_depth,
            )

    def update_string_stats(self, s, **kwargs):
        st = self.stats
        st.num_strings += 1
        st.max_string_length = max(st.max_string_length, len(s))
        st.total_string_length += len(s)
        if (
            self.options.warn_string_length
            and len(s) &gt; self.options.warn_string_length
            and not self._have_warned_long_string
        ):
            self._have_warned_long_string = True
            self.push_cond(
                self.options.non_portable,
                &#34;Strings longer than %d may not be portable&#34;
                % self.options.warn_string_length,
                **kwargs
            )
        if len(s) &gt; 0:
            mincp = ord(min(s))
            maxcp = ord(max(s))
            if st.min_codepoint is None:
                st.min_codepoint = mincp
                st.max_codepoint = maxcp
            else:
                st.min_codepoint = min(st.min_codepoint, mincp)
                st.max_codepoint = max(st.max_codepoint, maxcp)
            if maxcp &gt; 0xFFFF and not self._have_warned_nonbmp:
                self._have_warned_nonbmp = True
                self.push_cond(
                    self.options.non_portable,
                    &#34;Strings containing non-BMP characters (U+%04X) may not be portable&#34;
                    % maxcp,
                    **kwargs
                )

    def update_negzero_int_stats(self, **kwargs):
        st = self.stats
        st.num_negative_zero_ints += 1
        if st.num_negative_zero_ints == 1:  # Only warn once
            self.push_cond(
                self.options.non_portable,
                &#34;Negative zero (-0) integers are usually not portable&#34;,
                **kwargs
            )

    def update_negzero_float_stats(self, **kwargs):
        st = self.stats
        st.num_negative_zero_floats += 1
        if st.num_negative_zero_floats == 1:  # Only warn once
            self.push_cond(
                self.options.non_portable,
                &#34;Negative zero (-0.0) numbers may not be portable&#34;,
                **kwargs
            )

    def update_float_stats(self, float_value, **kwargs):
        st = self.stats
        if &#34;sign&#34; in kwargs:
            del kwargs[&#34;sign&#34;]

        if helpers.is_negzero(float_value):
            self.update_negzero_float_stats(**kwargs)

        if helpers.is_infinite(float_value):
            st.num_infinities += 1

        if isinstance(float_value, decimal.Decimal):
            st.num_floats_decimal += 1
            if st.num_floats_decimal == 1:  # Only warn once
                self.push_cond(
                    self.options.non_portable,
                    &#39;Floats larger or more precise than an IEEE &#34;double&#34; may not be portable&#39;,
                    **kwargs
                )
        elif isinstance(float_value, float):
            st.num_floats += 1

    def update_integer_stats(self, int_value, **kwargs):
        sign = kwargs.get(&#34;sign&#34;, 1)
        if &#34;sign&#34; in kwargs:
            del kwargs[&#34;sign&#34;]

        if int_value == 0 and sign &lt; 0:
            self.update_negzero_int_stats(**kwargs)

        if sign &lt; 0:
            int_value = -int_value

        st = self.stats
        st.num_ints += 1
        if st.int8_min &lt;= int_value &lt;= st.int8_max:
            st.num_ints_8bit += 1
        elif st.int16_min &lt;= int_value &lt;= st.int16_max:
            st.num_ints_16bit += 1
        elif st.int32_min &lt;= int_value &lt;= st.int32_max:
            st.num_ints_32bit += 1
        elif st.int64_min &lt;= int_value &lt;= st.int64_max:
            st.num_ints_64bit += 1
        else:
            st.num_ints_long += 1

        if int_value &lt; st.double_int_min or st.double_int_max &lt; int_value:
            st.num_ints_53bit += 1
            if st.num_ints_53bit == 1:  # Only warn once
                self.push_cond(
                    self.options.non_portable,
                    &#34;Integers larger than 53-bits are not portable&#34;,
                    **kwargs
                )


# ----------------------------------------------------------------------
# JSON strictness options
# ----------------------------------------------------------------------

STRICTNESS_STRICT = &#34;strict&#34;
STRICTNESS_WARN = &#34;warn&#34;
STRICTNESS_TOLERANT = &#34;tolerant&#34;

ALLOW = &#34;allow&#34;
WARN = &#34;warn&#34;
FORBID = &#34;forbid&#34;

# For float_type option
NUMBER_AUTO = &#34;auto&#34;
NUMBER_FLOAT = &#34;float&#34;
NUMBER_DECIMAL = &#34;decimal&#34;

# For json_int class
NUMBER_FORMAT_DECIMAL = &#34;decimal&#34;
NUMBER_FORMAT_HEX = &#34;hex&#34;
NUMBER_FORMAT_LEGACYOCTAL = &#34;legacyoctal&#34;
NUMBER_FORMAT_OCTAL = &#34;octal&#34;
NUMBER_FORMAT_BINARY = &#34;binary&#34;


class _behaviors_metaclass(type):
    &#34;&#34;&#34;Meta class used to establish a set of &#34;behavior&#34; options.

    Classes that use this meta class must defined a class-level
    variable called &#39;_behaviors&#39; that is a list of tuples, each of
    which describes one behavior and is like: (behavior_name,
    documentation).  Also define a second class-level variable called
    &#39;_behavior_values&#39; which is a list of the permitted values for
    each behavior, each being strings.

    For each behavior (e.g., pretty), and for each value (e.g.,
    yes) the following methods/properties will be created:

      * pretty - value of &#39;pretty&#39; behavior (read-write)
      * ispretty_yes - returns True if &#39;pretty&#39; is &#39;yes&#39;

    For each value (e.g., pink) the following methods/properties
    will be created:

      * all_behaviors - set of all behaviors (read-only)
      * pink_behaviors - set of behaviors with value of &#39;pink&#39; (read-only)
      * set_all(&#39;pink&#39;)
      * set_all_pink()    - set all behaviors to value of &#39;pink&#39;

    &#34;&#34;&#34;

    def __new__(cls, clsname, bases, attrs):
        values = attrs.get(&#34;_behavior_values&#34;)
        attrs[&#34;values&#34;] = property(
            lambda self: set(self._behavior_values),
            doc=&#34;Set of possible behavior values&#34;,
        )
        behaviors = attrs.get(&#34;_behaviors&#34;)

        def get_behavior(self, name):
            &#34;&#34;&#34;Returns the value for a given behavior&#34;&#34;&#34;
            try:
                return getattr(self, &#34;_behavior_&#34; + name)
            except AttributeError:
                raise ValueError(&#34;Unknown behavior&#34;, name)

        attrs[&#34;get_behavior&#34;] = get_behavior

        def set_behavior(self, name, value):
            &#34;&#34;&#34;Changes the value for a given behavior&#34;&#34;&#34;
            if value not in self._behavior_values:
                raise ValueError(&#34;Unknown value for behavior&#34;, value)
            varname = &#34;_behavior_&#34; + name
            if hasattr(self, varname):
                setattr(self, varname, value)
            else:
                raise ValueError(&#34;Unknown behavior&#34;, name)

        attrs[&#34;set_behavior&#34;] = set_behavior

        def describe_behavior(self, name):
            &#34;&#34;&#34;Returns documentation about a given behavior.&#34;&#34;&#34;
            for n, doc in self._behaviors:
                if n == name:
                    return doc
            else:
                raise AttributeError(&#34;No such behavior&#34;, name)

        attrs[&#34;describe_behavior&#34;] = describe_behavior

        for name, doc in behaviors:
            attrs[&#34;_behavior_&#34; + name] = True
            for v in values:
                vs = v + &#34;_&#34; + name

                def getx(self, name=name, forval=v):
                    return self.get_behavior(name) == forval

                attrs[&#34;is_&#34; + v + &#34;_&#34; + name] = property(
                    getx, doc=v.capitalize() + &#34; &#34; + doc
                )
                # method value_name()
                fnset = lambda self, _name=name, _value=v: self.set_behavior(
                    _name, _value
                )
                fnset.__name__ = v + &#34;_&#34; + name
                fnset.__doc__ = &#34;Set behavior &#34; + name + &#34; to &#34; + v + &#34;.&#34;
                attrs[fnset.__name__] = fnset

            def get_value_for_behavior(self, name=name):
                return self.get_behavior(name)

            def set_value_for_behavior(self, value, name=name):
                self.set_behavior(name, value)

            attrs[name] = property(
                get_value_for_behavior, set_value_for_behavior, doc=doc
            )

        @property
        def all_behaviors(self):
            &#34;&#34;&#34;Returns the names of all known behaviors.&#34;&#34;&#34;
            return set([t[0] for t in self._behaviors])

        attrs[&#34;all_behaviors&#34;] = all_behaviors

        def set_all(self, value):
            &#34;&#34;&#34;Changes all behaviors to have the given value.&#34;&#34;&#34;
            if value not in self._behavior_values:
                raise ValueError(&#34;Unknown behavior&#34;, value)
            for name in self.all_behaviors:
                setattr(self, &#34;_behavior_&#34; + name, value)

        attrs[&#34;set_all&#34;] = set_all

        def is_all(self, value):
            &#34;&#34;&#34;Determines if all the behaviors have the given value.&#34;&#34;&#34;
            if value not in self._behavior_values:
                raise ValueError(&#34;Unknown behavior&#34;, value)
            for name in self.all_behaviors:
                if getattr(self, &#34;_behavior_&#34; + name) != value:
                    return False
            return True

        attrs[&#34;is_all&#34;] = is_all

        for v in values:
            # property value_behaviors
            def getbehaviorsfor(self, value=v):
                return set(
                    [
                        name
                        for name in self.all_behaviors
                        if getattr(self, name) == value
                    ]
                )

            attrs[v + &#34;_behaviors&#34;] = property(
                getbehaviorsfor,
                doc=&#34;Return the set of behaviors with the value &#34; + v + &#34;.&#34;,
            )
            # method set_all_value()
            setfn = lambda self, _value=v: set_all(self, _value)
            setfn.__name__ = &#34;set_all_&#34; + v
            setfn.__doc__ = &#34;Set all behaviors to value &#34; + v + &#34;.&#34;
            attrs[setfn.__name__] = setfn
            # property is_all_value
            attrs[&#34;is_all_&#34; + v] = property(
                lambda self, v=v: is_all(self, v),
                doc=&#34;Determines if all the behaviors have the value &#34; + v + &#34;.&#34;,
            )

        def behaviors_eq(self, other):
            &#34;&#34;&#34;Determines if two options objects are equivalent.&#34;&#34;&#34;
            if self.all_behaviors != other.all_behaviors:
                return False
            return self.allowed_behaviors == other.allowed_behaviors

        attrs[&#34;__eq__&#34;] = behaviors_eq

        return super(_behaviors_metaclass, cls).__new__(cls, clsname, bases, attrs)


SORT_NONE = &#34;none&#34;
SORT_PRESERVE = &#34;preserve&#34;
SORT_ALPHA = &#34;alpha&#34;
SORT_ALPHA_CI = &#34;alpha_ci&#34;
SORT_SMART = &#34;smart&#34;

sorting_methods = {
    SORT_NONE: &#34;Do not sort, resulting order may be random&#34;,
    SORT_PRESERVE: &#34;Preserve original order when reformatting&#34;,
    SORT_ALPHA: &#34;Sort strictly alphabetically&#34;,
    SORT_ALPHA_CI: &#34;Sort alphabetically case-insensitive&#34;,
    SORT_SMART: &#34;Sort alphabetically and numerically (DEFAULT)&#34;,
}
sorting_method_aliases = {&#34;ci&#34;: SORT_ALPHA_CI}


def smart_sort_transform(key):
    numfmt = &#34;%012d&#34;
    digits = &#34;0123456789&#34;
    zero = ord(&#34;0&#34;)
    if not key:
        key = &#34;&#34;
    elif isinstance(key, int):
        key = numfmt % key
    elif isinstance(key, str):
        keylen = len(key)
        words = []
        i = 0
        while i &lt; keylen:
            if key[i] in digits:
                num = 0
                while i &lt; keylen and key[i] in digits:
                    num *= 10
                    num += ord(key[i]) - zero
                    i += 1
                words.append(numfmt % num)
            else:
                words.append(key[i].upper())
                i += 1
        key = &#34;&#34;.join(words)
    else:
        key = str(key)
    return key


# Find Enum type (introduced in Python 3.4)
from enum import Enum as _enum

# Find OrderedDict type
from collections import OrderedDict as _OrderedDict


class json_options(object, metaclass=_behaviors_metaclass):
    &#34;&#34;&#34;Options to determine how strict the decoder or encoder should be.&#34;&#34;&#34;

    _behavior_values = (ALLOW, WARN, FORBID)
    _behaviors = (
        (
            &#34;all_numeric_signs&#34;,
            &#34;Numbers may be prefixed by any &#39;+&#39; and &#39;-&#39;, e.g., +4, -+-+77&#34;,
        ),
        (
            &#34;any_type_at_start&#34;,
            &#34;A JSON document may start with any type, not just arrays or objects&#34;,
        ),
        (&#34;comments&#34;, &#34;JavaScript comments, both /*...*/ and //... styles&#34;),
        (
            &#34;control_char_in_string&#34;,
            &#34;Strings may contain raw control characters without \\u-escaping&#34;,
        ),
        (&#34;hex_numbers&#34;, &#34;Hexadecimal numbers, e.g., 0x1f&#34;),
        (&#34;binary_numbers&#34;, &#34;Binary numbers, e.g., 0b1001&#34;),
        (
            &#34;octal_numbers&#34;,
            &#34;New-style octal numbers, e.g., 0o731  (see leading-zeros for legacy octals)&#34;,
        ),
        (
            &#34;initial_decimal_point&#34;,
            &#34;Floating-point numbers may start with a decimal point (no units digit)&#34;,
        ),
        (
            &#34;extended_unicode_escapes&#34;,
            &#34;Extended Unicode escape sequence \\u{..} for non-BMP characters&#34;,
        ),
        (
            &#34;js_string_escapes&#34;,
            &#34;All JavaScript character \\-escape sequences may be in strings&#34;,
        ),
        (
            &#34;leading_zeros&#34;,
            &#34;Numbers may have extra leading zeros (see --leading-zero-radix option)&#34;,
        ),
        (&#34;non_numbers&#34;, &#34;Non-numbers may be used, such as NaN or Infinity&#34;),
        (
            &#34;nonescape_characters&#34;,
            &#34;Unknown character \\-escape sequences stand for that character (\\Q -&gt; &#39;Q&#39;)&#34;,
        ),
        (
            &#34;identifier_keys&#34;,
            &#34;JavaScript identifiers are converted to strings when used as object keys&#34;,
        ),
        (
            &#34;nonstring_keys&#34;,
            &#34;Value types other than strings (or identifiers) may be used as object keys&#34;,
        ),
        (
            &#34;omitted_array_elements&#34;,
            &#34;Arrays may have omitted/elided elements, e.g., [1,,3] == [1,undefined,3]&#34;,
        ),
        (
            &#34;single_quoted_strings&#34;,
            &#34;Strings may be delimited with both double (\&#34;) and single (&#39;) quotation marks&#34;,
        ),
        (&#34;trailing_comma&#34;, &#34;A final comma may end the list of array or object members&#34;),
        (
            &#34;trailing_decimal_point&#34;,
            &#34;Floating-point number may end with a decimal point and no following fractional digits&#34;,
        ),
        (&#34;undefined_values&#34;, &#34;The JavaScript &#39;undefined&#39; value may be used&#34;),
        (
            &#34;format_control_chars&#34;,
            &#39;Unicode &#34;format control characters&#34; may appear in the input&#39;,
        ),
        (
            &#34;unicode_whitespace&#34;,
            &#34;Treat any Unicode whitespace character as valid whitespace&#34;,
        ),
        # Never legal
        (&#34;leading_zeros&#34;, &#34;Numbers may have leading zeros&#34;),
        # Normally warnings
        (&#34;duplicate_keys&#34;, &#34;Objects may have repeated keys&#34;),
        (
            &#34;zero_byte&#34;,
            &#34;Strings may contain U+0000, which may not be safe for C-based programs&#34;,
        ),
        (&#34;bom&#34;, &#34;A JSON document may start with a Unicode BOM (Byte Order Mark)&#34;),
        (
            &#34;non_portable&#34;,
            &#34;Anything technically valid but likely to cause data portablibity issues&#34;,
        ),
    )  # end behavior list

    def reset_to_defaults(self):
        # Plain attrs (other than above behaviors) are simply copied
        # by value, either during initialization (via keyword
        # arguments) or via the copy() method.
        self._plain_attrs = [
            &#34;leading_zero_radix&#34;,
            &#34;encode_namedtuple_as_object&#34;,
            &#34;encode_enum_as&#34;,
            &#34;encode_compactly&#34;,
            &#34;escape_unicode&#34;,
            &#34;always_escape_chars&#34;,
            &#34;warn_string_length&#34;,
            &#34;warn_max_depth&#34;,
            &#34;int_as_float&#34;,
            &#34;decimal_context&#34;,
            &#34;float_type&#34;,
            &#34;keep_format&#34;,
            &#34;date_format&#34;,
            &#34;datetime_format&#34;,
            &#34;time_format&#34;,
            &#34;timedelta_format&#34;,
            &#34;sort_keys&#34;,
            &#34;indent_amount&#34;,
            &#34;indent_tab_width&#34;,
            &#34;indent_limit&#34;,
            &#34;max_items_per_line&#34;,
            &#34;py2str_encoding&#34;,
        ]

        self.strictness = STRICTNESS_WARN
        self._leading_zero_radix = 8  # via property: leading_zero_radix
        self._sort_keys = SORT_SMART  # via property: sort_keys

        self.int_as_float = False
        self.float_type = NUMBER_AUTO
        self.decimal_context = decimal.DefaultContext if decimal else None
        self.keep_format = False  # keep track of when numbers are hex, octal, etc.

        self.encode_namedtuple_as_object = True
        self._encode_enum_as = &#34;name&#34;  # via property
        self.encode_compactly = True
        self.escape_unicode = False
        self.always_escape_chars = (
            None  # None, or a set of Unicode characters to always escape
        )

        self.warn_string_length = 0xFFFD  # with 16-bit length prefix
        self.warn_max_depth = 64

        self.date_format = &#34;iso&#34;  # or strftime format
        self.datetime_format = &#34;iso&#34;  # or strftime format
        self.time_format = &#34;iso&#34;  # or strftime format
        self.timedelta_format = &#34;iso&#34;  # or &#39;hms&#39;

        self.sort_keys = SORT_ALPHA
        self.indent_amount = 2
        self.indent_tab_width = 0  # 0, or number of equivalent spaces
        self.indent_limit = None
        self.max_items_per_line = 1  # When encoding how many items per array/object
        # before breaking into multiple lines
        # For interpreting Python 2 &#39;str&#39; types:
        self.py2str_encoding = None

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Set JSON encoding and decoding options.

        If &#39;strict&#39; is set to True, then only strictly-conforming JSON
        output will be produced.  Note that this means that some types
        of values may not be convertable and will result in a
        JSONEncodeError exception.

        If &#39;compactly&#39; is set to True, then the resulting string will
        have all extraneous white space removed; if False then the
        string will be &#34;pretty printed&#34; with whitespace and indentation
        added to make it more readable.

        If &#39;escape_unicode&#39; is set to True, then all non-ASCII characters
        will be represented as a unicode escape sequence; if False then
        the actual real unicode character will be inserted if possible.

        The &#39;escape_unicode&#39; can also be a function, which when called
        with a single argument of a unicode character will return True
        if the character should be escaped or False if it should not.

        &#34;&#34;&#34;
        self.reset_to_defaults()

        if &#34;strict&#34; in kwargs:
            # Do this keyword first, so other keywords may override specific behaviors
            self.strictness = kwargs[&#34;strict&#34;]

        for kw, val in list(kwargs.items()):
            if kw == &#34;compactly&#34;:  # alias for &#39;encode_compactly&#39;
                self.encode_compactly = val
            elif kw == &#34;strict&#34;:
                pass  # Already handled
            elif kw == &#34;warnings&#34;:
                if val:
                    self.suppress_warnings()
            elif kw == &#34;html_safe&#34; or kw == &#34;xml_safe&#34;:
                if bool(val):
                    if self.always_escape_chars is None:
                        self.always_escape_chars = set(&#34;&lt;&gt;/&amp;&#34;)
                    else:
                        self.always_escape_chars.update(set(&#34;&lt;&gt;/&amp;&#34;))
            elif kw == &#34;always_escape&#34;:
                if val:
                    if self.always_escape_chars is None:
                        self.always_escape_chars = set(val)
                    else:
                        self.always_escape_chars.update(set(val))
            elif kw == &#34;int_as_float&#34;:
                self.int_as_float = bool(val)
            elif kw == &#34;keep_format&#34;:
                self.keep_format = bool(val)
            elif kw == &#34;float_type&#34;:
                if val in (NUMBER_AUTO, NUMBER_FLOAT, NUMBER_DECIMAL):
                    self.float_type = val
                else:
                    raise ValueError(
                        &#34;Unknown option %r for argument %r to initialize %s&#34;
                        % (val, kw, self.__class__.__name__)
                    )
            elif kw == &#34;decimal&#34; or kw == &#34;decimal_context&#34;:
                if decimal:
                    if not val or val == &#34;default&#34;:
                        self.decimal_context = decimal.DefaultContext
                    elif val == &#34;basic&#34;:
                        self.decimal_context = decimal.BasicContext
                    elif val == &#34;extended&#34;:
                        self.decimal_context = decimal.ExtendedContext
                    elif isinstance(val, decimal.Context):
                        self.decimal_context = val
                    elif isinstance(val, int) or val[0].isdigit:
                        prec = int(val)
                        self.decimal_context = decimal.Context(prec=prec)
                    else:
                        raise ValueError(
                            &#34;Option for %r should be a decimal.Context, a number of significant digits, or one of &#39;default&#39;,&#39;basic&#39;, or &#39;extended&#39;.&#34;
                            % (kw,)
                        )
            elif kw in (&#34;allow&#34;, &#34;warn&#34;, &#34;forbid&#34;, &#34;prevent&#34;, &#34;deny&#34;):
                action = {
                    &#34;allow&#34;: ALLOW,
                    &#34;warn&#34;: WARN,
                    &#34;forbid&#34;: FORBID,
                    &#34;prevent&#34;: FORBID,
                    &#34;deny&#34;: FORBID,
                }[kw]
                if isinstance(val, str):
                    val = [b.replace(&#34;-&#34;, &#34;_&#34;) for b in val.replace(&#34;,&#34;, &#34; &#34;).split()]
                for behavior in val:
                    self.set_behavior(behavior, action)
            elif (
                kw.startswith(&#34;allow_&#34;)
                or kw.startswith(&#34;forbid_&#34;)
                or kw.startswith(&#34;prevent_&#34;)
                or kw.startswith(&#34;deny_&#34;)
                or kw.startswith(&#34;warn_&#34;)
            ):
                action, behavior = kw.split(&#34;_&#34;, 1)
                if action == &#34;allow&#34;:
                    if val:
                        self.set_behavior(behavior, ALLOW)
                    else:
                        self.set_behavior(behavior, FORBID)
                elif action in (&#34;forbid&#34;, &#34;prevent&#34;, &#34;deny&#34;):
                    if val:
                        self.set_behavior(behavior, FORBID)
                    else:
                        self.set_behavior(behavior, ALLOW)
                elif action == &#34;warn&#34;:
                    if val:
                        self.set_behavior(behavior, WARN)
                    else:
                        self.set_behavior(behavior, ALLOW)
            elif kw in self._plain_attrs:
                setattr(self, kw, val)
            else:
                raise ValueError(
                    &#34;Unknown keyword argument %r to initialize %s&#34;
                    % (kw, self.__class__.__name__)
                )

    def copy(self):
        other = self.__class__()
        other.copy_from(self)
        return other

    def copy_from(self, other):
        if self is other:
            return  # Myself!

        self.strictness = other.strictness  # sets behaviors in bulk

        for name in self.all_behaviors:
            self.set_behavior(name, other.get_behavior(name))

        for name in self._plain_attrs:
            val = getattr(other, name)
            if isinstance(val, set):
                val = val.copy()
            elif decimal and isinstance(val, decimal.Decimal):
                val = decimal.Decimal(val)

            setattr(self, name, val)

    def spaces_to_next_indent_level(self, min_spaces=1, subtract=0):
        n = self.indent_amount - subtract
        if n &lt; 0:
            n = 0
        n = max(min_spaces, n)
        return &#34; &#34; * n

    def indentation_for_level(self, level=0):
        &#34;&#34;&#34;Returns a whitespace string used for indenting.&#34;&#34;&#34;
        if self.indent_limit is not None and level &gt; self.indent_limit:
            n = self.indent_limit
        else:
            n = level
        n *= self.indent_amount
        if self.indent_tab_width:
            tw, sw = divmod(n, self.indent_tab_width)
            return &#34;\t&#34; * tw + &#34; &#34; * sw
        else:
            return &#34; &#34; * n

    def set_indent(self, num_spaces, tab_width=0, limit=None):
        &#34;&#34;&#34;Changes the indentation properties when outputting JSON in non-compact mode.

        &#39;num_spaces&#39; is the number of spaces to insert for each level
        of indentation, which defaults to 2.

        &#39;tab_width&#39;, if not 0, is the number of spaces which is equivalent
        to one tab character.  Tabs will be output where possible rather
        than runs of spaces.

        &#39;limit&#39;, if not None, is the maximum indentation level after
        which no further indentation will be output.

        &#34;&#34;&#34;
        n = int(num_spaces)
        if n &lt; 0:
            raise ValueError(&#34;indentation amount can not be negative&#34;, n)
        self.indent_amount = n
        self.indent_tab_width = tab_width
        self.indent_limit = limit

    @property
    def sort_keys(self):
        &#34;&#34;&#34;The method used to sort dictionary keys when encoding JSON&#34;&#34;&#34;
        return self._sort_keys

    @sort_keys.setter
    def sort_keys(self, method):
        if not method:
            self._sort_keys = SORT_NONE
        elif callable(method):
            self._sort_keys = method
        elif method in sorting_methods:
            self._sort_keys = method
        elif method in sorting_method_aliases:  # alias
            self._sort_keys = sorting_method_aliases[method]
        elif method:
            self._sort_keys = SORT_ALPHA
        else:
            raise ValueError(&#34;Not a valid sorting method: %r&#34; % method)

    @property
    def encode_enum_as(self):
        &#34;&#34;&#34;The strategy for encoding Python Enum values.&#34;&#34;&#34;
        return self._encode_enum_as

    @encode_enum_as.setter
    def encode_enum_as(self, val):
        if val not in (&#34;name&#34;, &#34;qname&#34;, &#34;value&#34;):
            raise ValueError(&#34;encode_enum_as must be one of &#39;name&#39;,&#39;qname&#39;, or &#39;value&#39;&#34;)
        self._encode_enum_as = val

    @property
    def zero_float(self):
        &#34;&#34;&#34;The numeric value 0.0, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;0.0&#34;)
        else:
            return 0.0

    @property
    def negzero_float(self):
        &#34;&#34;&#34;The numeric value -0.0, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;-0.0&#34;)
        else:
            return -0.0

    @property
    def nan(self):
        &#34;&#34;&#34;The numeric value NaN, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;NaN&#34;)
        else:
            return nan

    @property
    def inf(self):
        &#34;&#34;&#34;The numeric value Infinity, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;Infinity&#34;)
        else:
            return inf

    @property
    def neginf(self):
        &#34;&#34;&#34;The numeric value -Infinity, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;-Infinity&#34;)
        else:
            return neginf

    def make_int(self, s, sign=None, number_format=NUMBER_FORMAT_DECIMAL):
        &#34;&#34;&#34;Makes an integer value according to the current options.

        First argument should be a string representation of the number,
        or an integer.

        Returns a number value, which could be an int, float, or decimal.

        &#34;&#34;&#34;
        if isinstance(sign, int):
            if sign &lt; 0:
                sign = &#34;-&#34;
            else:
                sign = &#34;+&#34;
        if isinstance(s, str):
            if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
                sign = s[0]
                s = s[1:]

        if self.int_as_float:
            # Making a float/decimal
            if isinstance(s, int):
                if self.float_type == NUMBER_DECIMAL:
                    n = self.decimal_context.create_decimal(s)
                    if sign == &#34;-&#34;:
                        n = n.copy_negate()
                elif s == 0 and sign == &#34;-&#34;:
                    n = self.negzero_float
                elif -999999999999999 &lt;= s &lt;= 999999999999999:
                    n = float(s)
                    if sign == &#34;-&#34;:
                        n *= -1
                else:
                    n = float(s)
                    if (n == inf or int(n) != s) and self.float_type != NUMBER_FLOAT:
                        n = self.decimal_context.create_decimal(s)
                        if sign == &#34;-&#34;:
                            n = n.copy_negate()
                    elif sign == &#34;-&#34;:
                        n *= -1
            else:  # not already an int
                n = self.make_float(s, sign)
                n2 = self.make_float(s[:-1] + (&#34;9&#34; if s[-1] &lt;= &#34;5&#34; else &#34;0&#34;), sign)
                if (n == inf or n == n2) and self.float_type != NUMBER_FLOAT:
                    n = self.make_decimal(s, sign)
        elif isinstance(s, int):
            # already an integer
            n = s
            if sign == &#34;-&#34;:
                if n == 0:
                    n = self.negzero_float
                else:
                    n *= -1
        else:
            # Making an actual integer
            try:
                n = int(s)
            except ValueError:
                n = self.nan
            else:
                if sign == &#34;-&#34;:
                    if n == 0:
                        n = self.negzero_float
                    else:
                        n *= -1
        if isinstance(n, int) and self.keep_format:
            n = json_int(n, number_format=number_format)
        return n

    def make_decimal(self, s, sign=&#34;+&#34;):
        &#34;&#34;&#34;Converts a string into a decimal or float value.&#34;&#34;&#34;
        if self.float_type == NUMBER_FLOAT:
            return self.make_float(s, sign)

        if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
            sign = s[0]
            s = s[1:]
        elif isinstance(sign, int):
            if sign &lt; 0:
                sign = &#34;-&#34;
            else:
                sign = &#34;+&#34;

        try:
            f = self.decimal_context.create_decimal(s)
        except decimal.InvalidOperation:
            f = self.decimal_context.create_decimal(&#34;NaN&#34;)
        except decimal.Overflow:
            if sign == &#34;-&#34;:
                f = self.decimal_context.create_decimal(&#34;-Infinity&#34;)
            else:
                f = self.decimal_context.create_decimal(&#34;Infinity&#34;)
        else:
            if sign == &#34;-&#34;:
                f = f.copy_negate()
        return f

    def make_float(self, s, sign=&#34;+&#34;):
        &#34;&#34;&#34;Converts a string into a float or decimal value.&#34;&#34;&#34;
        if decimal and self.float_type == NUMBER_DECIMAL:
            return self.make_decimal(s, sign)

        if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
            sign = s[0]
            s = s[1:]
        elif isinstance(sign, int):
            if sign &lt; 0:
                sign = &#34;-&#34;
            else:
                sign = &#34;+&#34;

        try:
            f = float(s)
        except ValueError:
            f = nan
        else:
            if sign == &#34;-&#34;:
                f *= -1
        return f

    @property
    def leading_zero_radix(self):
        &#34;&#34;&#34;The radix to be used for numbers with leading zeros.  8 or 10&#34;&#34;&#34;
        return self._leading_zero_radix

    @leading_zero_radix.setter
    def leading_zero_radix(self, radix):
        if isinstance(radix, str):
            try:
                radix = int(radix)
            except ValueError:
                radix = radix.lower()
                if radix == &#34;octal&#34; or radix == &#34;oct&#34; or radix == &#34;8&#34;:
                    radix = 8
                elif radix == &#34;decimal&#34; or radix == &#34;dec&#34;:
                    radix = 10
        if radix not in (8, 10):
            raise ValueError(&#34;Radix must either be 8 (octal) or 10 (decimal)&#34;)
        self._leading_zero_radix = radix

    @property
    def leading_zero_radix_as_word(self):
        return {8: &#34;octal&#34;, 10: &#34;decimal&#34;}[self._leading_zero_radix]

    def suppress_warnings(self):
        for name in self.warn_behaviors:
            self.set_behavior(name, &#34;allow&#34;)

    @property
    def allow_or_warn_behaviors(self):
        &#34;&#34;&#34;Returns the set of all behaviors that are not forbidden (i.e., are allowed or warned).&#34;&#34;&#34;
        return self.allow_behaviors.union(self.warn_behaviors)

    @property
    def strictness(self):
        return self._strictness

    @strictness.setter
    def strictness(self, strict):
        &#34;&#34;&#34;Changes whether the options should be re-configured for strict JSON conformance.&#34;&#34;&#34;
        if strict == STRICTNESS_WARN:
            self._strictness = STRICTNESS_WARN
            self.set_all_warn()
        elif strict == STRICTNESS_STRICT or strict is True:
            self._strictness = STRICTNESS_STRICT
            self.keep_format = False
            self.set_all_forbid()
            self.warn_duplicate_keys()
            self.warn_zero_byte()
            self.warn_bom()
            self.warn_non_portable()
        elif strict == STRICTNESS_TOLERANT or strict is False:
            self._strictness = STRICTNESS_TOLERANT
            self.set_all_allow()
            self.warn_duplicate_keys()
            self.warn_zero_byte()
            self.warn_leading_zeros()
            self.leading_zero_radix = 8
            self.warn_bom()
            self.allow_non_portable()
        else:
            raise ValueError(&#34;Unknown strictness options %r&#34; % strict)
        self.allow_any_type_at_start()


# ----------------------------------------------------------------------
# The main JSON encoder/decoder class.
# ----------------------------------------------------------------------


class JSON(object):
    &#34;&#34;&#34;An encoder/decoder for JSON data streams.

    Usually you will call the encode() or decode() methods.  The other
    methods are for lower-level processing.

    Whether the JSON parser runs in strict mode (which enforces exact
    compliance with the JSON spec) or the more forgiving non-string mode
    can be affected by setting the &#39;strict&#39; argument in the object&#39;s
    initialization; or by assigning True or False to the &#39;strict&#39;
    property of the object.

    You can also adjust a finer-grained control over strictness by
    allowing or forbidding specific behaviors.  You can get a list of
    all the available behaviors by accessing the &#39;behaviors&#39; property.
    Likewise the &#39;allowed_behaviors&#39; and &#39;forbidden_behaviors&#39; list which
    behaviors will be allowed and which will not.  Call the allow()
    or forbid() methods to adjust these.

    &#34;&#34;&#34;

    _string_quotes = &#34;\&#34;&#39;&#34;

    _escapes_json = {  # character escapes in JSON
        &#39;&#34;&#39;: &#39;&#34;&#39;,
        &#34;/&#34;: &#34;/&#34;,
        &#34;\\&#34;: &#34;\\&#34;,
        &#34;b&#34;: &#34;\b&#34;,
        &#34;f&#34;: &#34;\f&#34;,
        &#34;n&#34;: &#34;\n&#34;,
        &#34;r&#34;: &#34;\r&#34;,
        &#34;t&#34;: &#34;\t&#34;,
    }

    _escapes_js = {  # character escapes in Javascript
        &#39;&#34;&#39;: &#39;&#34;&#39;,
        &#34;&#39;&#34;: &#34;&#39;&#34;,
        &#34;\\&#34;: &#34;\\&#34;,
        &#34;b&#34;: &#34;\b&#34;,
        &#34;f&#34;: &#34;\f&#34;,
        &#34;n&#34;: &#34;\n&#34;,
        &#34;r&#34;: &#34;\r&#34;,
        &#34;t&#34;: &#34;\t&#34;,
        &#34;v&#34;: &#34;\v&#34;,
        &#34;0&#34;: &#34;\x00&#34;,
    }

    # Following is a reverse mapping of escape characters, used when we
    # output JSON.  Only those escapes which are always safe (e.g., in JSON)
    # are here.  It won&#39;t hurt if we leave questionable ones out.
    _rev_escapes = {
        &#34;\n&#34;: &#34;\\n&#34;,
        &#34;\t&#34;: &#34;\\t&#34;,
        &#34;\b&#34;: &#34;\\b&#34;,
        &#34;\r&#34;: &#34;\\r&#34;,
        &#34;\f&#34;: &#34;\\f&#34;,
        &#39;&#34;&#39;: &#39;\\&#34;&#39;,
        &#34;\\&#34;: &#34;\\\\&#34;,
    }
    _optional_rev_escapes = {&#34;/&#34;: &#34;\\/&#34;}  # only escaped if forced to do so

    json_syntax_characters = &#39;{}[]&#34;\\,:0123456789.-+abcdefghijklmnopqrstuvwxyz \t\n\r&#39;

    all_hook_names = (
        &#34;decode_number&#34;,
        &#34;decode_float&#34;,
        &#34;decode_object&#34;,
        &#34;decode_array&#34;,
        &#34;decode_string&#34;,
        &#34;encode_value&#34;,
        &#34;encode_dict&#34;,
        &#34;encode_dict_key&#34;,
        &#34;encode_sequence&#34;,
        &#34;encode_bytes&#34;,
        &#34;encode_default&#34;,
    )

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Creates a JSON encoder/decoder object.

        You may pass encoding and decoding options either by passing
        an argument named &#39;json_options&#39; with an instance of a
        json_options class; or with individual keyword/values that will
        be used to initialize a new json_options object.

        You can also set hooks by using keyword arguments using the
        hook name; e.g., encode_dict=my_hook_func.

        &#34;&#34;&#34;
        import unicodedata

        kwargs = kwargs.copy()
        # Initialize hooks
        for hookname in self.all_hook_names:
            if hookname in kwargs:
                self.set_hook(hookname, kwargs[hookname])
                del kwargs[hookname]
            else:
                self.set_hook(hookname, None)

        # Set options
        if &#34;json_options&#34; in kwargs:
            self._options = kwargs[&#34;json_options&#34;]
        else:
            self._options = json_options(**kwargs)

        # The following is a boolean map of the first 256 characters
        # which will quickly tell us which of those characters never
        # need to be escaped.

        self._asciiencodable = [
            32 &lt;= c &lt; 128
            and chr(c) not in self._rev_escapes
            and not unicodedata.category(chr(c)) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]
            for c in range(0, 256)
        ]

    @property
    def options(self):
        &#34;&#34;&#34;The optional behaviors used, e.g., the JSON conformance
        strictness.  Returns an instance of json_options.

        &#34;&#34;&#34;
        return self._options

    def clear_hook(self, hookname):
        &#34;&#34;&#34;Unsets a hook callback, as previously set with set_hook().&#34;&#34;&#34;
        self.set_hook(hookname, None)

    def clear_all_hooks(self):
        &#34;&#34;&#34;Unsets all hook callbacks, as previously set with set_hook().&#34;&#34;&#34;
        for hookname in self.all_hook_names:
            self.clear_hook(hookname)

    def set_hook(self, hookname, function):
        &#34;&#34;&#34;Sets a user-defined callback function used during encoding or decoding.

        The &#39;hookname&#39; argument must be a string containing the name of
        one of the available hooks, listed below.

        The &#39;function&#39; argument must either be None, which disables the hook,
        or a callable function.  Hooks do not stack, if you set a hook it will
        undo any previously set hook.

        Netsted values.  When decoding JSON that has nested objects or
        arrays, the decoding hooks will be called once for every
        corresponding value, even if nested.  Generally the decoding
        hooks will be called from the inner-most value outward, and
        then left to right.

        Skipping. Any hook function may raise a JSONSkipHook exception
        if it does not wish to handle the particular invocation.  This
        will have the effect of skipping the hook for that particular
        value, as if the hook was net set.

        AVAILABLE HOOKS:

        * decode_string
            Called for every JSON string literal with the
            Python-equivalent string value as an argument. Expects to
            get a Python object in return.

        * decode_float:
            Called for every JSON number that looks like a float (has
            a &#34;.&#34;).  The string representation of the number is passed
            as an argument.  Expects to get a Python object in return.

        * decode_number:
            Called for every JSON number. The string representation of
            the number is passed as an argument.  Expects to get a
            Python object in return.  NOTE: If the number looks like a
            float and the &#39;decode_float&#39; hook is set, then this hook
            will not be called.

        * decode_array:
            Called for every JSON array. A Python list is passed as
            the argument, and expects to get a Python object back.
            NOTE: this hook will get called for every array, even
            for nested arrays.

        * decode_object:
            Called for every JSON object.  A Python dictionary is passed
            as the argument, and expects to get a Python object back.
            NOTE: this hook will get called for every object, even
            for nested objects.

        * encode_value:
            Called for every Python object which is to be encoded into JSON.

        * encode_dict:
            Called for every Python dictionary or anything that looks
            like a dictionary.

        * encode_dict_key:
            Called for every dictionary key.

        * encode_sequence:
            Called for every Python sequence-like object that is not a
            dictionary or string. This includes lists and tuples.

        * encode_bytes:
            Called for every Python bytes or bytearray type; or for
            any memoryview with a byte (&#39;B&#39;) item type.  (Python 3 only)

        * encode_default:
            Called for any Python type which can not otherwise be converted
            into JSON, even after applying any other encoding hooks.

        &#34;&#34;&#34;
        if hookname in self.all_hook_names:
            att = hookname + &#34;_hook&#34;
            if function != None and not callable(function):
                raise ValueError(
                    &#34;Hook %r must be None or a callable function&#34; % hookname
                )
            setattr(self, att, function)
        else:
            raise ValueError(&#34;Unknown hook name %r&#34; % hookname)

    def has_hook(self, hook_name):
        if not hook_name or hook_name not in self.all_hook_names:
            return False
        hook = getattr(self, hook_name + &#34;_hook&#34;)
        return callable(hook)

    def call_hook(self, hook_name, input_object, position=None, *args, **kwargs):
        &#34;&#34;&#34;Wrapper function to invoke a user-supplied hook function.

        This will capture any exceptions raised by the hook and do something
        appropriate with it.

        &#34;&#34;&#34;
        import sys

        if hook_name not in self.all_hook_names:
            raise AttributeError(&#34;No such hook %r&#34; % hook_name)
        hook = getattr(self, hook_name + &#34;_hook&#34;)
        if not callable(hook):
            raise TypeError(&#34;Hook is not callable: %r&#34; % (hook,))
        try:
            rval = hook(input_object, *args, **kwargs)
        except JSONSkipHook:
            raise  # Do nothing
        except Exception as err:
            exc_info = sys.exc_info()
            if hook_name.startswith(&#34;encode_&#34;):
                ex_class = JSONEncodeHookError
            else:
                ex_class = JSONDecodeHookError

            if isinstance(err, JSONStopProcessing):
                severity = &#34;fatal&#34;
            else:
                severity = &#34;error&#34;

            newerr = ex_class(
                hook_name,
                exc_info,
                input_object,
                *args,
                position=position,
                severity=severity
            )

            # Simulate Python 3&#39;s: &#34;raise X from Y&#34; exception chaining
            newerr.__cause__ = err
            newerr.__traceback__ = exc_info[2]
            raise newerr
        return rval

    def isws(self, c):
        &#34;&#34;&#34;Determines if the given character is considered as white space.

        Note that Javscript is much more permissive on what it considers
        to be whitespace than does JSON.

        Ref. ECMAScript section 7.2

        &#34;&#34;&#34;
        if not self.options.unicode_whitespace:
            return c in &#34; \t\n\r&#34;
        else:
            if not isinstance(c, str):
                c = str(c)
            if c in &#34; \t\n\r\f\v&#34;:
                return True
            import unicodedata

            return unicodedata.category(c) == &#34;Zs&#34;

    def islineterm(self, c):
        &#34;&#34;&#34;Determines if the given character is considered a line terminator.

        Ref. ECMAScript section 7.3

        &#34;&#34;&#34;
        if c == &#34;\r&#34; or c == &#34;\n&#34;:
            return True
        if c == &#34;\u2028&#34; or c == &#34;\u2029&#34;:  # unicodedata.category(c) in  [&#39;Zl&#39;, &#39;Zp&#39;]
            return True
        return False

    def recover_parser(self, state):
        &#34;&#34;&#34;Try to recover after a syntax error by locating the next &#34;known&#34; position.&#34;&#34;&#34;
        buf = state.buf
        buf.skipuntil(lambda c: c in &#34;,:[]{}\&#34;&#39;;&#34; or helpers.char_is_unicode_eol(c))
        stopchar = buf.peek()
        self.skipws(state)
        if buf.at_end:
            state.push_info(
                &#34;Could not recover parsing after previous error&#34;, position=buf.position
            )
        else:
            state.push_info(
                &#34;Recovering parsing after character %r&#34; % stopchar,
                position=buf.position,
            )
        return stopchar

    def decode_null(self, state):
        &#34;&#34;&#34;Intermediate-level decoder for ECMAScript &#39;null&#39; keyword.

        Takes a string and a starting index, and returns a Python
        None object and the index of the next unparsed character.

        &#34;&#34;&#34;
        buf = state.buf
        start_position = buf.position
        kw = buf.pop_identifier()
        if not kw or kw != &#34;null&#34;:
            state.push_error(&#34;Expected a &#39;null&#39; keyword&#39;&#34;, kw, position=start_position)
        else:
            state.stats.num_nulls += 1
        return None

    def encode_undefined(self, state):
        &#34;&#34;&#34;Produces the ECMAScript &#39;undefined&#39; keyword.&#34;&#34;&#34;
        state.append(&#34;undefined&#34;)

    def encode_null(self, state):
        &#34;&#34;&#34;Produces the JSON &#39;null&#39; keyword.&#34;&#34;&#34;
        state.append(&#34;null&#34;)

    def decode_boolean(self, state):
        &#34;&#34;&#34;Intermediate-level decode for JSON boolean literals.

        Takes a string and a starting index, and returns a Python bool
        (True or False) and the index of the next unparsed character.

        &#34;&#34;&#34;
        buf = state.buf
        start_position = buf.position
        kw = buf.pop_identifier()
        if not kw or kw not in (&#34;true&#34;, &#34;false&#34;):
            state.push_error(
                &#34;Expected a &#39;true&#39; or &#39;false&#39; keyword&#39;&#34;, kw, position=start_position
            )
        else:
            state.stats.num_bools += 1
        return kw == &#34;true&#34;

    def encode_boolean(self, bval, state):
        &#34;&#34;&#34;Encodes the Python boolean into a JSON Boolean literal.&#34;&#34;&#34;
        state.append(&#34;true&#34; if bool(bval) else &#34;false&#34;)

    def decode_number(self, state):
        &#34;&#34;&#34;Intermediate-level decoder for JSON numeric literals.

        Takes a string and a starting index, and returns a Python
        suitable numeric type and the index of the next unparsed character.

        The returned numeric type can be either of a Python int,
        long, or float.  In addition some special non-numbers may
        also be returned such as nan, inf, and neginf (technically
        which are Python floats, but have no numeric value.)

        Ref. ECMAScript section 8.5.

        &#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)
        start_position = buf.position

        # Use external number parser hook if available
        if self.has_hook(&#34;decode_number&#34;) or self.has_hook(&#34;decode_float&#34;):
            c = buf.peek()
            if c and c in &#34;-+0123456789.&#34;:  # First chars for a number-like value
                buf.save_position()
                nbr = buf.pop_while_in(&#34;-+0123456789abcdefABCDEF&#34; &#34;NaN&#34; &#34;Infinity.&#34;)
                if &#34;.&#34; in nbr and self.has_hook(&#34;decode_float&#34;):
                    hook_name = &#34;decode_float&#34;
                elif self.has_hook(&#34;decode_number&#34;):
                    hook_name = &#34;decode_number&#34;
                else:
                    hook_name = None

                if hook_name:
                    try:
                        val = self.call_hook(hook_name, nbr, position=start_position)
                    except JSONSkipHook:
                        pass
                    except JSONError as err:
                        state.push_exception(err)
                        val = undefined
                    else:
                        buf.clear_saved_position()
                        return val
                # Hook didn&#39;t handle it, restore old position
                buf.restore_position()

        # Detect initial sign character(s)
        sign = +1
        sign_count = 0
        sign_saw_plus = False
        sign_saw_ws = False
        c = buf.peek()
        while c and c in &#34;+-&#34;:
            if c == &#34;-&#34;:
                sign = sign * -1
            elif c == &#34;+&#34;:
                sign_saw_plus = True
            sign_count += 1
            buf.skip()
            if self.skipws_nocomments(state) &gt; 0:
                sign_saw_ws = True
            c = buf.peek()

        if sign_count &gt; 1 or sign_saw_plus:
            state.push_cond(
                self.options.all_numeric_signs,
                &#39;Numbers may only have a single &#34;-&#34; as a sign prefix&#39;,
                position=start_position,
            )
        if sign_saw_ws:
            state.push_error(
                &#34;Spaces may not appear between a +/- number sign and the digits&#34;,
                position=start_position,
            )

        # Check for ECMAScript symbolic non-numbers
        if not c:
            state.push_error(
                &#34;Missing numeric value after sign&#34;, position=start_position
            )
            self.recover_parser(state)
            self.stats.num_undefineds += 1
            return undefined
        elif c.isalpha() or c in &#34;_$&#34;:
            kw = buf.popwhile(lambda c: c.isalnum() or c in &#34;_$&#34;)
            if kw == &#34;NaN&#34;:
                state.push_cond(
                    self.options.non_numbers,
                    &#34;NaN literals are not allowed in strict JSON&#34;,
                    position=start_position,
                )
                state.stats.num_nans += 1
                return self.options.nan
            elif kw == &#34;Infinity&#34;:
                state.push_cond(
                    self.options.non_numbers,
                    &#34;Infinity literals are not allowed in strict JSON&#34;,
                    position=start_position,
                )
                state.stats.num_infinities += 1
                if sign &lt; 0:
                    return self.options.neginf
                else:
                    return self.options.inf
            else:
                state.push_error(
                    &#34;Unknown numeric value keyword&#34;, kw, position=start_position
                )
                return undefined

        # Check for radix-prefixed numbers
        elif c == &#34;0&#34; and (buf.peek(1) in [&#34;x&#34;, &#34;X&#34;]):
            # ----- HEX NUMBERS 0x123
            prefix = buf.popstr(2)
            digits = buf.popwhile(helpers.is_hex_digit)
            state.push_cond(
                self.options.hex_numbers,
                &#34;Hexadecimal literals are not allowed in strict JSON&#34;,
                prefix + digits,
                position=start_position,
            )
            if len(digits) == 0:
                state.push_error(
                    &#34;Hexadecimal number is invalid&#34;, position=start_position
                )
                self.recover_parser(state)
                return undefined
            ival = helpers.decode_hex(digits)
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_HEX)
            return n
        elif c == &#34;0&#34; and (buf.peek(1) in [&#34;o&#34;, &#34;O&#34;]):
            # ----- NEW-STYLE OCTAL NUMBERS  0o123
            prefix = buf.popstr(2)
            digits = buf.popwhile(helpers.is_octal_digit)
            state.push_cond(
                self.options.octal_numbers,
                &#34;Octal literals are not allowed in strict JSON&#34;,
                prefix + digits,
                position=start_position,
            )
            if len(digits) == 0:
                state.push_error(&#34;Octal number is invalid&#34;, position=start_position)
                self.recover_parser(state)
                return undefined
            ival = helpers.decode_octal(digits)
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_OCTAL)
            return n
        elif c == &#34;0&#34; and (buf.peek(1) in [&#34;b&#34;, &#34;B&#34;]):
            # ----- NEW-STYLE BINARY NUMBERS  0b1101
            prefix = buf.popstr(2)
            digits = buf.popwhile(helpers.is_binary_digit)
            state.push_cond(
                self.options.binary_numbers,
                &#34;Binary literals are not allowed in strict JSON&#34;,
                prefix + digits,
                position=start_position,
            )
            if len(digits) == 0:
                state.push_error(&#34;Binary number is invalid&#34;, position=start_position)
                self.recover_parser(state)
                return undefined
            ival = helpers.decode_binary(digits)
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_BINARY)
            return n
        else:
            # ----- DECIMAL OR LEGACY-OCTAL NUMBER.   123, 0123
            # General syntax is:  \d+[\.\d+][e[+-]?\d+]
            number = buf.popwhile(lambda c: c in &#34;0123456789.+-eE&#34;)
            imax = len(number)
            if imax == 0:
                state.push_error(&#34;Missing numeric value&#34;, position=start_position)
            has_leading_zero = False
            units_digits = []  # digits making up whole number portion
            fraction_digits = []  # digits making up fractional portion
            exponent_digits = []  # digits making up exponent portion (excluding sign)
            esign = &#34;+&#34;  # sign of exponent
            sigdigits = 0  # number of significant digits (approximate)
            saw_decimal_point = False
            saw_exponent = False

            # Break number into parts in a first pass...use a mini state machine
            in_part = &#34;units&#34;
            for i, c in enumerate(number):

                if c == &#34;.&#34;:
                    if in_part != &#34;units&#34;:
                        state.push_error(&#34;Bad number&#34;, number, position=start_position)
                        self.recover_parser(state)
                        return undefined
                    in_part = &#34;fraction&#34;
                    saw_decimal_point = True
                elif c in &#34;eE&#34;:
                    if in_part == &#34;exponent&#34;:
                        state.push_error(&#34;Bad number&#34;, number, position=start_position)
                        self.recover_parser(state)
                        return undefined
                    in_part = &#34;exponent&#34;
                    saw_exponent = True
                elif c in &#34;+-&#34;:
                    if in_part != &#34;exponent&#34; or exponent_digits:
                        state.push_error(&#34;Bad number&#34;, number, position=start_position)
                        self.recover_parser(state)
                        return undefined
                    esign = c
                else:  # digit
                    if in_part == &#34;units&#34;:
                        units_digits.append(c)
                    elif in_part == &#34;fraction&#34;:
                        fraction_digits.append(c)
                    elif in_part == &#34;exponent&#34;:
                        exponent_digits.append(c)
            units_s = &#34;&#34;.join(units_digits)
            fraction_s = &#34;&#34;.join(fraction_digits)
            exponent_s = &#34;&#34;.join(exponent_digits)

            # Basic syntax rules checking
            is_integer = not (saw_decimal_point or saw_exponent)

            if not units_s and not fraction_s:
                state.push_error(&#34;Bad number&#34;, number, position=start_position)
                self.recover_parser(state)
                return undefined

            if saw_decimal_point and not fraction_s:
                state.push_cond(
                    self.options.trailing_decimal_point,
                    &#34;Bad number, decimal point must be followed by at least one digit&#34;,
                    number,
                    position=start_position,
                )
                fraction_s = &#34;0&#34;

            if saw_exponent and not exponent_s:
                state.push_error(
                    &#34;Bad number, exponent is missing&#34;, number, position=start_position
                )
                self.recover_parser(state)
                return undefined

            if not units_s:
                state.push_cond(
                    self.options.initial_decimal_point,
                    &#34;Bad number, decimal point must be preceded by at least one digit&#34;,
                    number,
                    position=start_position,
                )
                units = &#34;0&#34;
            elif len(units_s) &gt; 1 and units_s[0] == &#34;0&#34;:
                has_leading_zero = True
                if self.options.is_forbid_leading_zeros:
                    state.push_cond(
                        self.options.leading_zeros,
                        &#34;Numbers may not have extra leading zeros&#34;,
                        number,
                        position=start_position,
                    )
                elif self.options.is_warn_leading_zeros:
                    state.push_cond(
                        self.options.leading_zeros,
                        &#34;Numbers may not have leading zeros; interpreting as %s&#34;
                        % self.options.leading_zero_radix_as_word,
                        number,
                        position=start_position,
                    )

            # Estimate number of significant digits
            sigdigits = len((units_s + fraction_s).replace(&#34;0&#34;, &#34; &#34;).strip())

            # Handle legacy octal integers.
            if has_leading_zero and is_integer and self.options.leading_zero_radix == 8:
                # ----- LEGACY-OCTAL  0123
                try:
                    ival = helpers.decode_octal(units_s)
                except ValueError:
                    state.push_error(
                        &#34;Bad number, not a valid octal value&#34;,
                        number,
                        position=start_position,
                    )
                    self.recover_parser(state)
                    return self.options.nan  # undefined
                state.update_integer_stats(ival, sign=sign, position=start_position)
                n = state.options.make_int(
                    ival, sign, number_format=NUMBER_FORMAT_LEGACYOCTAL
                )
                return n

            # Determine the exponential part
            if exponent_s:
                try:
                    exponent = int(exponent_s)
                except ValueError:
                    state.push_error(
                        &#34;Bad number, bad exponent&#34;, number, position=start_position
                    )
                    self.recover_parser(state)
                    return undefined
                if esign == &#34;-&#34;:
                    exponent = -exponent
            else:
                exponent = 0

            # Try to make an int/long first.
            if not saw_decimal_point and exponent &gt;= 0:
                # ----- A DECIMAL INTEGER
                ival = int(units_s)
                if exponent != 0:
                    ival *= 10 ** exponent
                state.update_integer_stats(ival, sign=sign, position=start_position)
                n = state.options.make_int(ival, sign)
            else:
                # ----- A FLOATING-POINT NUMBER
                try:
                    if (
                        exponent &lt; float_minexp
                        or exponent &gt; float_maxexp
                        or sigdigits &gt; float_sigdigits
                    ):
                        n = state.options.make_decimal(number, sign)
                    else:
                        n = state.options.make_float(number, sign)
                except ValueError as err:
                    state.push_error(
                        &#34;Bad number, %s&#34; % err.message, number, position=start_position
                    )
                    n = undefined
                else:
                    state.update_float_stats(n, sign=sign, position=start_position)
            return n

    def encode_number(self, n, state):
        &#34;&#34;&#34;Encodes a Python numeric type into a JSON numeric literal.

        The special non-numeric values of float(&#39;nan&#39;), float(&#39;inf&#39;)
        and float(&#39;-inf&#39;) are translated into appropriate JSON
        literals.

        Note that Python complex types are not handled, as there is no
        ECMAScript equivalent type.

        &#34;&#34;&#34;
        if isinstance(n, complex):
            if n.imag:
                raise JSONEncodeError(
                    &#34;Can not encode a complex number that has a non-zero imaginary part&#34;,
                    n,
                )
            n = n.real

        if isinstance(n, json_int):
            state.append(n.json_format())
            return

        if isinstance(n, int):
            state.append(str(n))
            return

        if isinstance(n, decimal.Decimal):
            if n.is_nan():  # Could be &#39;NaN&#39; or &#39;sNaN&#39;
                state.append(&#34;NaN&#34;)
            elif n.is_infinite():
                if n.is_signed():
                    state.append(&#34;-Infinity&#34;)
                else:
                    state.append(&#34;Infinity&#34;)
            else:
                s = str(n).lower()
                if &#34;e&#34; not in s and &#34;.&#34; not in s:
                    s = s + &#34;.0&#34;
                state.append(s)
            return

        global nan, inf, neginf
        if n is nan:
            state.append(&#34;NaN&#34;)
        elif n is inf:
            state.append(&#34;Infinity&#34;)
        elif n is neginf:
            state.append(&#34;-Infinity&#34;)
        elif isinstance(n, float):
            # Check for non-numbers.
            # In python nan == inf == -inf, so must use repr() to distinguish
            reprn = repr(n).lower()
            if (&#34;inf&#34; in reprn and &#34;-&#34; in reprn) or n == neginf:
                state.append(&#34;-Infinity&#34;)
            elif &#34;inf&#34; in reprn or n is inf:
                state.append(&#34;Infinity&#34;)
            elif &#34;nan&#34; in reprn or n is nan:
                state.append(&#34;NaN&#34;)
            else:
                # A normal float.
                state.append(repr(n))
        else:
            raise TypeError(
                &#34;encode_number expected an integral, float, or decimal number type&#34;,
                type(n),
            )

    def decode_string(self, state):
        &#34;&#34;&#34;Intermediate-level decoder for JSON string literals.

        Takes a string and a starting index, and returns a Python
        string (or unicode string) and the index of the next unparsed
        character.

        &#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)
        quote = buf.peek()
        if quote == &#39;&#34;&#39;:
            pass
        elif quote == &#34;&#39;&#34;:
            state.push_cond(
                self.options.single_quoted_strings,
                &#34;String literals must use double quotation marks in strict JSON&#34;,
            )
        else:
            state.push_error(&#34;String literal must be properly quoted&#34;)
            return undefined

        string_position = buf.position
        buf.skip()

        if self.options.is_forbid_js_string_escapes:
            escapes = self._escapes_json
        else:
            escapes = self._escapes_js
        ccallowed = not self.options.is_forbid_control_char_in_string
        chunks = []
        _append = chunks.append

        # Used to track the last seen high-surrogate character
        high_surrogate = None
        highsur_position = None

        # Used to track if errors occured so we don&#39;t keep reporting multiples
        had_lineterm_error = False

        # Start looping character by character until the final quotation mark
        saw_final_quote = False
        should_stop = False
        while not saw_final_quote and not should_stop:
            if buf.at_end:
                state.push_error(
                    &#34;String literal is not terminated&#34;,
                    outer_position=string_position,
                    context=&#34;String&#34;,
                )
                break
            c = buf.peek()

            # Make sure a high surrogate is immediately followed by a low surrogate
            if high_surrogate:
                if 0xDC00 &lt;= ord(c) &lt;= 0xDFFF:
                    low_surrogate = buf.pop()
                    try:
                        uc = helpers.surrogate_pair_as_unicode(
                            high_surrogate, low_surrogate
                        )
                    except ValueError as err:
                        state.push_error(
                            &#34;Illegal Unicode surrogate pair&#34;,
                            (high_surrogate, low_surrogate),
                            position=highsur_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        uc = &#34;\ufffd&#34;  # replacement char
                    _append(uc)
                    high_surrogate = None
                    highsur_position = None
                    continue  # ==== NEXT CHAR
                elif buf.peekstr(2) != &#34;\\u&#34;:
                    state.push_error(
                        &#34;High unicode surrogate must be followed by a low surrogate&#34;,
                        position=highsur_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    _append(&#34;\ufffd&#34;)  # replacement char
                    high_surrogate = None
                    highsur_position = None

            if c == quote:
                buf.skip()  # skip over closing quote
                saw_final_quote = True
                break
            elif c == &#34;\\&#34;:
                # Escaped character
                escape_position = buf.position
                buf.skip()  # skip over backslash
                c = buf.peek()
                if not c:
                    state.push_error(
                        &#34;Escape in string literal is incomplete&#34;,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    break
                elif helpers.is_octal_digit(c):
                    # Handle octal escape codes first so special \0 doesn&#39;t kick in yet.
                    # Follow Annex B.1.2 of ECMAScript standard.
                    if &#34;0&#34; &lt;= c &lt;= &#34;3&#34;:
                        maxdigits = 3
                    else:
                        maxdigits = 2
                    digits = buf.popwhile(helpers.is_octal_digit, maxchars=maxdigits)
                    n = helpers.decode_octal(digits)
                    if n == 0:
                        state.push_cond(
                            self.options.zero_byte,
                            &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                            &#34;\\&#34; + digits,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                    else:  # n != 0
                        state.push_cond(
                            self.options.octal_numbers,
                            &#39;JSON does not allow octal character escapes other than &#34;\\0&#34;&#39;,
                            &#34;\\&#34; + digits,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                    should_stop = state.should_stop
                    if n &lt; 128:
                        _append(chr(n))
                    else:
                        _append(helpers.safe_unichr(n))
                elif c in escapes:
                    buf.skip()
                    _append(escapes[c])
                elif c == &#34;u&#34; or c == &#34;x&#34;:
                    buf.skip()
                    esc_opener = &#34;\\&#34; + c
                    esc_closer = &#34;&#34;
                    if c == &#34;u&#34;:
                        if buf.peek() == &#34;{&#34;:
                            buf.skip()
                            esc_opener += &#34;{&#34;
                            esc_closer = &#34;}&#34;
                            maxdigits = None
                            state.push_cond(
                                self.options.extended_unicode_escapes,
                                &#34;JSON strings do not allow \\u{...} escapes&#34;,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                        else:
                            maxdigits = 4
                    else:  # c== &#39;x&#39;
                        state.push_cond(
                            self.options.js_string_escapes,
                            &#34;JSON strings may not use the \\x hex-escape&#34;,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        maxdigits = 2

                    digits = buf.popwhile(helpers.is_hex_digit, maxchars=maxdigits)

                    if esc_closer:
                        if buf.peek() != esc_closer:
                            state.push_error(
                                &#34;Unicode escape sequence is missing closing &#39;%s&#39;&#34;
                                % esc_closer,
                                esc_opener + digits,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                            should_stop = state.should_stop
                        else:
                            buf.skip()

                    esc_sequence = esc_opener + digits + esc_closer

                    if not digits:
                        state.push_error(
                            &#34;numeric character escape sequence is truncated&#34;,
                            esc_sequence,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        codepoint = 0xFFFD  # replacement char
                    else:
                        if maxdigits and len(digits) != maxdigits:
                            state.push_error(
                                &#34;escape sequence has too few hexadecimal digits&#34;,
                                esc_sequence,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                        codepoint = helpers.decode_hex(digits)

                    if codepoint &gt; 0x10FFFF:
                        state.push_error(
                            &#34;Unicode codepoint is beyond U+10FFFF&#34;,
                            esc_opener + digits + esc_closer,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        codepoint = 0xFFFD  # replacement char

                    if high_surrogate:
                        # Decode surrogate pair and clear high surrogate
                        low_surrogate = chr(codepoint)
                        try:
                            uc = helpers.surrogate_pair_as_unicode(
                                high_surrogate, low_surrogate
                            )
                        except ValueError as err:
                            state.push_error(
                                &#34;Illegal Unicode surrogate pair&#34;,
                                (high_surrogate, low_surrogate),
                                position=highsur_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                            should_stop = state.should_stop
                            uc = &#34;\ufffd&#34;  # replacement char
                        _append(uc)
                        high_surrogate = None
                        highsur_position = None
                    elif codepoint &lt; 128:
                        # ASCII chars always go in as a str
                        if codepoint == 0:
                            state.push_cond(
                                self.options.zero_byte,
                                &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                            should_stop = state.should_stop
                        _append(chr(codepoint))
                    elif 0xD800 &lt;= codepoint &lt;= 0xDBFF:  # high surrogate
                        high_surrogate = chr(
                            codepoint
                        )  # remember until we get to the low surrogate
                        highsur_position = escape_position.copy()
                    elif 0xDC00 &lt;= codepoint &lt;= 0xDFFF:  # low surrogate
                        state.push_error(
                            &#34;Low unicode surrogate must be proceeded by a high surrogate&#34;,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        _append(&#34;\ufffd&#34;)  # replacement char
                    else:
                        # Other chars go in as a unicode char
                        _append(helpers.safe_unichr(codepoint))
                else:
                    # Unknown escape sequence
                    state.push_cond(
                        self.options.nonescape_characters,
                        &#34;String escape code is not allowed in strict JSON&#34;,
                        &#34;\\&#34; + c,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    _append(c)
                    buf.skip()
            elif ord(c) &lt;= 0x1F:  # A control character
                if ord(c) == 0:
                    state.push_cond(
                        self.options.zero_byte,
                        &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                        position=buf.position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                if self.islineterm(c):
                    if not had_lineterm_error:
                        state.push_error(
                            &#34;Line terminator characters must be escaped inside string literals&#34;,
                            &#34;U+%04X&#34; % ord(c),
                            position=buf.position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        had_lineterm_error = True
                    _append(c)
                    buf.skip()
                elif ccallowed:
                    _append(c)
                    buf.skip()
                else:
                    state.push_error(
                        &#34;Control characters must be escaped inside JSON string literals&#34;,
                        &#34;U+%04X&#34; % ord(c),
                        position=buf.position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    buf.skip()
            elif 0xD800 &lt;= ord(c) &lt;= 0xDBFF:  # a raw high surrogate
                high_surrogate = buf.pop()  # remember until we get to the low surrogate
                highsur_position = buf.position.copy()
            else:  # A normal character; not an escape sequence or end-quote.
                # Find a whole sequence of &#34;safe&#34; characters so we can append them
                # all at once rather than one a time, for speed.
                chunk = buf.popwhile(
                    lambda c: c not in helpers.unsafe_string_chars and c != quote
                )
                if not chunk:
                    _append(c)
                    buf.skip()
                else:
                    _append(chunk)

        # Check proper string termination
        if high_surrogate:
            state.push_error(
                &#34;High unicode surrogate must be followed by a low surrogate&#34;,
                position=highsur_position,
                outer_position=string_position,
                context=&#34;String&#34;,
            )
            _append(&#34;\ufffd&#34;)  # replacement char
            high_surrogate = None
            highsur_position = None

        if not saw_final_quote:
            state.push_error(
                &#34;String literal is not terminated with a quotation mark&#34;,
                position=buf.position,
                outer_position=string_position,
                context=&#34;String&#34;,
            )

        if state.should_stop:
            return undefined

        # Compose the python string and update stats
        s = &#34;&#34;.join(chunks)
        state.update_string_stats(s, position=string_position)

        # Call string hook
        if self.has_hook(&#34;decode_string&#34;):
            try:
                s = self.call_hook(&#34;decode_string&#34;, s, position=string_position)
            except JSONSkipHook:
                pass
            except JSONError as err:
                state.push_exception(err)
                s = undefined
        return s

    def encode_string(self, s, state):
        &#34;&#34;&#34;Encodes a Python string into a JSON string literal.&#34;&#34;&#34;
        # Must handle instances of UserString specially in order to be
        # able to use ord() on it&#39;s simulated &#34;characters&#34;.  Also
        # convert Python2 &#39;str&#39; types to unicode strings first.
        import unicodedata, sys
        import collections

        py2strenc = self.options.py2str_encoding
        if isinstance(s, collections.UserString):

            def tochar(c):
                c2 = c.data
                if py2strenc and not isinstance(c2, str):
                    return c2.decode(py2strenc)
                else:
                    return c2

        elif py2strenc and not isinstance(s, str):
            s = s.decode(py2strenc)
            tochar = None
        else:
            # Could use &#34;lambda c:c&#34;, but that is too slow.  So we set to None
            # and use an explicit if test inside the loop.
            tochar = None

        chunks = []
        chunks.append(&#39;&#34;&#39;)
        revesc = self._rev_escapes
        optrevesc = self._optional_rev_escapes
        asciiencodable = self._asciiencodable
        always_escape = state.options.always_escape_chars
        encunicode = state.escape_unicode_test
        i = 0
        imax = len(s)
        while i &lt; imax:
            if tochar:
                c = tochar(s[i])
            else:
                c = s[i]
            cord = ord(c)
            if (
                cord &lt; 256
                and asciiencodable[cord]
                and isinstance(encunicode, bool)
                and not (always_escape and c in always_escape)
            ):
                # Contiguous runs of plain old printable ASCII can be copied
                # directly to the JSON output without worry (unless the user
                # has supplied a custom is-encodable function).
                j = i
                i += 1
                while i &lt; imax:
                    if tochar:
                        c = tochar(s[i])
                    else:
                        c = s[i]
                    cord = ord(c)
                    if (
                        cord &lt; 256
                        and asciiencodable[cord]
                        and not (always_escape and c in always_escape)
                    ):
                        i += 1
                    else:
                        break
                chunks.append(str(s[j:i]))
            elif c in revesc:
                # Has a shortcut escape sequence, like &#34;\n&#34;
                chunks.append(revesc[c])
                i += 1
            elif cord &lt;= 0x1F:
                # Always unicode escape ASCII-control characters
                chunks.append(r&#34;\u%04x&#34; % cord)
                i += 1
            elif 0xD800 &lt;= cord &lt;= 0xDFFF:
                # A raw surrogate character!
                # This should ONLY happen in &#34;narrow&#34; Python builds
                # where (sys.maxunicode == 65535) as Python itself
                # uses UTF-16.  But for &#34;wide&#34; Python builds, a raw
                # surrogate should never happen.
                handled_raw_surrogates = False
                if (
                    sys.maxunicode == 0xFFFF
                    and 0xD800 &lt;= cord &lt;= 0xDBFF
                    and (i + 1) &lt; imax
                ):
                    # In a NARROW Python, output surrogate pair as-is
                    hsurrogate = cord
                    i += 1
                    if tochar:
                        c = tochar(s[i])
                    else:
                        c = s[i]
                    cord = ord(c)
                    i += 1
                    if 0xDC00 &lt;= cord &lt;= 0xDFFF:
                        lsurrogate = cord
                        chunks.append(r&#34;\u%04x\u%04x&#34; % (hsurrogate, lsurrogate))
                        handled_raw_surrogates = True
                if not handled_raw_surrogates:
                    cname = &#34;U+%04X&#34; % cord
                    raise JSONEncodeError(
                        &#34;can not include or escape a Unicode surrogate character&#34;, cname
                    )
            elif cord &lt;= 0xFFFF:
                # Other BMP Unicode character
                if always_escape and c in always_escape:
                    doesc = True
                elif unicodedata.category(c) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]:
                    doesc = True
                elif callable(encunicode):
                    doesc = encunicode(c)
                else:
                    doesc = encunicode

                if doesc:
                    if c in optrevesc:
                        chunks.append(optrevesc[c])
                    else:
                        chunks.append(r&#34;\u%04x&#34; % cord)
                else:
                    chunks.append(c)
                i += 1
            else:  # ord(c) &gt;= 0x10000
                # Non-BMP Unicode
                if always_escape and c in always_escape:
                    doesc = True
                elif unicodedata.category(c) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]:
                    doesc = True
                elif callable(encunicode):
                    doesc = encunicode(c)
                else:
                    doesc = encunicode

                if doesc:
                    for surrogate in helpers.unicode_as_surrogate_pair(c):
                        chunks.append(r&#34;\u%04x&#34; % ord(surrogate))
                else:
                    chunks.append(c)
                i += 1

        chunks.append(&#39;&#34;&#39;)
        state.append(&#34;&#34;.join(chunks))

    def decode_identifier(self, state, identifier_as_string=False):
        &#34;&#34;&#34;Decodes an identifier/keyword.&#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)
        start_position = buf.position
        obj = None

        kw = buf.pop_identifier()

        if not kw:
            state.push_error(&#34;Expected an identifier&#34;, position=start_position)
        elif kw == &#34;null&#34;:
            obj = None
            state.stats.num_nulls += 1
        elif kw == &#34;true&#34;:
            obj = True
            state.stats.num_bools += 1
        elif kw == &#34;false&#34;:
            obj = False
            state.stats.num_bools += 1
        elif kw == &#34;undefined&#34;:
            state.push_cond(
                self.options.undefined_values,
                &#34;Strict JSON does not allow the &#39;undefined&#39; keyword&#34;,
                kw,
                position=start_position,
            )
            obj = undefined
            state.stats.num_undefineds += 1
        elif kw == &#34;NaN&#34; or kw == &#34;Infinity&#34;:
            state.push_cond(
                self.options.non_numbers,
                &#34;%s literals are not allowed in strict JSON&#34; % kw,
                kw,
                position=start_position,
            )
            if self.has_hook(&#34;decode_float&#34;):
                try:
                    val = self.call_hook(&#34;decode_float&#34;, kw, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    return undefined
                else:
                    return val
            elif self.has_hook(&#34;decode_number&#34;):
                try:
                    val = self.call_hook(&#34;decode_number&#34;, kw, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    return undefined
                else:
                    return val
            if kw == &#34;NaN&#34;:
                state.stats.num_nans += 1
                obj = state.options.nan
            else:
                state.stats.num_infinities += 1
                obj = state.options.inf
        else:
            # Convert unknown identifiers into strings
            if identifier_as_string:
                if kw in helpers.javascript_reserved_words:
                    state.push_warning(
                        &#34;Identifier is a JavaScript reserved word&#34;,
                        kw,
                        position=start_position,
                    )
                state.push_cond(
                    self.options.identifier_keys,
                    &#34;JSON does not allow identifiers to be used as strings&#34;,
                    kw,
                    position=start_position,
                )
                state.stats.num_identifiers += 1
                obj = self.decode_javascript_identifier(kw)
            else:
                state.push_error(&#34;Unknown identifier&#34;, kw, position=start_position)
                obj = undefined
                state.stats.num_identifiers += 1
        return obj

    def skip_comment(self, state):
        &#34;&#34;&#34;Skips an ECMAScript comment, either // or /* style.

        The contents of the comment are returned as a string, as well
        as the index of the character immediately after the comment.

        &#34;&#34;&#34;
        buf = state.buf
        uniws = self.options.unicode_whitespace
        s = buf.peekstr(2)
        if s != &#34;//&#34; and s != &#34;/*&#34;:
            return None
        state.push_cond(
            self.options.comments, &#34;Comments are not allowed in strict JSON&#34;
        )
        start_position = buf.position
        buf.skip(2)
        multiline = s == &#34;/*&#34;
        saw_close = False
        while not buf.at_end:
            if multiline:
                if buf.peekstr(2) == &#34;*/&#34;:
                    buf.skip(2)
                    saw_close = True
                    break
                elif buf.peekstr(2) == &#34;/*&#34;:
                    state.push_error(
                        &#34;Multiline /* */ comments may not nest&#34;,
                        outer_position=start_position,
                        context=&#34;Comment&#34;,
                    )
            else:
                if buf.at_eol(uniws):
                    buf.skip_to_next_line(uniws)
                    saw_close = True
                    break
            buf.pop()

        if not saw_close and multiline:
            state.push_error(
                &#34;Comment was never terminated&#34;,
                outer_position=start_position,
                context=&#34;Comment&#34;,
            )
        state.stats.num_comments += 1

    def skipws_nocomments(self, state):
        &#34;&#34;&#34;Skips whitespace (will not allow comments).&#34;&#34;&#34;
        return state.buf.skipws(not self.options.is_forbid_unicode_whitespace)

    def skipws(self, state):
        &#34;&#34;&#34;Skips all whitespace, including comments and unicode whitespace

        Takes a string and a starting index, and returns the index of the
        next non-whitespace character.

        If the &#39;skip_comments&#39; behavior is True and not running in
        strict JSON mode, then comments will be skipped over just like
        whitespace.

        &#34;&#34;&#34;
        buf = state.buf
        uniws = not self.options.unicode_whitespace
        while not buf.at_end:
            c = buf.peekstr(2)
            if c == &#34;/*&#34; or c == &#34;//&#34;:
                cmt = self.skip_comment(state)
            elif buf.at_ws(uniws):
                buf.skipws(uniws)
            else:
                break

    def decode_composite(self, state):
        &#34;&#34;&#34;Intermediate-level JSON decoder for composite literal types (array and object).&#34;&#34;&#34;
        if state.should_stop:
            return None
        buf = state.buf
        self.skipws(state)
        opener = buf.peek()
        if opener not in &#34;{[&#34;:
            state.push_error(&#39;Composite data must start with &#34;[&#34; or &#34;{&#34;&#39;)
            return None
        start_position = buf.position
        buf.skip()
        if opener == &#34;[&#34;:
            isdict = False
            closer = &#34;]&#34;
            obj = []
        else:
            isdict = True
            closer = &#34;}&#34;
            if state.options.sort_keys == SORT_PRESERVE and _OrderedDict:
                obj = _OrderedDict()
            else:
                obj = {}
        num_items = 0
        self.skipws(state)

        c = buf.peek()
        if c == closer:
            # empty composite
            buf.skip()
            done = True
        else:
            saw_value = False  # set to false at beginning and after commas
            done = False
            while not done and not buf.at_end and not state.should_stop:
                self.skipws(state)
                c = buf.peek()
                if c == &#34;&#34;:
                    break  # will report error futher down because done==False
                elif c == &#34;,&#34;:
                    if not saw_value:
                        # no preceeding value, an elided (omitted) element
                        if isdict:
                            state.push_error(
                                &#34;Can not omit elements of an object (dictionary)&#34;,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        else:
                            state.push_cond(
                                self.options.omitted_array_elements,
                                &#34;Can not omit elements of an array (list)&#34;,
                                outer_position=start_position,
                                context=&#34;Array&#34;,
                            )
                            obj.append(undefined)
                            if state.stats:
                                state.stats.num_undefineds += 1
                    buf.skip()  # skip over comma
                    saw_value = False
                    continue
                elif c == closer:
                    if not saw_value:
                        if isdict:
                            state.push_cond(
                                self.options.trailing_comma,
                                &#34;Strict JSON does not allow a final comma in an object (dictionary) literal&#34;,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        else:
                            state.push_cond(
                                self.options.trailing_comma,
                                &#34;Strict JSON does not allow a final comma in an array (list) literal&#34;,
                                outer_position=start_position,
                                context=&#34;Array&#34;,
                            )
                    buf.skip()  # skip over closer
                    done = True
                    break
                elif c in &#34;]}&#34;:
                    if isdict:
                        cdesc = &#34;Object&#34;
                    else:
                        cdesc = &#34;Array&#34;
                    state.push_error(
                        &#34;Expected a &#39;%c&#39; but saw &#39;%c&#39;&#34; % (closer, c),
                        outer_position=start_position,
                        context=cdesc,
                    )
                    done = True
                    break

                if state.should_stop:
                    break

                # Decode the item/value
                value_position = buf.position

                if isdict:
                    val = self.decodeobj(state, identifier_as_string=True)
                else:
                    val = self.decodeobj(state, identifier_as_string=False)

                if val is syntax_error:
                    recover_c = self.recover_parser(state)
                    if recover_c not in &#34;:&#34;:
                        continue

                if state.should_stop:
                    break

                if saw_value:
                    # Two values without a separating comma
                    if isdict:
                        cdesc = &#34;Object&#34;
                    else:
                        cdesc = &#34;Array&#34;
                    state.push_error(
                        &#34;Values must be separated by a comma&#34;,
                        position=value_position,
                        outer_position=start_position,
                        context=cdesc,
                    )

                saw_value = True
                self.skipws(state)

                if state.should_stop:
                    break

                if isdict:
                    skip_item = False
                    key = val  # Ref 11.1.5
                    key_position = value_position
                    if not helpers.isstringtype(key):
                        if helpers.isnumbertype(key):
                            state.push_cond(
                                self.options.nonstring_keys,
                                &#34;JSON only permits string literals as object properties (keys)&#34;,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        else:
                            state.push_error(
                                &#34;Object properties (keys) must be string literals, numbers, or identifiers&#34;,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                            skip_item = True
                    c = buf.peek()
                    if c != &#34;:&#34;:
                        state.push_error(
                            &#39;Missing value for object property, expected &#34;:&#34;&#39;,
                            position=value_position,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                    buf.skip()  # skip over colon
                    self.skipws(state)

                    rval = self.decodeobj(state)
                    self.skipws(state)
                    if not skip_item:
                        if key in obj:
                            state.push_cond(
                                self.options.duplicate_keys,
                                &#34;Object contains duplicate key&#34;,
                                key,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        if key == &#34;&#34;:
                            state.push_cond(
                                self.options.non_portable,
                                &#39;Using an empty string &#34;&#34; as an object key may not be portable&#39;,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        obj[key] = rval
                        num_items += 1
                else:  # islist
                    obj.append(val)
                    num_items += 1
            # end while

        if state.stats:
            if isdict:
                state.stats.max_items_in_object = max(
                    state.stats.max_items_in_object, num_items
                )
            else:
                state.stats.max_items_in_array = max(
                    state.stats.max_items_in_array, num_items
                )

        if state.should_stop:
            return obj

        # Make sure composite value is properly terminated
        if not done:
            if isdict:
                state.push_error(
                    &#34;Object literal (dictionary) is not terminated&#34;,
                    outer_position=start_position,
                    context=&#34;Object&#34;,
                )
            else:
                state.push_error(
                    &#34;Array literal (list) is not terminated&#34;,
                    outer_position=start_position,
                    context=&#34;Array&#34;,
                )

        # Update stats and run hooks
        if isdict:
            state.stats.num_objects += 1
            if self.has_hook(&#34;decode_object&#34;):
                try:
                    obj = self.call_hook(&#34;decode_object&#34;, obj, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    obj = undefined
        else:
            state.stats.num_arrays += 1
            if self.has_hook(&#34;decode_array&#34;):
                try:
                    obj = self.call_hook(&#34;decode_array&#34;, obj, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    obj = undefined
        return obj

    def decode_javascript_identifier(self, name):
        &#34;&#34;&#34;Convert a JavaScript identifier into a Python string object.

        This method can be overriden by a subclass to redefine how JavaScript
        identifiers are turned into Python objects.  By default this just
        converts them into strings.

        &#34;&#34;&#34;
        return name

    def decodeobj(self, state, identifier_as_string=False, at_document_start=False):
        &#34;&#34;&#34;Intermediate-level JSON decoder.

        Takes a string and a starting index, and returns a two-tuple consting
        of a Python object and the index of the next unparsed character.

        If there is no value at all (empty string, etc), then None is
        returned instead of a tuple.

        &#34;&#34;&#34;
        buf = state.buf
        obj = None
        self.skipws(state)
        if buf.at_end:
            state.push_error(&#34;Unexpected end of input&#34;)

        c = buf.peek()
        if c in &#34;{[&#34;:
            state.cur_depth += 1
            try:
                state.update_depth_stats()
                obj = self.decode_composite(state)
            finally:
                state.cur_depth -= 1
        else:
            if at_document_start:
                state.push_cond(
                    self.options.any_type_at_start,
                    &#34;JSON document must start with an object or array type only&#34;,
                )
            if c in self._string_quotes:
                obj = self.decode_string(state)
            elif c.isdigit() or c in &#34;.+-&#34;:
                obj = self.decode_number(state)
            elif c.isalpha() or c in &#34;_$&#34;:
                obj = self.decode_identifier(
                    state, identifier_as_string=identifier_as_string
                )
            else:
                state.push_error(&#34;Can not decode value starting with character %r&#34; % c)
                buf.skip()
                self.recover_parser(state)
                obj = syntax_error
        return obj

    def decode(self, txt, encoding=None, return_errors=False, return_stats=False):
        &#34;&#34;&#34;Decodes a JSON-encoded string into a Python object.

        The &#39;return_errors&#39; parameter controls what happens if the
        input JSON has errors in it.

            * False: the first error will be raised as a Python
              exception. If there are no errors then the corresponding
              Python object will be returned.

            * True: the return value is always a 2-tuple: (object, error_list)

        &#34;&#34;&#34;
        import sys

        state = decode_state(options=self.options)

        # Prepare the input
        state.set_input(txt, encoding=encoding)

        # Do the decoding
        if not state.has_errors:
            self.__sanity_check_start(state)

        if not state.has_errors:
            try:
                self._do_decode(state)  # DECODE!
            except JSONException as err:
                state.push_exception(err)
            except Exception as err:  # Mainly here to catch maximum recursion depth exceeded
                newerr = JSONDecodeError(
                    &#34;An unexpected failure occured&#34;,
                    severity=&#34;fatal&#34;,
                    position=state.buf.position,
                )
                try:
                    raise newerr from err
                except Exception as err:
                    state.push_exception(newerr)

        if return_stats and state.buf:
            state.stats.num_excess_whitespace = state.buf.num_ws_skipped
            state.stats.total_chars = state.buf.position.char_position

        # Handle the errors
        result_type = _namedtuple(&#34;json_results&#34;, [&#34;object&#34;, &#34;errors&#34;, &#34;stats&#34;])

        if return_errors:
            if return_stats:
                return result_type(state.obj, state.errors, state.stats)
            else:
                return result_type(state.obj, state.errors, None)
        else:
            # Don&#39;t cause warnings to raise an error
            errors = [err for err in state.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)]
            if errors:
                raise errors[0]
            if return_stats:
                return result_type(state.obj, None, state.stats)
            else:
                return state.obj

    def __sanity_check_start(self, state):
        &#34;&#34;&#34;Check that the document seems sane by looking at the first couple characters.

        Check that the decoding seems sane.  Per RFC 4627 section 3:
            &#34;Since the first two characters of a JSON text will
             always be ASCII characters [RFC0020], ...&#34;
        [WAS removed from RFC 7158, but still valid via the grammar.]

        This check is probably not necessary, but it allows us to
        raise a suitably descriptive error rather than an obscure
        syntax error later on.

        Note that the RFC requirements of two ASCII characters seems
        to be an incorrect statement as a JSON string literal may have
        as it&#39;s first character any unicode character.  Thus the first
        two characters will always be ASCII, unless the first
        character is a quotation mark.  And in non-strict mode we can
        also have a few other characters too.

        &#34;&#34;&#34;
        is_sane = True
        unitxt = state.buf.peekstr(2)
        if len(unitxt) &gt;= 2:
            first, second = unitxt[:2]
            if first in self._string_quotes:
                pass  # second can be anything inside string literal
            else:
                if (
                    (ord(first) &lt; 0x20 or ord(first) &gt; 0x7F)
                    or (ord(second) &lt; 0x20 or ord(second) &gt; 0x7F)
                ) and (not self.isws(first) and not self.isws(second)):
                    # Found non-printable ascii, must check unicode
                    # categories to see if the character is legal.
                    # Only whitespace, line and paragraph separators,
                    # and format control chars are legal here.
                    import unicodedata

                    catfirst = unicodedata.category(str(first))
                    catsecond = unicodedata.category(str(second))
                    if catfirst not in (&#34;Zs&#34;, &#34;Zl&#34;, &#34;Zp&#34;, &#34;Cf&#34;) or catsecond not in (
                        &#34;Zs&#34;,
                        &#34;Zl&#34;,
                        &#34;Zp&#34;,
                        &#34;Cf&#34;,
                    ):
                        state.push_fatal(
                            &#34;The input is gibberish, is the Unicode encoding correct?&#34;
                        )
        return is_sane

    def _do_decode(self, state):
        &#34;&#34;&#34;This is the internal function that does the JSON decoding.

        Called by the decode() method, after it has performed any Unicode decoding, etc.
        &#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)

        if buf.at_end:
            state.push_error(&#34;No value to decode&#34;)
        else:
            if state.options.decimal_context:
                dec_ctx = decimal.localcontext(state.options.decimal_context)
            else:
                dec_ctx = _dummy_context_manager

            with dec_ctx:
                state.obj = self.decodeobj(state, at_document_start=True)

            if not state.should_stop:
                # Make sure there&#39;s nothing at the end
                self.skipws(state)
                if not buf.at_end:
                    state.push_error(&#34;Unexpected text after end of JSON value&#34;)

    def _classify_for_encoding(self, obj):
        import datetime

        c = &#34;other&#34;
        if obj is None:
            c = &#34;null&#34;
        elif obj is undefined:
            c = &#34;undefined&#34;
        elif isinstance(obj, bool):
            c = &#34;bool&#34;
        elif isinstance(obj, (int, float, complex)) or (
            decimal and isinstance(obj, decimal.Decimal)
        ):
            c = &#34;number&#34;
        elif isinstance(obj, str) or helpers.isstringtype(obj):
            c = &#34;string&#34;
        else:
            if isinstance(obj, dict):
                c = &#34;dict&#34;
            elif (
                isinstance(obj, tuple)
                and hasattr(obj, &#34;_asdict&#34;)
                and callable(obj._asdict)
            ):
                # Have a named tuple
                enc_nt = self.options.encode_namedtuple_as_object
                if enc_nt and (enc_nt is True or (callable(enc_nt) and enc_nt(obj))):
                    c = &#34;namedtuple&#34;
                else:
                    c = &#34;sequence&#34;
            elif isinstance(obj, (list, tuple, set, frozenset)):
                c = &#34;sequence&#34;
            elif hasattr(obj, &#34;iterkeys&#34;) or (
                hasattr(obj, &#34;__getitem__&#34;) and hasattr(obj, &#34;keys&#34;)
            ):
                c = &#34;dict&#34;
            elif isinstance(obj, datetime.datetime):
                # Check datetime before date because it is a subclass!
                c = &#34;datetime&#34;
            elif isinstance(obj, datetime.date):
                c = &#34;date&#34;
            elif isinstance(obj, datetime.time):
                c = &#34;time&#34;
            elif isinstance(obj, datetime.timedelta):
                c = &#34;timedelta&#34;
            elif _py_major &gt;= 3 and isinstance(obj, (bytes, bytearray)):
                c = &#34;bytes&#34;
            elif _py_major &gt;= 3 and isinstance(obj, memoryview):
                c = &#34;memoryview&#34;
            elif _enum is not None and isinstance(obj, _enum):
                c = &#34;enum&#34;
            else:
                c = &#34;other&#34;
        return c

    def encode(self, obj, encoding=None):
        &#34;&#34;&#34;Encodes the Python object into a JSON string representation.

        This method will first attempt to encode an object by seeing
        if it has a json_equivalent() method.  If so than it will
        call that method and then recursively attempt to encode
        the object resulting from that call.

        Next it will attempt to determine if the object is a native
        type or acts like a squence or dictionary.  If so it will
        encode that object directly.

        Finally, if no other strategy for encoding the object of that
        type exists, it will call the encode_default() method.  That
        method currently raises an error, but it could be overridden
        by subclasses to provide a hook for extending the types which
        can be encoded.

        &#34;&#34;&#34;
        import sys, codecs

        # Make a fresh encoding state
        state = encode_state(self.options)

        # Find the codec to use. CodecInfo will be in &#39;cdk&#39; and name in &#39;encoding&#39;.
        #
        # Also set the state&#39;s &#39;escape_unicode_test&#39; property which is used to
        # determine what characters to \u-escape.
        if encoding is None:
            cdk = None
        elif isinstance(encoding, codecs.CodecInfo):
            cdk = encoding
            encoding = cdk.name
        else:
            cdk = helpers.lookup_codec(encoding)
            if not cdk:
                raise JSONEncodeError(
                    &#34;no codec available for character encoding&#34;, encoding
                )

        if self.options.escape_unicode and callable(self.options.escape_unicode):
            # User-supplied repertoire test function
            state.escape_unicode_test = self.options.escape_unicode
        else:
            if (
                self.options.escape_unicode == True
                or not cdk
                or cdk.name.lower() == &#34;ascii&#34;
            ):
                # ASCII, ISO8859-1, or and Unknown codec -- \u escape anything not ASCII
                state.escape_unicode_test = lambda c: ord(c) &gt;= 0x80
            elif cdk.name == &#34;iso8859-1&#34;:
                state.escape_unicode_test = lambda c: ord(c) &gt;= 0x100
            elif cdk and cdk.name.lower().startswith(&#34;utf&#34;):
                # All UTF-x encodings can do the whole Unicode repertoire, so
                # do nothing special.
                state.escape_unicode_test = False
            else:
                # An unusual codec.  We need to test every character
                # to see if it is in the codec&#39;s repertoire to determine
                # if we should \u escape that character.
                enc_func = cdk.encode

                def escape_unicode_hardway(c):
                    try:
                        enc_func(c)
                    except UnicodeEncodeError:
                        return True
                    else:
                        return False

                state.escape_unicode_test = escape_unicode_hardway

        # Make sure the encoding is not degenerate: it can encode the minimal
        # number of characters needed by the JSON syntax rules.
        if encoding is not None:
            try:
                output, nchars = cdk.encode(JSON.json_syntax_characters)
            except UnicodeError as err:
                raise JSONEncodeError(
                    &#34;Output encoding %s is not sufficient to encode JSON&#34; % cdk.name
                )

        # Do the JSON encoding!
        self._do_encode(obj, state)
        if not self.options.encode_compactly:
            state.append(&#34;\n&#34;)
        unitxt = state.combine()

        # Do the final Unicode encoding
        if encoding is None:
            output = unitxt
        else:
            try:
                output, nchars = cdk.encode(unitxt)
            except UnicodeEncodeError as err:
                # Re-raise as a JSONDecodeError
                newerr = JSONEncodeError(&#34;a Unicode encoding error occurred&#34;)
                raise newerr from err
        return output

    def _do_encode(self, obj, state):
        &#34;&#34;&#34;Internal encode function.&#34;&#34;&#34;
        obj_classification = self._classify_for_encoding(obj)

        if self.has_hook(&#34;encode_value&#34;):
            orig_obj = obj
            try:
                obj = self.call_hook(&#34;encode_value&#34;, obj)
            except JSONSkipHook:
                pass

            if obj is not orig_obj:
                prev_cls = obj_classification
                obj_classification = self._classify_for_encoding(obj)
                if obj_classification != prev_cls:
                    # Got a different type of object, re-encode again
                    self._do_encode(obj, state)
                    return

        if hasattr(obj, &#34;json_equivalent&#34;):
            success = self.encode_equivalent(obj, state)
            if success:
                return

        if obj_classification == &#34;null&#34;:
            self.encode_null(state)
        elif obj_classification == &#34;undefined&#34;:
            if not self.options.is_forbid_undefined_values:
                self.encode_undefined(state)
            else:
                raise JSONEncodeError(&#39;strict JSON does not permit &#34;undefined&#34; values&#39;)
        elif obj_classification == &#34;bool&#34;:
            self.encode_boolean(obj, state)
        elif obj_classification == &#34;number&#34;:
            try:
                self.encode_number(obj, state)
            except JSONEncodeError as err1:
                # Bad number, probably a complex with non-zero imaginary part.
                # Let the default encoders take a shot at encoding.
                try:
                    self.try_encode_default(obj, state)
                except Exception as err2:
                    # Default handlers couldn&#39;t deal with it, re-raise original exception.
                    raise err1
        elif obj_classification == &#34;string&#34;:
            self.encode_string(obj, state)
        elif obj_classification == &#34;enum&#34;:  # Python 3.4 enum.Enum
            self.encode_enum(obj, state)
        elif obj_classification == &#34;datetime&#34;:  # Python datetime.datetime
            self.encode_datetime(obj, state)
        elif obj_classification == &#34;date&#34;:  # Python datetime.date
            self.encode_date(obj, state)
        elif obj_classification == &#34;time&#34;:  # Python datetime.time
            self.encode_time(obj, state)
        elif obj_classification == &#34;timedelta&#34;:  # Python datetime.time
            self.encode_timedelta(obj, state)
        else:
            # Anything left is probably composite, or an unconvertable type.
            self.encode_composite(obj, state)

    def encode_enum(self, val, state):
        &#34;&#34;&#34;Encode a Python Enum value into JSON.&#34;&#34;&#34;
        eas = self.options.encode_enum_as
        if eas == &#34;qname&#34;:
            self.encode_string(str(val), state)
        elif eas == &#34;value&#34;:
            self._do_encode(val.value, state)
        else:  # eas == &#39;name&#39;
            self.encode_string(val.name, state)

    def encode_date(self, dt, state):
        fmt = self.options.date_format
        if not fmt or fmt == &#34;iso&#34;:
            fmt = &#34;%Y-%m-%d&#34;
        self.encode_string(dt.strftime(fmt), state)

    def encode_datetime(self, dt, state):
        fmt = self.options.datetime_format
        is_iso = not fmt or fmt == &#34;iso&#34;
        if is_iso:
            if dt.microsecond == 0:
                fmt = &#34;%Y-%m-%dT%H:%M:%S%z&#34;
            else:
                fmt = &#34;%Y-%m-%dT%H:%M:%S.%f%z&#34;
        s = dt.strftime(fmt)
        if is_iso and s.endswith(&#34;-00:00&#34;) or s.endswith(&#34;+00:00&#34;):
            s = s[:-6] + &#34;Z&#34;  # Change UTC to use &#39;Z&#39; notation
        self.encode_string(s, state)

    def encode_time(self, t, state):
        fmt = self.options.datetime_format
        is_iso = not fmt or fmt == &#34;iso&#34;
        if is_iso:
            if t.microsecond == 0:
                fmt = &#34;T%H:%M:%S%z&#34;
            else:
                fmt = &#34;T%H:%M:%S.%f%z&#34;
        s = t.strftime(fmt)
        if is_iso and s.endswith(&#34;-00:00&#34;) or s.endswith(&#34;+00:00&#34;):
            s = s[:-6] + &#34;Z&#34;  # Change UTC to use &#39;Z&#39; notation
        self.encode_string(s, state)

    def encode_timedelta(self, td, state):
        fmt = self.options.timedelta_format
        if not fmt or fmt == &#34;iso&#34;:
            s = helpers.format_timedelta_iso(td)
        elif fmt == &#34;hms&#34;:
            s = str(td)
        else:
            raise ValueError(&#34;Unknown timedelta_format %r&#34; % fmt)
        self.encode_string(s, state)

    def encode_composite(self, obj, state, obj_classification=None):
        &#34;&#34;&#34;Encodes just composite objects: dictionaries, lists, or sequences.

        Basically handles any python type for which iter() can create
        an iterator object.

        This method is not intended to be called directly.  Use the
        encode() method instead.

        &#34;&#34;&#34;
        import sys

        if not obj_classification:
            obj_classification = self._classify_for_encoding(obj)

        # Convert namedtuples to dictionaries
        if obj_classification == &#34;namedtuple&#34;:
            obj = obj._asdict()
            obj_classification = &#34;dict&#34;

        # Convert &#39;unsigned byte&#39; memory views into plain bytes
        if obj_classification == &#34;memoryview&#34; and obj.format == &#34;B&#34;:
            obj = obj.tobytes()
            obj_classification = &#34;bytes&#34;

        # Run hooks
        hook_name = None
        if obj_classification == &#34;dict&#34;:
            hook_name = &#34;encode_dict&#34;
        elif obj_classification == &#34;sequence&#34;:
            hook_name = &#34;encode_sequence&#34;
        elif obj_classification == &#34;bytes&#34;:
            hook_name = &#34;encode_bytes&#34;

        if self.has_hook(hook_name):
            try:
                new_obj = self.call_hook(hook_name, obj)
            except JSONSkipHook:
                pass
            else:
                if new_obj is not obj:
                    obj = new_obj
                    prev_cls = obj_classification
                    obj_classification = self._classify_for_encoding(obj)
                    if obj_classification != prev_cls:
                        # Transformed to a different kind of object, call
                        # back to the general encode() method.
                        self._do_encode(obj, state)
                        return
                    # Else, fall through

        # At his point we have decided to do with an object or an array
        isdict = obj_classification == &#34;dict&#34;

        # Get iterator
        it = None
        if isdict and hasattr(obj, &#34;iterkeys&#34;):
            try:
                it = iter(obj.keys())
            except AttributeError:
                pass
        else:
            try:
                it = iter(obj)
            except TypeError:
                pass

        # Convert each member to JSON
        if it is not None:
            # Try to get length, but don&#39;t fail if we can&#39;t
            try:
                numitems = len(obj)
            except TypeError:
                numitems = 0

            # Output the opening bracket or brace
            compactly = self.options.encode_compactly
            if not compactly:
                indent0 = self.options.indentation_for_level(state.nest_level)
                indent = self.options.indentation_for_level(state.nest_level + 1)

            spaces_after_opener = &#34;&#34;
            if isdict:
                opener = &#34;{&#34;
                closer = &#34;}&#34;
                if compactly:
                    dictcolon = &#34;:&#34;
                else:
                    dictcolon = &#34; : &#34;
            else:
                opener = &#34;[&#34;
                closer = &#34;]&#34;
            if not compactly:
                # opener = opener + &#39; &#39;
                spaces_after_opener = self.options.spaces_to_next_indent_level(
                    subtract=len(opener)
                )

            state.append(opener)
            state.append(spaces_after_opener)

            # Now iterate through all the items and collect their representations
            parts = []  # Collects each of the members
            part_keys = []  # For dictionary key sorting, tuples (key,index)

            try:  # while not StopIteration
                part_idx = 0
                while True:
                    obj2 = next(it)
                    part_idx += 1  # Note, will start counting at 1
                    if obj2 is obj:
                        raise JSONEncodeError(
                            &#34;trying to encode an infinite sequence&#34;, obj
                        )
                    if isdict:
                        obj3 = obj[obj2]
                        # Dictionary key is in obj2 and value in obj3.

                        # Let any hooks transform the key.
                        if self.has_hook(&#34;encode_value&#34;):
                            try:
                                newobj = self.call_hook(&#34;encode_value&#34;, obj2)
                            except JSONSkipHook:
                                pass
                            else:
                                obj2 = newobj
                        if self.has_hook(&#34;encode_dict_key&#34;):
                            try:
                                newkey = self.call_hook(&#34;encode_dict_key&#34;, obj2)
                            except JSONSkipHook:
                                pass
                            else:
                                obj2 = newkey

                        # Check JSON restrictions on key types
                        if not helpers.isstringtype(obj2):
                            if helpers.isnumbertype(obj2):
                                if not self.options.is_allow_nonstring_keys:
                                    raise JSONEncodeError(
                                        &#34;object properties (dictionary keys) must be strings in strict JSON&#34;,
                                        obj2,
                                    )
                            else:
                                raise JSONEncodeError(
                                    &#34;object properties (dictionary keys) can only be strings or numbers in ECMAScript&#34;,
                                    obj2,
                                )
                        part_keys.append((obj2, part_idx - 1))

                    # Encode this item in the sequence and put into item_chunks
                    substate = state.make_substate()
                    self._do_encode(obj2, substate)
                    if isdict:
                        substate.append(dictcolon)
                        substate2 = substate.make_substate()
                        self._do_encode(obj3, substate2)
                        substate.join_substate(substate2)
                    parts.append(substate)
                # Next item iteration
            except StopIteration:
                pass

            # Sort dictionary keys
            if isdict:
                srt = self.options.sort_keys
                if srt == SORT_PRESERVE:
                    if _OrderedDict and isinstance(obj, _OrderedDict):
                        srt = SORT_NONE  # Will keep order
                    else:
                        srt = SORT_SMART

                if not srt or srt in (SORT_NONE, SORT_PRESERVE):
                    srt = None
                elif callable(srt):
                    part_keys.sort(key=(lambda t: (srt(t[0]), t[0])))
                elif srt == SORT_SMART:
                    part_keys.sort(key=(lambda t: (smart_sort_transform(t[0]), t[0])))
                elif srt == SORT_ALPHA_CI:
                    part_keys.sort(key=(lambda t: (str(t[0]).upper(), t[0])))
                elif srt or srt == SORT_ALPHA:
                    part_keys.sort(key=(lambda t: str(t[0])))
                # Now make parts match the new sort order
                if srt is not None:
                    parts = [parts[pk[1]] for pk in part_keys]

            if compactly:
                sep = &#34;,&#34;
            elif len(parts) &lt;= self.options.max_items_per_line:
                sep = &#34;, &#34;
            else:
                # state.append(spaces_after_opener)
                state.append(&#34;\n&#34; + indent)
                sep = &#34;,\n&#34; + indent

            for pnum, substate in enumerate(parts):
                if pnum &gt; 0:
                    state.append(sep)
                state.join_substate(substate)

            if not compactly:
                if numitems &gt; self.options.max_items_per_line:
                    state.append(&#34;\n&#34; + indent0)
                else:
                    state.append(&#34; &#34;)
            state.append(closer)  # final &#39;}&#39; or &#39;]&#39;
        else:  # Can&#39;t create an iterator for the object
            self.try_encode_default(obj, state)

    def encode_equivalent(self, obj, state):
        &#34;&#34;&#34;This method is used to encode user-defined class objects.

        The object being encoded should have a json_equivalent()
        method defined which returns another equivalent object which
        is easily JSON-encoded.  If the object in question has no
        json_equivalent() method available then None is returned
        instead of a string so that the encoding will attempt the next
        strategy.

        If a caller wishes to disable the calling of json_equivalent()
        methods, then subclass this class and override this method
        to just return None.

        &#34;&#34;&#34;
        if hasattr(obj, &#34;json_equivalent&#34;) and callable(
            getattr(obj, &#34;json_equivalent&#34;)
        ):
            obj2 = obj.json_equivalent()
            if obj2 is obj:
                # Try to prevent careless infinite recursion
                raise JSONEncodeError(
                    &#34;object has a json_equivalent() method that returns itself&#34;, obj
                )
            self._do_encode(obj2, state)
            return True
        else:
            return False

    def try_encode_default(self, obj, state):
        orig_obj = obj
        if self.has_hook(&#34;encode_default&#34;):
            try:
                obj = self.call_hook(&#34;encode_default&#34;, obj)
            except JSONSkipHook:
                pass
            else:
                if obj is not orig_obj:
                    # Hook made a transformation, re-encode it
                    return self._do_encode(obj, state)

        # End of the road.
        raise JSONEncodeError(&#34;can not encode object into a JSON representation&#34;, obj)


# ------------------------------


def encode(obj, encoding=None, **kwargs):
    r&#34;&#34;&#34;Encodes a Python object into a JSON-encoded string.

    * &#39;strict&#39;    (Boolean, default False)

        If &#39;strict&#39; is set to True, then only strictly-conforming JSON
        output will be produced.  Note that this means that some types
        of values may not be convertable and will result in a
        JSONEncodeError exception.

    * &#39;compactly&#39;    (Boolean, default True)

        If &#39;compactly&#39; is set to True, then the resulting string will
        have all extraneous white space removed; if False then the
        string will be &#34;pretty printed&#34; with whitespace and
        indentation added to make it more readable.

    * &#39;encode_namedtuple_as_object&#39;  (Boolean or callable, default True)

        If True, then objects of type namedtuple, or subclasses of
        &#39;tuple&#39; that have an _asdict() method, will be encoded as an
        object rather than an array.
        If can also be a predicate function that takes a namedtuple
        object as an argument and returns True or False.

    * &#39;indent_amount&#39;   (Integer, default 2)

        The number of spaces to output for each indentation level.
        If &#39;compactly&#39; is True then indentation is ignored.

    * &#39;indent_limit&#39;    (Integer or None, default None)

        If not None, then this is the maximum limit of indentation
        levels, after which further indentation spaces are not
        inserted.  If None, then there is no limit.

    CONCERNING CHARACTER ENCODING:

    The &#39;encoding&#39; argument should be one of:

        * None - The return will be a Unicode string.
        * encoding_name - A string which is the name of a known
              encoding, such as &#39;UTF-8&#39; or &#39;ascii&#39;.
        * codec - A CodecInfo object, such as as found by codecs.lookup().
              This allows you to use a custom codec as well as those
              built into Python.

    If an encoding is given (either by name or by codec), then the
    returned value will be a byte array (Python 3), or a &#39;str&#39; string
    (Python 2); which represents the raw set of bytes.  Otherwise,
    if encoding is None, then the returned value will be a Unicode
    string.

    The &#39;escape_unicode&#39; argument is used to determine which characters
    in string literals must be \u escaped.  Should be one of:

        * True  -- All non-ASCII characters are always \u escaped.
        * False -- Try to insert actual Unicode characters if possible.
        * function -- A user-supplied function that accepts a single
             unicode character and returns True or False; where True
             means to \u escape that character.

    Regardless of escape_unicode, certain characters will always be
    \u escaped. Additionaly any characters not in the output encoding
    repertoire for the encoding codec will be \u escaped as well.

    &#34;&#34;&#34;
    # Do the JSON encoding
    j = JSON(**kwargs)
    output = j.encode(obj, encoding)
    return output


def decode(txt, encoding=None, **kwargs):
    &#34;&#34;&#34;Decodes a JSON-encoded string into a Python object.

    == Optional arguments ==

    * &#39;encoding&#39;  (string, default None)

       This argument provides a hint regarding the character encoding
       that the input text is assumed to be in (if it is not already a
       unicode string type).

       If set to None then autodetection of the encoding is attempted
       (see discussion above). Otherwise this argument should be the
       name of a registered codec (see the standard &#39;codecs&#39; module).

    * &#39;strict&#39;    (Boolean, default False)

        If &#39;strict&#39; is set to True, then those strings that are not
        entirely strictly conforming to JSON will result in a
        JSONDecodeError exception.

    * &#39;return_errors&#39;    (Boolean, default False)

        Controls the return value from this function. If False, then
        only the Python equivalent object is returned on success, or
        an error will be raised as an exception.

        If True then a 2-tuple is returned: (object, error_list). The
        error_list will be an empty list [] if the decoding was
        successful, otherwise it will be a list of all the errors
        encountered.  Note that it is possible for an object to be
        returned even if errors were encountered.

    * &#39;return_stats&#39;    (Boolean, default False)

        Controls whether statistics about the decoded JSON document
        are returns (and instance of decode_statistics).

        If True, then the stats object will be added to the end of the
        tuple returned.  If return_errors is also set then a 3-tuple
        is returned, otherwise a 2-tuple is returned.

    * &#39;write_errors&#39;    (Boolean OR File-like object, default False)

        Controls what to do with errors.

        - If False, then the first decoding error is raised as an exception.
        - If True, then errors will be printed out to sys.stderr.
        - If a File-like object, then errors will be printed to that file.

        The write_errors and return_errors arguments can be set
        independently.

    * &#39;filename_for_errors&#39;   (string or None)

        Provides a filename to be used when writting error messages.

    * &#39;allow_xxx&#39;, &#39;warn_xxx&#39;, and &#39;forbid_xxx&#39;    (Booleans)

        These arguments allow for fine-adjustments to be made to the
        &#39;strict&#39; argument, by allowing or forbidding specific
        syntaxes.

        There are many of these arguments, named by replacing the
        &#34;xxx&#34; with any number of possible behavior names (See the JSON
        class for more details).

        Each of these will allow (or forbid) the specific behavior,
        after the evaluation of the &#39;strict&#39; argument.  For example,
        if strict=True then by also passing &#39;allow_comments=True&#39; then
        comments will be allowed.  If strict=False then
        forbid_comments=True will allow everything except comments.

    Unicode decoding:
    -----------------
    The input string can be either a python string or a python unicode
    string (or a byte array in Python 3).  If it is already a unicode
    string, then it is assumed that no character set decoding is
    required.

    However, if you pass in a non-Unicode text string (a Python 2
    &#39;str&#39; type or a Python 3 &#39;bytes&#39; or &#39;bytearray&#39;) then an attempt
    will be made to auto-detect and decode the character encoding.
    This will be successful if the input was encoded in any of UTF-8,
    UTF-16 (BE or LE), or UTF-32 (BE or LE), and of course plain ASCII
    works too.

    Note though that if you know the character encoding, then you
    should convert to a unicode string yourself, or pass it the name
    of the &#39;encoding&#39; to avoid the guessing made by the auto
    detection, as with

        python_object = demjson.decode( input_bytes, encoding=&#39;utf8&#39; )

    Callback hooks:
    ---------------
    You may supply callback hooks by using the hook name as the
    named argument, such as:
        decode_float=decimal.Decimal

    See the hooks documentation on the JSON.set_hook() method.

    &#34;&#34;&#34;
    import sys

    # Initialize the JSON object
    return_errors = False
    return_stats = False
    write_errors = False
    filename_for_errors = None
    write_stats = False

    kwargs = kwargs.copy()

    todel = []
    for kw, val in list(kwargs.items()):
        if kw == &#34;return_errors&#34;:
            return_errors = bool(val)
            todel.append(kw)
        elif kw == &#34;return_stats&#34;:
            return_stats = bool(val)
            todel.append(kw)
        elif kw == &#34;write_errors&#34;:
            write_errors = val
            todel.append(kw)
        elif kw == &#34;filename_for_errors&#34;:
            filename_for_errors = val
            todel.append(kw)
        elif kw == &#34;write_stats&#34;:
            write_stats = val
            todel.append(kw)
    # next keyword argument
    for kw in todel:
        del kwargs[kw]

    j = JSON(**kwargs)

    # Now do the actual JSON decoding
    result = j.decode(
        txt,
        encoding=encoding,
        return_errors=(return_errors or write_errors),
        return_stats=(return_stats or write_stats),
    )

    if write_errors:
        import sys

        if write_errors is True:
            write_errors = sys.stderr
        for err in result.errors:
            write_errors.write(
                err.pretty_description(filename=filename_for_errors) + &#34;\n&#34;
            )

    if write_stats:
        import sys

        if write_stats is True:
            write_stats = sys.stderr
        if result.stats:
            write_stats.write(&#34;%s----- Begin JSON statistics\n&#34; % filename_for_errors)
            write_stats.write(result.stats.pretty_description(prefix=&#34;   | &#34;))
            write_stats.write(&#34;%s----- End of JSON statistics\n&#34; % filename_for_errors)
    return result


def encode_to_file(filename, obj, encoding=&#34;utf-8&#34;, overwrite=False, **kwargs):
    &#34;&#34;&#34;Encodes a Python object into JSON and writes into the given file.

    If no encoding is given, then UTF-8 will be used.

    See the encode() function for a description of other possible options.

    If the file already exists and the &#39;overwrite&#39; option is not set
    to True, then the existing file will not be overwritten.  (Note,
    there is a subtle race condition in the check so there are
    possible conditions in which a file may be overwritten)

    &#34;&#34;&#34;
    import os, errno

    if not encoding:
        encoding = &#34;utf-8&#34;

    if not isinstance(filename, str) or not filename:
        raise TypeError(&#34;Expected a file name&#34;)

    if not overwrite and os.path.exists(filename):
        raise IOError(errno.EEXIST, &#34;File exists: %r&#34; % filename)

    jsondata = encode(obj, encoding=encoding, **kwargs)

    try:
        fp = open(filename, &#34;wb&#34;)
    except Exception:
        raise
    else:
        try:
            fp.write(jsondata)
        finally:
            fp.close()


def decode_file(filename, encoding=None, **kwargs):
    &#34;&#34;&#34;Decodes JSON found in the given file.

    See the decode() function for a description of other possible options.

    &#34;&#34;&#34;
    if isinstance(filename, str):
        try:
            fp = open(filename, &#34;rb&#34;)
        except Exception:
            raise
        else:
            try:
                jsondata = fp.read()
            finally:
                fp.close()
    else:
        raise TypeError(&#34;Expected a file name&#34;)
    return decode(jsondata, encoding=encoding, **kwargs)


# ======================================================================


class jsonlint(object):
    &#34;&#34;&#34;This class contains most of the logic for the &#34;jsonlint&#34; command.

    You generally create an instance of this class, to defined the
    program&#39;s environment, and then call the main() method.  A simple
    wrapper to turn this into a script might be:

        import sys, demjson
        if __name__ == &#39;__main__&#39;:
            lint = demjson.jsonlint( sys.argv[0] )
            return lint.main( sys.argv[1:] )

    &#34;&#34;&#34;

    _jsonlint_usage = r&#34;&#34;&#34;Usage: %(program_name)s [&lt;options&gt; ...] [--] inputfile.json ...

With no input filename, or &#34;-&#34;, it will read from standard input.

The return status will be 0 if the file is conforming JSON (per the
RFC 7159 specification), or non-zero otherwise.

GENERAL OPTIONS:

 -v | --verbose    Show details of lint checking
 -q | --quiet      Don&#39;t show any output (except for reformatting)

STRICTNESS OPTIONS (WARNINGS AND ERRORS):

 -W | --tolerant   Be tolerant, but warn about non-conformance (default)
 -s | --strict     Be strict in what is considered conforming JSON
 -S | --nonstrict  Be tolerant in what is considered conforming JSON

 --allow=...      -\
 --warn=...         |-- These options let you pick specific behaviors.
 --forbid=...     -/      Use --help-behaviors for more

STATISTICS OPTIONS:

 --stats       Show statistics about JSON document

REFORMATTING OPTIONS:

 -f | --format     Reformat the JSON text (if conforming) to stdout
 -F | --format-compactly
        Reformat the JSON simlar to -f, but do so compactly by
        removing all unnecessary whitespace

 -o filename | --output filename
        The filename to which reformatted JSON is to be written.
        Without this option the standard output is used.

 --[no-]keep-format   Try to preserve numeric radix, e.g., hex, octal, etc.
 --html-safe          Escape characters that are not safe to embed in HTML/XML.

 --sort &lt;kind&gt;     How to sort object/dictionary keys, &lt;kind&gt; is one of:
%(sort_options_help)s

 --indent tabs | &lt;nnn&gt;   Number of spaces to use per indentation level,
                         or use tab characters if &#34;tabs&#34; given.

UNICODE OPTIONS:

 -e codec | --encoding=codec     Set both input and output encodings
 --input-encoding=codec          Set the input encoding
 --output-encoding=codec         Set the output encoding

    These options set the character encoding codec (e.g., &#34;ascii&#34;,
    &#34;utf-8&#34;, &#34;utf-16&#34;).  The -e will set both the input and output
    encodings to the same thing.  The output encoding is used when
    reformatting with the -f or -F options.

    Unless set, the input encoding is guessed and the output
    encoding will be &#34;utf-8&#34;.

OTHER OPTIONS:

 --recursion-limit=nnn     Set the Python recursion limit to number
 --leading-zero-radix=8|10 The radix to use for numbers with leading
                           zeros. 8=octal, 10=decimal.

REFORMATTING / PRETTY-PRINTING:

    When reformatting JSON with -f or -F, output is only produced if
    the input passed validation.  By default the reformatted JSON will
    be written to standard output, unless the -o option was given.

    The default output codec is UTF-8, unless an encoding option is
    provided.  Any Unicode characters will be output as literal
    characters if the encoding permits, otherwise they will be
    \u-escaped.  You can use &#34;--output-encoding ascii&#34; to force all
    Unicode characters to be escaped.

MORE INFORMATION:

    Use &#39;%(program_name)s --version [-v]&#39; to see versioning information.
    Use &#39;%(program_name)s --copyright&#39; to see author and copyright details.
    Use &#39;%(program_name)s [-W|-s|-S] --help-behaviors&#39; for help on specific checks.

    %(program_name)s is distributed as part of the &#34;demjson&#34; Python module.
    See %(homepage)s
&#34;&#34;&#34;
    SUCCESS_FAIL = &#34;E&#34;
    SUCCESS_WARNING = &#34;W&#34;
    SUCCESS_OK = &#34;OK&#34;

    def __init__(self, program_name=&#34;jsonlint&#34;, stdin=None, stdout=None, stderr=None):
        &#34;&#34;&#34;Create an instance of a &#34;jsonlint&#34; program.

        You can optionally pass options to define the program&#39;s environment:

          * program_name  - the name of the program, usually sys.argv[0]
          * stdin   - the file object to use for input, default sys.stdin
          * stdout  - the file object to use for outut, default sys.stdout
          * stderr  - the file object to use for error output, default sys.stderr

        After creating an instance, you typically call the main() method.

        &#34;&#34;&#34;
        import os, sys

        self.program_path = program_name
        self.program_name = os.path.basename(program_name)
        if stdin:
            self.stdin = stdin
        else:
            self.stdin = sys.stdin

        if stdout:
            self.stdout = stdout
        else:
            self.stdout = sys.stdout

        if stderr:
            self.stderr = stderr
        else:
            self.stderr = sys.stderr

    @property
    def usage(self):
        &#34;&#34;&#34;A multi-line string containing the program usage instructions.&#34;&#34;&#34;
        sorthelp = &#34;\n&#34;.join(
            [
                &#34;          %12s - %s&#34; % (sm, sd)
                for sm, sd in sorted(sorting_methods.items())
                if sm != SORT_NONE
            ]
        )
        return self._jsonlint_usage % {
            &#34;program_name&#34;: self.program_name,
            &#34;homepage&#34;: __homepage__,
            &#34;sort_options_help&#34;: sorthelp,
        }

    def _lintcheck_data(
        self,
        jsondata,
        verbose_fp=None,
        reformat=False,
        show_stats=False,
        input_encoding=None,
        output_encoding=None,
        escape_unicode=True,
        pfx=&#34;&#34;,
        jsonopts=None,
    ):
        global decode, encode
        success = self.SUCCESS_FAIL
        reformatted = None
        if show_stats:
            stats_fp = verbose_fp
        else:
            stats_fp = None
        try:
            results = decode(
                jsondata,
                encoding=input_encoding,
                return_errors=True,
                return_stats=True,
                write_errors=verbose_fp,
                write_stats=stats_fp,
                filename_for_errors=pfx,
                json_options=jsonopts,
            )
        except JSONError as err:
            success = self.SUCCESS_FAIL
            if verbose_fp:
                verbose_fp.write(&#34;%s%s\n&#34; % (pfx, err.pretty_description()))
        except Exception as err:
            success = self.SUCCESS_FAIL
            if verbose_fp:
                verbose_fp.write(&#34;%s%s\n&#34; % (pfx, str(err)))
        else:
            errors = [
                err for err in results.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)
            ]
            warnings = [err for err in results.errors if err.severity in (&#34;warning&#34;,)]
            if errors:
                success = self.SUCCESS_FAIL
            elif warnings:
                success = self.SUCCESS_WARNING
            else:
                success = self.SUCCESS_OK

            if reformat:
                encopts = jsonopts.copy()
                encopts.strictness = STRICTNESS_TOLERANT
                if reformat == &#34;compactly&#34;:
                    encopts.encode_compactly = True
                else:
                    encopts.encode_compactly = False

                reformatted = encode(
                    results.object, encoding=output_encoding, json_options=encopts
                )

        return (success, reformatted)

    def _lintcheck(
        self,
        filename,
        output_filename,
        verbose=False,
        reformat=False,
        show_stats=False,
        input_encoding=None,
        output_encoding=None,
        escape_unicode=True,
        jsonopts=None,
    ):
        import sys

        verbose_fp = None

        if not filename or filename == &#34;-&#34;:
            pfx = &#34;&lt;stdin&gt;: &#34;
            jsondata = self.stdin.read()
            if verbose:
                verbose_fp = self.stderr
        else:
            pfx = &#34;%s: &#34; % filename
            try:
                fp = open(filename, &#34;rb&#34;)
                jsondata = fp.read()
                fp.close()
            except IOError as err:
                self.stderr.write(&#34;%s: %s\n&#34; % (pfx, str(err)))
                return self.SUCCESS_FAIL
            if verbose:
                verbose_fp = self.stdout

        success, reformatted = self._lintcheck_data(
            jsondata,
            verbose_fp=verbose_fp,
            reformat=reformat,
            show_stats=show_stats,
            input_encoding=input_encoding,
            output_encoding=output_encoding,
            pfx=pfx,
            jsonopts=jsonopts,
        )

        if success != self.SUCCESS_FAIL and reformat:
            if output_filename:
                try:
                    fp = open(output_filename, &#34;wb&#34;)
                    fp.write(reformatted)
                except IOError as err:
                    self.stderr.write(&#34;%s: %s\n&#34; % (pfx, str(err)))
                    success = False
            else:
                if hasattr(
                    sys.stdout, &#34;buffer&#34;
                ):  # To write binary data rather than strings
                    self.stdout.buffer.write(reformatted)
                else:
                    self.stdout.write(reformatted)
        elif success == self.SUCCESS_OK and verbose_fp:
            verbose_fp.write(&#34;%sok\n&#34; % pfx)
        elif success == self.SUCCESS_WARNING and verbose_fp:
            verbose_fp.write(&#34;%sok, with warnings\n&#34; % pfx)
        elif verbose_fp:
            verbose_fp.write(&#34;%shas errors\n&#34; % pfx)

        return success

    def main(self, argv):
        &#34;&#34;&#34;The main routine for program &#34;jsonlint&#34;.

        Should be called with sys.argv[1:] as its sole argument.

        Note sys.argv[0] which normally contains the program name
        should not be passed to main(); instead this class itself
        is initialized with sys.argv[0].

        Use &#34;--help&#34; for usage syntax, or consult the &#39;usage&#39; member.

        &#34;&#34;&#34;
        import sys, os, getopt, unicodedata

        recursion_limit = None
        success = True
        verbose = &#34;auto&#34;  # one of &#39;auto&#39;, True, or False
        reformat = False
        show_stats = False
        output_filename = None
        input_encoding = None
        output_encoding = &#34;utf-8&#34;

        kwoptions = {  # Will be used to initialize json_options
            &#34;sort_keys&#34;: SORT_SMART,
            &#34;strict&#34;: STRICTNESS_WARN,
            &#34;keep_format&#34;: True,
            &#34;decimal_context&#34;: 100,
        }

        try:
            opts, args = getopt.getopt(
                argv,
                &#34;vqfFe:o:sSW&#34;,
                [
                    &#34;verbose&#34;,
                    &#34;quiet&#34;,
                    &#34;format&#34;,
                    &#34;format-compactly&#34;,
                    &#34;stats&#34;,
                    &#34;output&#34;,
                    &#34;strict&#34;,
                    &#34;nonstrict&#34;,
                    &#34;warn&#34;,
                    &#34;html-safe&#34;,
                    &#34;xml-safe&#34;,
                    &#34;encoding=&#34;,
                    &#34;input-encoding=&#34;,
                    &#34;output-encoding=&#34;,
                    &#34;sort=&#34;,
                    &#34;recursion-limit=&#34;,
                    &#34;leading-zero-radix=&#34;,
                    &#34;keep-format&#34;,
                    &#34;no-keep-format&#34;,
                    &#34;indent=&#34;,
                    &#34;indent-amount=&#34;,
                    &#34;indent-limit=&#34;,
                    &#34;indent-tab-width=&#34;,
                    &#34;max-items-per-line=&#34;,
                    &#34;allow=&#34;,
                    &#34;warn=&#34;,
                    &#34;forbid=&#34;,
                    &#34;deny=&#34;,
                    &#34;help&#34;,
                    &#34;help-behaviors&#34;,
                    &#34;version&#34;,
                    &#34;copyright&#34;,
                ],
            )
        except getopt.GetoptError as err:
            self.stderr.write(
                &#39;Error: %s.  Use &#34;%s --help&#34; for usage information.\n&#39;
                % (err.msg, self.program_name)
            )
            return 1

        # Set verbose before looking at any other options
        for opt, val in opts:
            if opt in (&#34;-v&#34;, &#34;--verbose&#34;):
                verbose = True

        # Process all options
        for opt, val in opts:
            if opt in (&#34;-h&#34;, &#34;--help&#34;):
                self.stdout.write(self.usage)
                return 0
            elif opt == &#34;--help-behaviors&#34;:
                self.stdout.write(
                    &#34;&#34;&#34;
BEHAVIOR OPTIONS:

These set of options let you control which checks are to be performed.
They may be turned on or off by listing them as arguments to one of
the options --allow, --warn, or --forbid ; for example:

    %(program_name)s --allow comments,hex-numbers --forbid duplicate-keys

&#34;&#34;&#34;
                    % {&#34;program_name&#34;: self.program_name}
                )
                self.stdout.write(
                    &#34;The default shown is for %s mode\n\n&#34; % kwoptions[&#34;strict&#34;]
                )
                self.stdout.write(
                    &#34;%-7s %-25s %s\n&#34; % (&#34;Default&#34;, &#34;Behavior_name&#34;, &#34;Description&#34;)
                )
                self.stdout.write(&#34;-&#34; * 7 + &#34; &#34; + &#34;-&#34; * 25 + &#34; &#34; + &#34;-&#34; * 50 + &#34;\n&#34;)
                j = json_options(**kwoptions)
                for behavior in sorted(j.all_behaviors):
                    v = j.get_behavior(behavior)
                    desc = j.describe_behavior(behavior)
                    self.stdout.write(
                        &#34;%-7s %-25s %s\n&#34;
                        % (v.lower(), behavior.replace(&#34;_&#34;, &#34;-&#34;), desc)
                    )
                return 0
            elif opt == &#34;--version&#34;:
                self.stdout.write(
                    &#34;%s (%s) version %s (%s)\n&#34;
                    % (self.program_name, __name__, __version__, __date__)
                )
                if verbose == True:
                    self.stdout.write(&#34;demjson from %r\n&#34; % (__file__,))
                if verbose == True:
                    self.stdout.write(
                        &#34;Python version: %s\n&#34; % (sys.version.replace(&#34;\n&#34;, &#34; &#34;),)
                    )
                    self.stdout.write(&#34;This python implementation supports:\n&#34;)
                    self.stdout.write(&#34;  * Max unicode: U+%X\n&#34; % (sys.maxunicode,))
                    self.stdout.write(
                        &#34;  * Unicode version: %s\n&#34; % (unicodedata.unidata_version,)
                    )
                    self.stdout.write(
                        &#34;  * Floating-point significant digits: %d\n&#34;
                        % (float_sigdigits,)
                    )
                    self.stdout.write(
                        &#34;  * Floating-point max 10^exponent: %d\n&#34; % (float_maxexp,)
                    )
                    if str(0.0) == str(-0.0):
                        szero = &#34;No&#34;
                    else:
                        szero = &#34;Yes&#34;
                    self.stdout.write(
                        &#34;  * Floating-point has signed-zeros: %s\n&#34; % (szero,)
                    )
                    if decimal:
                        has_dec = &#34;Yes&#34;
                    else:
                        has_dec = &#34;No&#34;
                    self.stdout.write(
                        &#34;  * Decimal (bigfloat) support: %s\n&#34; % (has_dec,)
                    )
                return 0
            elif opt == &#34;--copyright&#34;:
                self.stdout.write(
                    &#39;%s is distributed as part of the &#34;demjson&#34; python package.\n&#39;
                    % (self.program_name,)
                )
                self.stdout.write(&#34;See %s\n\n\n&#34; % (__homepage__,))
                self.stdout.write(__credits__)
                return 0
            elif opt in (&#34;-v&#34;, &#34;--verbose&#34;):
                verbose = True
            elif opt in (&#34;-q&#34;, &#34;--quiet&#34;):
                verbose = False
            elif opt in (&#34;-s&#34;, &#34;--strict&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_STRICT
                kwoptions[&#34;keep_format&#34;] = False
            elif opt in (&#34;-S&#34;, &#34;--nonstrict&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_TOLERANT
            elif opt in (&#34;-W&#34;, &#34;--tolerant&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_WARN
            elif opt in (&#34;-f&#34;, &#34;--format&#34;):
                reformat = True
                kwoptions[&#34;encode_compactly&#34;] = False
            elif opt in (&#34;-F&#34;, &#34;--format-compactly&#34;):
                kwoptions[&#34;encode_compactly&#34;] = True
                reformat = &#34;compactly&#34;
            elif opt in (&#34;--stats&#34;,):
                show_stats = True
            elif opt in (&#34;-o&#34;, &#34;--output&#34;):
                output_filename = val
            elif opt in (&#34;-e&#34;, &#34;--encoding&#34;):
                input_encoding = val
                output_encoding = val
                escape_unicode = False
            elif opt in (&#34;--output-encoding&#34;):
                output_encoding = val
                escape_unicode = False
            elif opt in (&#34;--input-encoding&#34;):
                input_encoding = val
            elif opt in (&#34;--html-safe&#34;, &#34;--xml-safe&#34;):
                kwoptions[&#34;html_safe&#34;] = True
            elif opt in (&#34;--allow&#34;, &#34;--warn&#34;, &#34;--forbid&#34;):
                action = opt[2:]
                if action in kwoptions:
                    kwoptions[action] += &#34;,&#34; + val
                else:
                    kwoptions[action] = val
            elif opt in (&#34;--keep-format&#34;,):
                kwoptions[&#34;keep_format&#34;] = True
            elif opt in (&#34;--no-keep-format&#34;,):
                kwoptions[&#34;keep_format&#34;] = False
            elif opt == &#34;--leading-zero-radix&#34;:
                kwoptions[&#34;leading_zero_radix&#34;] = val
            elif opt in (&#34;--indent&#34;, &#34;--indent-amount&#34;):
                if val in (&#34;tab&#34;, &#34;tabs&#34;):
                    kwoptions[&#34;indent_amount&#34;] = 8
                    kwoptions[&#34;indent_tab_width&#34;] = 8
                else:
                    try:
                        kwoptions[&#34;indent_amount&#34;] = int(val)
                    except ValueError:
                        self.stderr.write(&#34;Indentation amount must be a number\n&#34;)
                        return 1
            elif opt == &#34;indent-tab-width&#34;:
                try:
                    kwoptions[&#34;indent_tab_width&#34;] = int(val)
                except ValueError:
                    self.stderr.write(&#34;Indentation tab width must be a number\n&#34;)
                    return 1
            elif opt == &#34;--max-items-per-line&#34;:
                try:
                    kwoptions[&#34;max_items_per_line&#34;] = int(val)
                except ValueError:
                    self.stderr.write(&#34;Max items per line must be a number\n&#34;)
                    return 1
            elif opt == &#34;--sort&#34;:
                val = val.lower()
                if val == &#34;alpha&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_ALPHA
                elif val == &#34;alpha_ci&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_ALPHA_CI
                elif val == &#34;preserve&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_PRESERVE
                else:
                    kwoptions[&#34;sort_keys&#34;] = SORT_SMART
            elif opt == &#34;--recursion-limit&#34;:
                try:
                    recursion_limit = int(val)
                except ValueError:
                    self.stderr.write(&#34;Recursion limit must be a number: %r\n&#34; % val)
                    return 1
                else:
                    max_limit = 100000
                    old_limit = sys.getrecursionlimit()
                    if recursion_limit &gt; max_limit:
                        self.stderr.write(
                            &#34;Recursion limit must be a number between %d and %d\n&#34;
                            % (old_limit, max_limit)
                        )
                        return 1
                    elif recursion_limit &gt; old_limit:
                        sys.setrecursionlimit(recursion_limit)
            else:
                self.stderr.write(&#34;Unknown option %r\n&#34; % opt)
                return 1

        # Make the JSON options
        kwoptions[&#34;decimal_context&#34;] = 100
        jsonopts = json_options(**kwoptions)

        # Now decode each file...
        if not args:
            args = [None]

        for fn in args:
            try:
                rc = self._lintcheck(
                    fn,
                    output_filename=output_filename,
                    verbose=verbose,
                    reformat=reformat,
                    show_stats=show_stats,
                    input_encoding=input_encoding,
                    output_encoding=output_encoding,
                    jsonopts=jsonopts,
                )
                if rc != self.SUCCESS_OK:
                    # Warnings or errors should result in failure.  If
                    # checking multiple files, do not change a
                    # previous error back to ok.
                    success = False
            except KeyboardInterrupt as err:
                sys.stderr.write(&#34;\njsonlint interrupted!\n&#34;)
                sys.exit(1)

        if not success:
            return 1
        return 0


# end file</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="demjson3.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>txt, encoding=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a JSON-encoded string into a Python object.</p>
<p>== Optional arguments ==</p>
<ul>
<li>'encoding'
(string, default None)</li>
</ul>
<p>This argument provides a hint regarding the character encoding
that the input text is assumed to be in (if it is not already a
unicode string type).</p>
<p>If set to None then autodetection of the encoding is attempted
(see discussion above). Otherwise this argument should be the
name of a registered codec (see the standard 'codecs' module).</p>
<ul>
<li>
<p>'strict'
(Boolean, default False)</p>
<p>If 'strict' is set to True, then those strings that are not
entirely strictly conforming to JSON will result in a
JSONDecodeError exception.</p>
</li>
<li>
<p>'return_errors'
(Boolean, default False)</p>
<p>Controls the return value from this function. If False, then
only the Python equivalent object is returned on success, or
an error will be raised as an exception.</p>
<p>If True then a 2-tuple is returned: (object, error_list). The
error_list will be an empty list [] if the decoding was
successful, otherwise it will be a list of all the errors
encountered.
Note that it is possible for an object to be
returned even if errors were encountered.</p>
</li>
<li>
<p>'return_stats'
(Boolean, default False)</p>
<p>Controls whether statistics about the decoded JSON document
are returns (and instance of decode_statistics).</p>
<p>If True, then the stats object will be added to the end of the
tuple returned.
If return_errors is also set then a 3-tuple
is returned, otherwise a 2-tuple is returned.</p>
</li>
<li>
<p>'write_errors'
(Boolean OR File-like object, default False)</p>
<p>Controls what to do with errors.</p>
<ul>
<li>If False, then the first decoding error is raised as an exception.</li>
<li>If True, then errors will be printed out to sys.stderr.</li>
<li>If a File-like object, then errors will be printed to that file.</li>
</ul>
<p>The write_errors and return_errors arguments can be set
independently.</p>
</li>
<li>
<p>'filename_for_errors'
(string or None)</p>
<p>Provides a filename to be used when writting error messages.</p>
</li>
<li>
<p>'allow_xxx', 'warn_xxx', and 'forbid_xxx'
(Booleans)</p>
<p>These arguments allow for fine-adjustments to be made to the
'strict' argument, by allowing or forbidding specific
syntaxes.</p>
<p>There are many of these arguments, named by replacing the
"xxx" with any number of possible behavior names (See the JSON
class for more details).</p>
<p>Each of these will allow (or forbid) the specific behavior,
after the evaluation of the 'strict' argument.
For example,
if strict=True then by also passing 'allow_comments=True' then
comments will be allowed.
If strict=False then
forbid_comments=True will allow everything except comments.</p>
</li>
</ul>
<h2 id="unicode-decoding">Unicode decoding:</h2>
<p>The input string can be either a python string or a python unicode
string (or a byte array in Python 3).
If it is already a unicode
string, then it is assumed that no character set decoding is
required.</p>
<p>However, if you pass in a non-Unicode text string (a Python 2
'str' type or a Python 3 'bytes' or 'bytearray') then an attempt
will be made to auto-detect and decode the character encoding.
This will be successful if the input was encoded in any of UTF-8,
UTF-16 (BE or LE), or UTF-32 (BE or LE), and of course plain ASCII
works too.</p>
<p>Note though that if you know the character encoding, then you
should convert to a unicode string yourself, or pass it the name
of the 'encoding' to avoid the guessing made by the auto
detection, as with</p>
<pre><code>python_object = demjson.decode( input_bytes, encoding='utf8' )
</code></pre>
<h2 id="callback-hooks">Callback hooks:</h2>
<p>You may supply callback hooks by using the hook name as the
named argument, such as:
decode_float=decimal.Decimal</p>
<p>See the hooks documentation on the JSON.set_hook() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(txt, encoding=None, **kwargs):
    &#34;&#34;&#34;Decodes a JSON-encoded string into a Python object.

    == Optional arguments ==

    * &#39;encoding&#39;  (string, default None)

       This argument provides a hint regarding the character encoding
       that the input text is assumed to be in (if it is not already a
       unicode string type).

       If set to None then autodetection of the encoding is attempted
       (see discussion above). Otherwise this argument should be the
       name of a registered codec (see the standard &#39;codecs&#39; module).

    * &#39;strict&#39;    (Boolean, default False)

        If &#39;strict&#39; is set to True, then those strings that are not
        entirely strictly conforming to JSON will result in a
        JSONDecodeError exception.

    * &#39;return_errors&#39;    (Boolean, default False)

        Controls the return value from this function. If False, then
        only the Python equivalent object is returned on success, or
        an error will be raised as an exception.

        If True then a 2-tuple is returned: (object, error_list). The
        error_list will be an empty list [] if the decoding was
        successful, otherwise it will be a list of all the errors
        encountered.  Note that it is possible for an object to be
        returned even if errors were encountered.

    * &#39;return_stats&#39;    (Boolean, default False)

        Controls whether statistics about the decoded JSON document
        are returns (and instance of decode_statistics).

        If True, then the stats object will be added to the end of the
        tuple returned.  If return_errors is also set then a 3-tuple
        is returned, otherwise a 2-tuple is returned.

    * &#39;write_errors&#39;    (Boolean OR File-like object, default False)

        Controls what to do with errors.

        - If False, then the first decoding error is raised as an exception.
        - If True, then errors will be printed out to sys.stderr.
        - If a File-like object, then errors will be printed to that file.

        The write_errors and return_errors arguments can be set
        independently.

    * &#39;filename_for_errors&#39;   (string or None)

        Provides a filename to be used when writting error messages.

    * &#39;allow_xxx&#39;, &#39;warn_xxx&#39;, and &#39;forbid_xxx&#39;    (Booleans)

        These arguments allow for fine-adjustments to be made to the
        &#39;strict&#39; argument, by allowing or forbidding specific
        syntaxes.

        There are many of these arguments, named by replacing the
        &#34;xxx&#34; with any number of possible behavior names (See the JSON
        class for more details).

        Each of these will allow (or forbid) the specific behavior,
        after the evaluation of the &#39;strict&#39; argument.  For example,
        if strict=True then by also passing &#39;allow_comments=True&#39; then
        comments will be allowed.  If strict=False then
        forbid_comments=True will allow everything except comments.

    Unicode decoding:
    -----------------
    The input string can be either a python string or a python unicode
    string (or a byte array in Python 3).  If it is already a unicode
    string, then it is assumed that no character set decoding is
    required.

    However, if you pass in a non-Unicode text string (a Python 2
    &#39;str&#39; type or a Python 3 &#39;bytes&#39; or &#39;bytearray&#39;) then an attempt
    will be made to auto-detect and decode the character encoding.
    This will be successful if the input was encoded in any of UTF-8,
    UTF-16 (BE or LE), or UTF-32 (BE or LE), and of course plain ASCII
    works too.

    Note though that if you know the character encoding, then you
    should convert to a unicode string yourself, or pass it the name
    of the &#39;encoding&#39; to avoid the guessing made by the auto
    detection, as with

        python_object = demjson.decode( input_bytes, encoding=&#39;utf8&#39; )

    Callback hooks:
    ---------------
    You may supply callback hooks by using the hook name as the
    named argument, such as:
        decode_float=decimal.Decimal

    See the hooks documentation on the JSON.set_hook() method.

    &#34;&#34;&#34;
    import sys

    # Initialize the JSON object
    return_errors = False
    return_stats = False
    write_errors = False
    filename_for_errors = None
    write_stats = False

    kwargs = kwargs.copy()

    todel = []
    for kw, val in list(kwargs.items()):
        if kw == &#34;return_errors&#34;:
            return_errors = bool(val)
            todel.append(kw)
        elif kw == &#34;return_stats&#34;:
            return_stats = bool(val)
            todel.append(kw)
        elif kw == &#34;write_errors&#34;:
            write_errors = val
            todel.append(kw)
        elif kw == &#34;filename_for_errors&#34;:
            filename_for_errors = val
            todel.append(kw)
        elif kw == &#34;write_stats&#34;:
            write_stats = val
            todel.append(kw)
    # next keyword argument
    for kw in todel:
        del kwargs[kw]

    j = JSON(**kwargs)

    # Now do the actual JSON decoding
    result = j.decode(
        txt,
        encoding=encoding,
        return_errors=(return_errors or write_errors),
        return_stats=(return_stats or write_stats),
    )

    if write_errors:
        import sys

        if write_errors is True:
            write_errors = sys.stderr
        for err in result.errors:
            write_errors.write(
                err.pretty_description(filename=filename_for_errors) + &#34;\n&#34;
            )

    if write_stats:
        import sys

        if write_stats is True:
            write_stats = sys.stderr
        if result.stats:
            write_stats.write(&#34;%s----- Begin JSON statistics\n&#34; % filename_for_errors)
            write_stats.write(result.stats.pretty_description(prefix=&#34;   | &#34;))
            write_stats.write(&#34;%s----- End of JSON statistics\n&#34; % filename_for_errors)
    return result</code></pre>
</details>
</dd>
<dt id="demjson3.decode_file"><code class="name flex">
<span>def <span class="ident">decode_file</span></span>(<span>filename, encoding=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes JSON found in the given file.</p>
<p>See the decode() function for a description of other possible options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_file(filename, encoding=None, **kwargs):
    &#34;&#34;&#34;Decodes JSON found in the given file.

    See the decode() function for a description of other possible options.

    &#34;&#34;&#34;
    if isinstance(filename, str):
        try:
            fp = open(filename, &#34;rb&#34;)
        except Exception:
            raise
        else:
            try:
                jsondata = fp.read()
            finally:
                fp.close()
    else:
        raise TypeError(&#34;Expected a file name&#34;)
    return decode(jsondata, encoding=encoding, **kwargs)</code></pre>
</details>
</dd>
<dt id="demjson3.determine_float_limits"><code class="name flex">
<span>def <span class="ident">determine_float_limits</span></span>(<span>number_type=builtins.float)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines the precision and range of the given float type.</p>
<p>The passed in 'number_type' argument should refer to the type of
floating-point number.
It should either be the built-in 'float',
or decimal context or constructor; i.e., one of:</p>
<pre><code># 1. FLOAT TYPE
determine_float_limits( float )

# 2. DEFAULT DECIMAL CONTEXT
determine_float_limits( decimal.Decimal )

# 3. CUSTOM DECIMAL CONTEXT
ctx = decimal.Context( prec=75 )
determine_float_limits( ctx )
</code></pre>
<p>Returns a named tuple with components:</p>
<pre><code> ( significant_digits,
   max_exponent,
   min_exponent )
</code></pre>
<h2 id="where">Where</h2>
<ul>
<li>
<p>significant_digits &ndash; maximum number of <em>decimal</em> digits
that can be represented without any loss of precision.
This is conservative, so if there are 16 1/2 digits, it
will return 16, not 17.</p>
</li>
<li>
<p>max_exponent &ndash; The maximum exponent (power of 10) that can
be represented before an overflow (or rounding to
infinity) occurs.</p>
</li>
<li>
<p>min_exponent &ndash; The minimum exponent (negative power of 10)
that can be represented before either an underflow
(rounding to zero) or a subnormal result (loss of
precision) occurs.
Note this is conservative, as
subnormal numbers are excluded.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_float_limits(number_type=float):
    &#34;&#34;&#34;Determines the precision and range of the given float type.

    The passed in &#39;number_type&#39; argument should refer to the type of
    floating-point number.  It should either be the built-in &#39;float&#39;,
    or decimal context or constructor; i.e., one of:

        # 1. FLOAT TYPE
        determine_float_limits( float )

        # 2. DEFAULT DECIMAL CONTEXT
        determine_float_limits( decimal.Decimal )

        # 3. CUSTOM DECIMAL CONTEXT
        ctx = decimal.Context( prec=75 )
        determine_float_limits( ctx )

    Returns a named tuple with components:

         ( significant_digits,
           max_exponent,
           min_exponent )

    Where:
        * significant_digits -- maximum number of *decimal* digits
             that can be represented without any loss of precision.
             This is conservative, so if there are 16 1/2 digits, it
             will return 16, not 17.

        * max_exponent -- The maximum exponent (power of 10) that can
             be represented before an overflow (or rounding to
             infinity) occurs.

        * min_exponent -- The minimum exponent (negative power of 10)
             that can be represented before either an underflow
             (rounding to zero) or a subnormal result (loss of
             precision) occurs.  Note this is conservative, as
             subnormal numbers are excluded.

    &#34;&#34;&#34;
    numeric_exceptions = (ValueError, decimal.Overflow, decimal.Underflow)

    if number_type == decimal.Decimal:
        number_type = decimal.DefaultContext

    if isinstance(number_type, decimal.Context):
        # Passed a decimal Context, extract the bound creator function.
        create_num = number_type.create_decimal
        decimal_ctx = decimal.localcontext(number_type)
        is_zero_or_subnormal = lambda n: n.is_zero() or n.is_subnormal()
    elif number_type == float:
        create_num = number_type
        decimal_ctx = _dummy_context_manager
        is_zero_or_subnormal = lambda n: n == 0
    else:
        raise TypeError(&#34;Expected a float type, e.g., float or decimal context&#34;)

    with decimal_ctx:
        zero = create_num(&#34;0.0&#34;)

        # Find signifianct digits by comparing floats of increasing
        # number of digits, differing in the last digit only, until
        # they numerically compare as being equal.
        sigdigits = None
        n = 0
        while True:
            n = n + 1
            pfx = &#34;0.&#34; + &#34;1&#34; * n
            a = create_num(pfx + &#34;0&#34;)
            for sfx in &#34;123456789&#34;:  # Check all possible last digits to
                # avoid any partial-decimal.
                b = create_num(pfx + sfx)
                if (a + zero) == (b + zero):
                    sigdigits = n
                    break
            if sigdigits:
                break

        # Find exponent limits.  First find order of magnitude and
        # then use a binary search to find the exact exponent.
        base = &#34;1.&#34; + &#34;1&#34; * (sigdigits - 1)
        base0 = &#34;1.&#34; + &#34;1&#34; * (sigdigits - 2)
        minexp, maxexp = None, None

        for expsign in (&#34;+&#34;, &#34;-&#34;):
            minv = 0
            maxv = 10
            # First find order of magnitude of exponent limit
            while True:
                try:
                    s = base + &#34;e&#34; + expsign + str(maxv)
                    s0 = base0 + &#34;e&#34; + expsign + str(maxv)
                    f = create_num(s) + zero
                    f0 = create_num(s0) + zero
                except numeric_exceptions:
                    f = None
                if (
                    not f
                    or not str(f)[0].isdigit()
                    or is_zero_or_subnormal(f)
                    or f == f0
                ):
                    break
                else:
                    minv = maxv
                    maxv = maxv * 10

            # Now do a binary search to find exact limit
            while True:
                if minv + 1 == maxv:
                    if expsign == &#34;+&#34;:
                        maxexp = minv
                    else:
                        minexp = minv
                    break
                elif maxv &lt; minv:
                    if expsign == &#34;+&#34;:
                        maxexp = None
                    else:
                        minexp = None
                    break
                m = (minv + maxv) // 2
                try:
                    s = base + &#34;e&#34; + expsign + str(m)
                    s0 = base0 + &#34;e&#34; + expsign + str(m)
                    f = create_num(s) + zero
                    f0 = create_num(s0) + zero
                except numeric_exceptions:
                    f = None
                else:
                    if not f or not str(f)[0].isdigit():
                        f = None
                    elif is_zero_or_subnormal(f) or f == f0:
                        f = None
                if not f:
                    # infinite
                    maxv = m
                else:
                    minv = m

    return _namedtuple(
        &#34;float_limits&#34;, [&#34;significant_digits&#34;, &#34;max_exponent&#34;, &#34;min_exponent&#34;]
    )(sigdigits, maxexp, -minexp)</code></pre>
</details>
</dd>
<dt id="demjson3.determine_float_precision"><code class="name flex">
<span>def <span class="ident">determine_float_precision</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_float_precision():
    v = determine_float_limits(float)
    return (v.significant_digits, v.max_exponent)</code></pre>
</details>
</dd>
<dt id="demjson3.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>obj, encoding=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a Python object into a JSON-encoded string.</p>
<ul>
<li>
<p>'strict'
(Boolean, default False)</p>
<p>If 'strict' is set to True, then only strictly-conforming JSON
output will be produced.
Note that this means that some types
of values may not be convertable and will result in a
JSONEncodeError exception.</p>
</li>
<li>
<p>'compactly'
(Boolean, default True)</p>
<p>If 'compactly' is set to True, then the resulting string will
have all extraneous white space removed; if False then the
string will be "pretty printed" with whitespace and
indentation added to make it more readable.</p>
</li>
<li>
<p>'encode_namedtuple_as_object'
(Boolean or callable, default True)</p>
<p>If True, then objects of type namedtuple, or subclasses of
'tuple' that have an _asdict() method, will be encoded as an
object rather than an array.
If can also be a predicate function that takes a namedtuple
object as an argument and returns True or False.</p>
</li>
<li>
<p>'indent_amount'
(Integer, default 2)</p>
<p>The number of spaces to output for each indentation level.
If 'compactly' is True then indentation is ignored.</p>
</li>
<li>
<p>'indent_limit'
(Integer or None, default None)</p>
<p>If not None, then this is the maximum limit of indentation
levels, after which further indentation spaces are not
inserted.
If None, then there is no limit.</p>
</li>
</ul>
<p>CONCERNING CHARACTER ENCODING:</p>
<p>The 'encoding' argument should be one of:</p>
<pre><code>* None - The return will be a Unicode string.
* encoding_name - A string which is the name of a known
      encoding, such as 'UTF-8' or 'ascii'.
* codec - A CodecInfo object, such as as found by codecs.lookup().
      This allows you to use a custom codec as well as those
      built into Python.
</code></pre>
<p>If an encoding is given (either by name or by codec), then the
returned value will be a byte array (Python 3), or a 'str' string
(Python 2); which represents the raw set of bytes.
Otherwise,
if encoding is None, then the returned value will be a Unicode
string.</p>
<p>The 'escape_unicode' argument is used to determine which characters
in string literals must be \u escaped.
Should be one of:</p>
<pre><code>* True  -- All non-ASCII characters are always \u escaped.
* False -- Try to insert actual Unicode characters if possible.
* function -- A user-supplied function that accepts a single
     unicode character and returns True or False; where True
     means to \u escape that character.
</code></pre>
<p>Regardless of escape_unicode, certain characters will always be
\u escaped. Additionaly any characters not in the output encoding
repertoire for the encoding codec will be \u escaped as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(obj, encoding=None, **kwargs):
    r&#34;&#34;&#34;Encodes a Python object into a JSON-encoded string.

    * &#39;strict&#39;    (Boolean, default False)

        If &#39;strict&#39; is set to True, then only strictly-conforming JSON
        output will be produced.  Note that this means that some types
        of values may not be convertable and will result in a
        JSONEncodeError exception.

    * &#39;compactly&#39;    (Boolean, default True)

        If &#39;compactly&#39; is set to True, then the resulting string will
        have all extraneous white space removed; if False then the
        string will be &#34;pretty printed&#34; with whitespace and
        indentation added to make it more readable.

    * &#39;encode_namedtuple_as_object&#39;  (Boolean or callable, default True)

        If True, then objects of type namedtuple, or subclasses of
        &#39;tuple&#39; that have an _asdict() method, will be encoded as an
        object rather than an array.
        If can also be a predicate function that takes a namedtuple
        object as an argument and returns True or False.

    * &#39;indent_amount&#39;   (Integer, default 2)

        The number of spaces to output for each indentation level.
        If &#39;compactly&#39; is True then indentation is ignored.

    * &#39;indent_limit&#39;    (Integer or None, default None)

        If not None, then this is the maximum limit of indentation
        levels, after which further indentation spaces are not
        inserted.  If None, then there is no limit.

    CONCERNING CHARACTER ENCODING:

    The &#39;encoding&#39; argument should be one of:

        * None - The return will be a Unicode string.
        * encoding_name - A string which is the name of a known
              encoding, such as &#39;UTF-8&#39; or &#39;ascii&#39;.
        * codec - A CodecInfo object, such as as found by codecs.lookup().
              This allows you to use a custom codec as well as those
              built into Python.

    If an encoding is given (either by name or by codec), then the
    returned value will be a byte array (Python 3), or a &#39;str&#39; string
    (Python 2); which represents the raw set of bytes.  Otherwise,
    if encoding is None, then the returned value will be a Unicode
    string.

    The &#39;escape_unicode&#39; argument is used to determine which characters
    in string literals must be \u escaped.  Should be one of:

        * True  -- All non-ASCII characters are always \u escaped.
        * False -- Try to insert actual Unicode characters if possible.
        * function -- A user-supplied function that accepts a single
             unicode character and returns True or False; where True
             means to \u escape that character.

    Regardless of escape_unicode, certain characters will always be
    \u escaped. Additionaly any characters not in the output encoding
    repertoire for the encoding codec will be \u escaped as well.

    &#34;&#34;&#34;
    # Do the JSON encoding
    j = JSON(**kwargs)
    output = j.encode(obj, encoding)
    return output</code></pre>
</details>
</dd>
<dt id="demjson3.encode_to_file"><code class="name flex">
<span>def <span class="ident">encode_to_file</span></span>(<span>filename, obj, encoding='utf-8', overwrite=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a Python object into JSON and writes into the given file.</p>
<p>If no encoding is given, then UTF-8 will be used.</p>
<p>See the encode() function for a description of other possible options.</p>
<p>If the file already exists and the 'overwrite' option is not set
to True, then the existing file will not be overwritten.
(Note,
there is a subtle race condition in the check so there are
possible conditions in which a file may be overwritten)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_to_file(filename, obj, encoding=&#34;utf-8&#34;, overwrite=False, **kwargs):
    &#34;&#34;&#34;Encodes a Python object into JSON and writes into the given file.

    If no encoding is given, then UTF-8 will be used.

    See the encode() function for a description of other possible options.

    If the file already exists and the &#39;overwrite&#39; option is not set
    to True, then the existing file will not be overwritten.  (Note,
    there is a subtle race condition in the check so there are
    possible conditions in which a file may be overwritten)

    &#34;&#34;&#34;
    import os, errno

    if not encoding:
        encoding = &#34;utf-8&#34;

    if not isinstance(filename, str) or not filename:
        raise TypeError(&#34;Expected a file name&#34;)

    if not overwrite and os.path.exists(filename):
        raise IOError(errno.EEXIST, &#34;File exists: %r&#34; % filename)

    jsondata = encode(obj, encoding=encoding, **kwargs)

    try:
        fp = open(filename, &#34;wb&#34;)
    except Exception:
        raise
    else:
        try:
            fp.write(jsondata)
        finally:
            fp.close()</code></pre>
</details>
</dd>
<dt id="demjson3.extend_and_flatten_list_with_sep"><code class="name flex">
<span>def <span class="ident">extend_and_flatten_list_with_sep</span></span>(<span>orig_seq, extension_seq, separator='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_and_flatten_list_with_sep(orig_seq, extension_seq, separator=&#34;&#34;):
    for i, part in enumerate(extension_seq):
        if i &gt; 0 and separator:
            orig_seq.append(separator)
        orig_seq.extend(part)</code></pre>
</details>
</dd>
<dt id="demjson3.extend_list_with_sep"><code class="name flex">
<span>def <span class="ident">extend_list_with_sep</span></span>(<span>orig_seq, extension_seq, sepchar='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_list_with_sep(orig_seq, extension_seq, sepchar=&#34;&#34;):
    if not sepchar:
        orig_seq.extend(extension_seq)
    else:
        for i, x in enumerate(extension_seq):
            if i &gt; 0:
                orig_seq.append(sepchar)
            orig_seq.append(x)</code></pre>
</details>
</dd>
<dt id="demjson3.skipstringsafe"><code class="name flex">
<span>def <span class="ident">skipstringsafe</span></span>(<span>s, start=0, end=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skipstringsafe(s, start=0, end=None):
    i = start
    # if end is None:
    #    end = len(s)
    unsafe = helpers.unsafe_string_chars
    while i &lt; end and s[i] not in unsafe:
        # c = s[i]
        # if c in unsafe_string_chars:
        #    break
        i += 1
    return i</code></pre>
</details>
</dd>
<dt id="demjson3.skipstringsafe_slow"><code class="name flex">
<span>def <span class="ident">skipstringsafe_slow</span></span>(<span>s, start=0, end=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skipstringsafe_slow(s, start=0, end=None):
    i = start
    if end is None:
        end = len(s)
    while i &lt; end:
        c = s[i]
        if c == &#39;&#34;&#39; or c == &#34;&#39;&#34; or c == &#34;\\&#34; or ord(c) &lt;= 0x1F:
            break
        i += 1
    return i</code></pre>
</details>
</dd>
<dt id="demjson3.smart_sort_transform"><code class="name flex">
<span>def <span class="ident">smart_sort_transform</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smart_sort_transform(key):
    numfmt = &#34;%012d&#34;
    digits = &#34;0123456789&#34;
    zero = ord(&#34;0&#34;)
    if not key:
        key = &#34;&#34;
    elif isinstance(key, int):
        key = numfmt % key
    elif isinstance(key, str):
        keylen = len(key)
        words = []
        i = 0
        while i &lt; keylen:
            if key[i] in digits:
                num = 0
                while i &lt; keylen and key[i] in digits:
                    num *= 10
                    num += ord(key[i]) - zero
                    i += 1
                words.append(numfmt % num)
            else:
                words.append(key[i].upper())
                i += 1
        key = &#34;&#34;.join(words)
    else:
        key = str(key)
    return key</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="demjson3.JSON"><code class="flex name class">
<span>class <span class="ident">JSON</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An encoder/decoder for JSON data streams.</p>
<p>Usually you will call the encode() or decode() methods.
The other
methods are for lower-level processing.</p>
<p>Whether the JSON parser runs in strict mode (which enforces exact
compliance with the JSON spec) or the more forgiving non-string mode
can be affected by setting the 'strict' argument in the object's
initialization; or by assigning True or False to the 'strict'
property of the object.</p>
<p>You can also adjust a finer-grained control over strictness by
allowing or forbidding specific behaviors.
You can get a list of
all the available behaviors by accessing the 'behaviors' property.
Likewise the 'allowed_behaviors' and 'forbidden_behaviors' list which
behaviors will be allowed and which will not.
Call the allow()
or forbid() methods to adjust these.</p>
<p>Creates a JSON encoder/decoder object.</p>
<p>You may pass encoding and decoding options either by passing
an argument named 'json_options' with an instance of a
json_options class; or with individual keyword/values that will
be used to initialize a new json_options object.</p>
<p>You can also set hooks by using keyword arguments using the
hook name; e.g., encode_dict=my_hook_func.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSON(object):
    &#34;&#34;&#34;An encoder/decoder for JSON data streams.

    Usually you will call the encode() or decode() methods.  The other
    methods are for lower-level processing.

    Whether the JSON parser runs in strict mode (which enforces exact
    compliance with the JSON spec) or the more forgiving non-string mode
    can be affected by setting the &#39;strict&#39; argument in the object&#39;s
    initialization; or by assigning True or False to the &#39;strict&#39;
    property of the object.

    You can also adjust a finer-grained control over strictness by
    allowing or forbidding specific behaviors.  You can get a list of
    all the available behaviors by accessing the &#39;behaviors&#39; property.
    Likewise the &#39;allowed_behaviors&#39; and &#39;forbidden_behaviors&#39; list which
    behaviors will be allowed and which will not.  Call the allow()
    or forbid() methods to adjust these.

    &#34;&#34;&#34;

    _string_quotes = &#34;\&#34;&#39;&#34;

    _escapes_json = {  # character escapes in JSON
        &#39;&#34;&#39;: &#39;&#34;&#39;,
        &#34;/&#34;: &#34;/&#34;,
        &#34;\\&#34;: &#34;\\&#34;,
        &#34;b&#34;: &#34;\b&#34;,
        &#34;f&#34;: &#34;\f&#34;,
        &#34;n&#34;: &#34;\n&#34;,
        &#34;r&#34;: &#34;\r&#34;,
        &#34;t&#34;: &#34;\t&#34;,
    }

    _escapes_js = {  # character escapes in Javascript
        &#39;&#34;&#39;: &#39;&#34;&#39;,
        &#34;&#39;&#34;: &#34;&#39;&#34;,
        &#34;\\&#34;: &#34;\\&#34;,
        &#34;b&#34;: &#34;\b&#34;,
        &#34;f&#34;: &#34;\f&#34;,
        &#34;n&#34;: &#34;\n&#34;,
        &#34;r&#34;: &#34;\r&#34;,
        &#34;t&#34;: &#34;\t&#34;,
        &#34;v&#34;: &#34;\v&#34;,
        &#34;0&#34;: &#34;\x00&#34;,
    }

    # Following is a reverse mapping of escape characters, used when we
    # output JSON.  Only those escapes which are always safe (e.g., in JSON)
    # are here.  It won&#39;t hurt if we leave questionable ones out.
    _rev_escapes = {
        &#34;\n&#34;: &#34;\\n&#34;,
        &#34;\t&#34;: &#34;\\t&#34;,
        &#34;\b&#34;: &#34;\\b&#34;,
        &#34;\r&#34;: &#34;\\r&#34;,
        &#34;\f&#34;: &#34;\\f&#34;,
        &#39;&#34;&#39;: &#39;\\&#34;&#39;,
        &#34;\\&#34;: &#34;\\\\&#34;,
    }
    _optional_rev_escapes = {&#34;/&#34;: &#34;\\/&#34;}  # only escaped if forced to do so

    json_syntax_characters = &#39;{}[]&#34;\\,:0123456789.-+abcdefghijklmnopqrstuvwxyz \t\n\r&#39;

    all_hook_names = (
        &#34;decode_number&#34;,
        &#34;decode_float&#34;,
        &#34;decode_object&#34;,
        &#34;decode_array&#34;,
        &#34;decode_string&#34;,
        &#34;encode_value&#34;,
        &#34;encode_dict&#34;,
        &#34;encode_dict_key&#34;,
        &#34;encode_sequence&#34;,
        &#34;encode_bytes&#34;,
        &#34;encode_default&#34;,
    )

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Creates a JSON encoder/decoder object.

        You may pass encoding and decoding options either by passing
        an argument named &#39;json_options&#39; with an instance of a
        json_options class; or with individual keyword/values that will
        be used to initialize a new json_options object.

        You can also set hooks by using keyword arguments using the
        hook name; e.g., encode_dict=my_hook_func.

        &#34;&#34;&#34;
        import unicodedata

        kwargs = kwargs.copy()
        # Initialize hooks
        for hookname in self.all_hook_names:
            if hookname in kwargs:
                self.set_hook(hookname, kwargs[hookname])
                del kwargs[hookname]
            else:
                self.set_hook(hookname, None)

        # Set options
        if &#34;json_options&#34; in kwargs:
            self._options = kwargs[&#34;json_options&#34;]
        else:
            self._options = json_options(**kwargs)

        # The following is a boolean map of the first 256 characters
        # which will quickly tell us which of those characters never
        # need to be escaped.

        self._asciiencodable = [
            32 &lt;= c &lt; 128
            and chr(c) not in self._rev_escapes
            and not unicodedata.category(chr(c)) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]
            for c in range(0, 256)
        ]

    @property
    def options(self):
        &#34;&#34;&#34;The optional behaviors used, e.g., the JSON conformance
        strictness.  Returns an instance of json_options.

        &#34;&#34;&#34;
        return self._options

    def clear_hook(self, hookname):
        &#34;&#34;&#34;Unsets a hook callback, as previously set with set_hook().&#34;&#34;&#34;
        self.set_hook(hookname, None)

    def clear_all_hooks(self):
        &#34;&#34;&#34;Unsets all hook callbacks, as previously set with set_hook().&#34;&#34;&#34;
        for hookname in self.all_hook_names:
            self.clear_hook(hookname)

    def set_hook(self, hookname, function):
        &#34;&#34;&#34;Sets a user-defined callback function used during encoding or decoding.

        The &#39;hookname&#39; argument must be a string containing the name of
        one of the available hooks, listed below.

        The &#39;function&#39; argument must either be None, which disables the hook,
        or a callable function.  Hooks do not stack, if you set a hook it will
        undo any previously set hook.

        Netsted values.  When decoding JSON that has nested objects or
        arrays, the decoding hooks will be called once for every
        corresponding value, even if nested.  Generally the decoding
        hooks will be called from the inner-most value outward, and
        then left to right.

        Skipping. Any hook function may raise a JSONSkipHook exception
        if it does not wish to handle the particular invocation.  This
        will have the effect of skipping the hook for that particular
        value, as if the hook was net set.

        AVAILABLE HOOKS:

        * decode_string
            Called for every JSON string literal with the
            Python-equivalent string value as an argument. Expects to
            get a Python object in return.

        * decode_float:
            Called for every JSON number that looks like a float (has
            a &#34;.&#34;).  The string representation of the number is passed
            as an argument.  Expects to get a Python object in return.

        * decode_number:
            Called for every JSON number. The string representation of
            the number is passed as an argument.  Expects to get a
            Python object in return.  NOTE: If the number looks like a
            float and the &#39;decode_float&#39; hook is set, then this hook
            will not be called.

        * decode_array:
            Called for every JSON array. A Python list is passed as
            the argument, and expects to get a Python object back.
            NOTE: this hook will get called for every array, even
            for nested arrays.

        * decode_object:
            Called for every JSON object.  A Python dictionary is passed
            as the argument, and expects to get a Python object back.
            NOTE: this hook will get called for every object, even
            for nested objects.

        * encode_value:
            Called for every Python object which is to be encoded into JSON.

        * encode_dict:
            Called for every Python dictionary or anything that looks
            like a dictionary.

        * encode_dict_key:
            Called for every dictionary key.

        * encode_sequence:
            Called for every Python sequence-like object that is not a
            dictionary or string. This includes lists and tuples.

        * encode_bytes:
            Called for every Python bytes or bytearray type; or for
            any memoryview with a byte (&#39;B&#39;) item type.  (Python 3 only)

        * encode_default:
            Called for any Python type which can not otherwise be converted
            into JSON, even after applying any other encoding hooks.

        &#34;&#34;&#34;
        if hookname in self.all_hook_names:
            att = hookname + &#34;_hook&#34;
            if function != None and not callable(function):
                raise ValueError(
                    &#34;Hook %r must be None or a callable function&#34; % hookname
                )
            setattr(self, att, function)
        else:
            raise ValueError(&#34;Unknown hook name %r&#34; % hookname)

    def has_hook(self, hook_name):
        if not hook_name or hook_name not in self.all_hook_names:
            return False
        hook = getattr(self, hook_name + &#34;_hook&#34;)
        return callable(hook)

    def call_hook(self, hook_name, input_object, position=None, *args, **kwargs):
        &#34;&#34;&#34;Wrapper function to invoke a user-supplied hook function.

        This will capture any exceptions raised by the hook and do something
        appropriate with it.

        &#34;&#34;&#34;
        import sys

        if hook_name not in self.all_hook_names:
            raise AttributeError(&#34;No such hook %r&#34; % hook_name)
        hook = getattr(self, hook_name + &#34;_hook&#34;)
        if not callable(hook):
            raise TypeError(&#34;Hook is not callable: %r&#34; % (hook,))
        try:
            rval = hook(input_object, *args, **kwargs)
        except JSONSkipHook:
            raise  # Do nothing
        except Exception as err:
            exc_info = sys.exc_info()
            if hook_name.startswith(&#34;encode_&#34;):
                ex_class = JSONEncodeHookError
            else:
                ex_class = JSONDecodeHookError

            if isinstance(err, JSONStopProcessing):
                severity = &#34;fatal&#34;
            else:
                severity = &#34;error&#34;

            newerr = ex_class(
                hook_name,
                exc_info,
                input_object,
                *args,
                position=position,
                severity=severity
            )

            # Simulate Python 3&#39;s: &#34;raise X from Y&#34; exception chaining
            newerr.__cause__ = err
            newerr.__traceback__ = exc_info[2]
            raise newerr
        return rval

    def isws(self, c):
        &#34;&#34;&#34;Determines if the given character is considered as white space.

        Note that Javscript is much more permissive on what it considers
        to be whitespace than does JSON.

        Ref. ECMAScript section 7.2

        &#34;&#34;&#34;
        if not self.options.unicode_whitespace:
            return c in &#34; \t\n\r&#34;
        else:
            if not isinstance(c, str):
                c = str(c)
            if c in &#34; \t\n\r\f\v&#34;:
                return True
            import unicodedata

            return unicodedata.category(c) == &#34;Zs&#34;

    def islineterm(self, c):
        &#34;&#34;&#34;Determines if the given character is considered a line terminator.

        Ref. ECMAScript section 7.3

        &#34;&#34;&#34;
        if c == &#34;\r&#34; or c == &#34;\n&#34;:
            return True
        if c == &#34;\u2028&#34; or c == &#34;\u2029&#34;:  # unicodedata.category(c) in  [&#39;Zl&#39;, &#39;Zp&#39;]
            return True
        return False

    def recover_parser(self, state):
        &#34;&#34;&#34;Try to recover after a syntax error by locating the next &#34;known&#34; position.&#34;&#34;&#34;
        buf = state.buf
        buf.skipuntil(lambda c: c in &#34;,:[]{}\&#34;&#39;;&#34; or helpers.char_is_unicode_eol(c))
        stopchar = buf.peek()
        self.skipws(state)
        if buf.at_end:
            state.push_info(
                &#34;Could not recover parsing after previous error&#34;, position=buf.position
            )
        else:
            state.push_info(
                &#34;Recovering parsing after character %r&#34; % stopchar,
                position=buf.position,
            )
        return stopchar

    def decode_null(self, state):
        &#34;&#34;&#34;Intermediate-level decoder for ECMAScript &#39;null&#39; keyword.

        Takes a string and a starting index, and returns a Python
        None object and the index of the next unparsed character.

        &#34;&#34;&#34;
        buf = state.buf
        start_position = buf.position
        kw = buf.pop_identifier()
        if not kw or kw != &#34;null&#34;:
            state.push_error(&#34;Expected a &#39;null&#39; keyword&#39;&#34;, kw, position=start_position)
        else:
            state.stats.num_nulls += 1
        return None

    def encode_undefined(self, state):
        &#34;&#34;&#34;Produces the ECMAScript &#39;undefined&#39; keyword.&#34;&#34;&#34;
        state.append(&#34;undefined&#34;)

    def encode_null(self, state):
        &#34;&#34;&#34;Produces the JSON &#39;null&#39; keyword.&#34;&#34;&#34;
        state.append(&#34;null&#34;)

    def decode_boolean(self, state):
        &#34;&#34;&#34;Intermediate-level decode for JSON boolean literals.

        Takes a string and a starting index, and returns a Python bool
        (True or False) and the index of the next unparsed character.

        &#34;&#34;&#34;
        buf = state.buf
        start_position = buf.position
        kw = buf.pop_identifier()
        if not kw or kw not in (&#34;true&#34;, &#34;false&#34;):
            state.push_error(
                &#34;Expected a &#39;true&#39; or &#39;false&#39; keyword&#39;&#34;, kw, position=start_position
            )
        else:
            state.stats.num_bools += 1
        return kw == &#34;true&#34;

    def encode_boolean(self, bval, state):
        &#34;&#34;&#34;Encodes the Python boolean into a JSON Boolean literal.&#34;&#34;&#34;
        state.append(&#34;true&#34; if bool(bval) else &#34;false&#34;)

    def decode_number(self, state):
        &#34;&#34;&#34;Intermediate-level decoder for JSON numeric literals.

        Takes a string and a starting index, and returns a Python
        suitable numeric type and the index of the next unparsed character.

        The returned numeric type can be either of a Python int,
        long, or float.  In addition some special non-numbers may
        also be returned such as nan, inf, and neginf (technically
        which are Python floats, but have no numeric value.)

        Ref. ECMAScript section 8.5.

        &#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)
        start_position = buf.position

        # Use external number parser hook if available
        if self.has_hook(&#34;decode_number&#34;) or self.has_hook(&#34;decode_float&#34;):
            c = buf.peek()
            if c and c in &#34;-+0123456789.&#34;:  # First chars for a number-like value
                buf.save_position()
                nbr = buf.pop_while_in(&#34;-+0123456789abcdefABCDEF&#34; &#34;NaN&#34; &#34;Infinity.&#34;)
                if &#34;.&#34; in nbr and self.has_hook(&#34;decode_float&#34;):
                    hook_name = &#34;decode_float&#34;
                elif self.has_hook(&#34;decode_number&#34;):
                    hook_name = &#34;decode_number&#34;
                else:
                    hook_name = None

                if hook_name:
                    try:
                        val = self.call_hook(hook_name, nbr, position=start_position)
                    except JSONSkipHook:
                        pass
                    except JSONError as err:
                        state.push_exception(err)
                        val = undefined
                    else:
                        buf.clear_saved_position()
                        return val
                # Hook didn&#39;t handle it, restore old position
                buf.restore_position()

        # Detect initial sign character(s)
        sign = +1
        sign_count = 0
        sign_saw_plus = False
        sign_saw_ws = False
        c = buf.peek()
        while c and c in &#34;+-&#34;:
            if c == &#34;-&#34;:
                sign = sign * -1
            elif c == &#34;+&#34;:
                sign_saw_plus = True
            sign_count += 1
            buf.skip()
            if self.skipws_nocomments(state) &gt; 0:
                sign_saw_ws = True
            c = buf.peek()

        if sign_count &gt; 1 or sign_saw_plus:
            state.push_cond(
                self.options.all_numeric_signs,
                &#39;Numbers may only have a single &#34;-&#34; as a sign prefix&#39;,
                position=start_position,
            )
        if sign_saw_ws:
            state.push_error(
                &#34;Spaces may not appear between a +/- number sign and the digits&#34;,
                position=start_position,
            )

        # Check for ECMAScript symbolic non-numbers
        if not c:
            state.push_error(
                &#34;Missing numeric value after sign&#34;, position=start_position
            )
            self.recover_parser(state)
            self.stats.num_undefineds += 1
            return undefined
        elif c.isalpha() or c in &#34;_$&#34;:
            kw = buf.popwhile(lambda c: c.isalnum() or c in &#34;_$&#34;)
            if kw == &#34;NaN&#34;:
                state.push_cond(
                    self.options.non_numbers,
                    &#34;NaN literals are not allowed in strict JSON&#34;,
                    position=start_position,
                )
                state.stats.num_nans += 1
                return self.options.nan
            elif kw == &#34;Infinity&#34;:
                state.push_cond(
                    self.options.non_numbers,
                    &#34;Infinity literals are not allowed in strict JSON&#34;,
                    position=start_position,
                )
                state.stats.num_infinities += 1
                if sign &lt; 0:
                    return self.options.neginf
                else:
                    return self.options.inf
            else:
                state.push_error(
                    &#34;Unknown numeric value keyword&#34;, kw, position=start_position
                )
                return undefined

        # Check for radix-prefixed numbers
        elif c == &#34;0&#34; and (buf.peek(1) in [&#34;x&#34;, &#34;X&#34;]):
            # ----- HEX NUMBERS 0x123
            prefix = buf.popstr(2)
            digits = buf.popwhile(helpers.is_hex_digit)
            state.push_cond(
                self.options.hex_numbers,
                &#34;Hexadecimal literals are not allowed in strict JSON&#34;,
                prefix + digits,
                position=start_position,
            )
            if len(digits) == 0:
                state.push_error(
                    &#34;Hexadecimal number is invalid&#34;, position=start_position
                )
                self.recover_parser(state)
                return undefined
            ival = helpers.decode_hex(digits)
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_HEX)
            return n
        elif c == &#34;0&#34; and (buf.peek(1) in [&#34;o&#34;, &#34;O&#34;]):
            # ----- NEW-STYLE OCTAL NUMBERS  0o123
            prefix = buf.popstr(2)
            digits = buf.popwhile(helpers.is_octal_digit)
            state.push_cond(
                self.options.octal_numbers,
                &#34;Octal literals are not allowed in strict JSON&#34;,
                prefix + digits,
                position=start_position,
            )
            if len(digits) == 0:
                state.push_error(&#34;Octal number is invalid&#34;, position=start_position)
                self.recover_parser(state)
                return undefined
            ival = helpers.decode_octal(digits)
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_OCTAL)
            return n
        elif c == &#34;0&#34; and (buf.peek(1) in [&#34;b&#34;, &#34;B&#34;]):
            # ----- NEW-STYLE BINARY NUMBERS  0b1101
            prefix = buf.popstr(2)
            digits = buf.popwhile(helpers.is_binary_digit)
            state.push_cond(
                self.options.binary_numbers,
                &#34;Binary literals are not allowed in strict JSON&#34;,
                prefix + digits,
                position=start_position,
            )
            if len(digits) == 0:
                state.push_error(&#34;Binary number is invalid&#34;, position=start_position)
                self.recover_parser(state)
                return undefined
            ival = helpers.decode_binary(digits)
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_BINARY)
            return n
        else:
            # ----- DECIMAL OR LEGACY-OCTAL NUMBER.   123, 0123
            # General syntax is:  \d+[\.\d+][e[+-]?\d+]
            number = buf.popwhile(lambda c: c in &#34;0123456789.+-eE&#34;)
            imax = len(number)
            if imax == 0:
                state.push_error(&#34;Missing numeric value&#34;, position=start_position)
            has_leading_zero = False
            units_digits = []  # digits making up whole number portion
            fraction_digits = []  # digits making up fractional portion
            exponent_digits = []  # digits making up exponent portion (excluding sign)
            esign = &#34;+&#34;  # sign of exponent
            sigdigits = 0  # number of significant digits (approximate)
            saw_decimal_point = False
            saw_exponent = False

            # Break number into parts in a first pass...use a mini state machine
            in_part = &#34;units&#34;
            for i, c in enumerate(number):

                if c == &#34;.&#34;:
                    if in_part != &#34;units&#34;:
                        state.push_error(&#34;Bad number&#34;, number, position=start_position)
                        self.recover_parser(state)
                        return undefined
                    in_part = &#34;fraction&#34;
                    saw_decimal_point = True
                elif c in &#34;eE&#34;:
                    if in_part == &#34;exponent&#34;:
                        state.push_error(&#34;Bad number&#34;, number, position=start_position)
                        self.recover_parser(state)
                        return undefined
                    in_part = &#34;exponent&#34;
                    saw_exponent = True
                elif c in &#34;+-&#34;:
                    if in_part != &#34;exponent&#34; or exponent_digits:
                        state.push_error(&#34;Bad number&#34;, number, position=start_position)
                        self.recover_parser(state)
                        return undefined
                    esign = c
                else:  # digit
                    if in_part == &#34;units&#34;:
                        units_digits.append(c)
                    elif in_part == &#34;fraction&#34;:
                        fraction_digits.append(c)
                    elif in_part == &#34;exponent&#34;:
                        exponent_digits.append(c)
            units_s = &#34;&#34;.join(units_digits)
            fraction_s = &#34;&#34;.join(fraction_digits)
            exponent_s = &#34;&#34;.join(exponent_digits)

            # Basic syntax rules checking
            is_integer = not (saw_decimal_point or saw_exponent)

            if not units_s and not fraction_s:
                state.push_error(&#34;Bad number&#34;, number, position=start_position)
                self.recover_parser(state)
                return undefined

            if saw_decimal_point and not fraction_s:
                state.push_cond(
                    self.options.trailing_decimal_point,
                    &#34;Bad number, decimal point must be followed by at least one digit&#34;,
                    number,
                    position=start_position,
                )
                fraction_s = &#34;0&#34;

            if saw_exponent and not exponent_s:
                state.push_error(
                    &#34;Bad number, exponent is missing&#34;, number, position=start_position
                )
                self.recover_parser(state)
                return undefined

            if not units_s:
                state.push_cond(
                    self.options.initial_decimal_point,
                    &#34;Bad number, decimal point must be preceded by at least one digit&#34;,
                    number,
                    position=start_position,
                )
                units = &#34;0&#34;
            elif len(units_s) &gt; 1 and units_s[0] == &#34;0&#34;:
                has_leading_zero = True
                if self.options.is_forbid_leading_zeros:
                    state.push_cond(
                        self.options.leading_zeros,
                        &#34;Numbers may not have extra leading zeros&#34;,
                        number,
                        position=start_position,
                    )
                elif self.options.is_warn_leading_zeros:
                    state.push_cond(
                        self.options.leading_zeros,
                        &#34;Numbers may not have leading zeros; interpreting as %s&#34;
                        % self.options.leading_zero_radix_as_word,
                        number,
                        position=start_position,
                    )

            # Estimate number of significant digits
            sigdigits = len((units_s + fraction_s).replace(&#34;0&#34;, &#34; &#34;).strip())

            # Handle legacy octal integers.
            if has_leading_zero and is_integer and self.options.leading_zero_radix == 8:
                # ----- LEGACY-OCTAL  0123
                try:
                    ival = helpers.decode_octal(units_s)
                except ValueError:
                    state.push_error(
                        &#34;Bad number, not a valid octal value&#34;,
                        number,
                        position=start_position,
                    )
                    self.recover_parser(state)
                    return self.options.nan  # undefined
                state.update_integer_stats(ival, sign=sign, position=start_position)
                n = state.options.make_int(
                    ival, sign, number_format=NUMBER_FORMAT_LEGACYOCTAL
                )
                return n

            # Determine the exponential part
            if exponent_s:
                try:
                    exponent = int(exponent_s)
                except ValueError:
                    state.push_error(
                        &#34;Bad number, bad exponent&#34;, number, position=start_position
                    )
                    self.recover_parser(state)
                    return undefined
                if esign == &#34;-&#34;:
                    exponent = -exponent
            else:
                exponent = 0

            # Try to make an int/long first.
            if not saw_decimal_point and exponent &gt;= 0:
                # ----- A DECIMAL INTEGER
                ival = int(units_s)
                if exponent != 0:
                    ival *= 10 ** exponent
                state.update_integer_stats(ival, sign=sign, position=start_position)
                n = state.options.make_int(ival, sign)
            else:
                # ----- A FLOATING-POINT NUMBER
                try:
                    if (
                        exponent &lt; float_minexp
                        or exponent &gt; float_maxexp
                        or sigdigits &gt; float_sigdigits
                    ):
                        n = state.options.make_decimal(number, sign)
                    else:
                        n = state.options.make_float(number, sign)
                except ValueError as err:
                    state.push_error(
                        &#34;Bad number, %s&#34; % err.message, number, position=start_position
                    )
                    n = undefined
                else:
                    state.update_float_stats(n, sign=sign, position=start_position)
            return n

    def encode_number(self, n, state):
        &#34;&#34;&#34;Encodes a Python numeric type into a JSON numeric literal.

        The special non-numeric values of float(&#39;nan&#39;), float(&#39;inf&#39;)
        and float(&#39;-inf&#39;) are translated into appropriate JSON
        literals.

        Note that Python complex types are not handled, as there is no
        ECMAScript equivalent type.

        &#34;&#34;&#34;
        if isinstance(n, complex):
            if n.imag:
                raise JSONEncodeError(
                    &#34;Can not encode a complex number that has a non-zero imaginary part&#34;,
                    n,
                )
            n = n.real

        if isinstance(n, json_int):
            state.append(n.json_format())
            return

        if isinstance(n, int):
            state.append(str(n))
            return

        if isinstance(n, decimal.Decimal):
            if n.is_nan():  # Could be &#39;NaN&#39; or &#39;sNaN&#39;
                state.append(&#34;NaN&#34;)
            elif n.is_infinite():
                if n.is_signed():
                    state.append(&#34;-Infinity&#34;)
                else:
                    state.append(&#34;Infinity&#34;)
            else:
                s = str(n).lower()
                if &#34;e&#34; not in s and &#34;.&#34; not in s:
                    s = s + &#34;.0&#34;
                state.append(s)
            return

        global nan, inf, neginf
        if n is nan:
            state.append(&#34;NaN&#34;)
        elif n is inf:
            state.append(&#34;Infinity&#34;)
        elif n is neginf:
            state.append(&#34;-Infinity&#34;)
        elif isinstance(n, float):
            # Check for non-numbers.
            # In python nan == inf == -inf, so must use repr() to distinguish
            reprn = repr(n).lower()
            if (&#34;inf&#34; in reprn and &#34;-&#34; in reprn) or n == neginf:
                state.append(&#34;-Infinity&#34;)
            elif &#34;inf&#34; in reprn or n is inf:
                state.append(&#34;Infinity&#34;)
            elif &#34;nan&#34; in reprn or n is nan:
                state.append(&#34;NaN&#34;)
            else:
                # A normal float.
                state.append(repr(n))
        else:
            raise TypeError(
                &#34;encode_number expected an integral, float, or decimal number type&#34;,
                type(n),
            )

    def decode_string(self, state):
        &#34;&#34;&#34;Intermediate-level decoder for JSON string literals.

        Takes a string and a starting index, and returns a Python
        string (or unicode string) and the index of the next unparsed
        character.

        &#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)
        quote = buf.peek()
        if quote == &#39;&#34;&#39;:
            pass
        elif quote == &#34;&#39;&#34;:
            state.push_cond(
                self.options.single_quoted_strings,
                &#34;String literals must use double quotation marks in strict JSON&#34;,
            )
        else:
            state.push_error(&#34;String literal must be properly quoted&#34;)
            return undefined

        string_position = buf.position
        buf.skip()

        if self.options.is_forbid_js_string_escapes:
            escapes = self._escapes_json
        else:
            escapes = self._escapes_js
        ccallowed = not self.options.is_forbid_control_char_in_string
        chunks = []
        _append = chunks.append

        # Used to track the last seen high-surrogate character
        high_surrogate = None
        highsur_position = None

        # Used to track if errors occured so we don&#39;t keep reporting multiples
        had_lineterm_error = False

        # Start looping character by character until the final quotation mark
        saw_final_quote = False
        should_stop = False
        while not saw_final_quote and not should_stop:
            if buf.at_end:
                state.push_error(
                    &#34;String literal is not terminated&#34;,
                    outer_position=string_position,
                    context=&#34;String&#34;,
                )
                break
            c = buf.peek()

            # Make sure a high surrogate is immediately followed by a low surrogate
            if high_surrogate:
                if 0xDC00 &lt;= ord(c) &lt;= 0xDFFF:
                    low_surrogate = buf.pop()
                    try:
                        uc = helpers.surrogate_pair_as_unicode(
                            high_surrogate, low_surrogate
                        )
                    except ValueError as err:
                        state.push_error(
                            &#34;Illegal Unicode surrogate pair&#34;,
                            (high_surrogate, low_surrogate),
                            position=highsur_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        uc = &#34;\ufffd&#34;  # replacement char
                    _append(uc)
                    high_surrogate = None
                    highsur_position = None
                    continue  # ==== NEXT CHAR
                elif buf.peekstr(2) != &#34;\\u&#34;:
                    state.push_error(
                        &#34;High unicode surrogate must be followed by a low surrogate&#34;,
                        position=highsur_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    _append(&#34;\ufffd&#34;)  # replacement char
                    high_surrogate = None
                    highsur_position = None

            if c == quote:
                buf.skip()  # skip over closing quote
                saw_final_quote = True
                break
            elif c == &#34;\\&#34;:
                # Escaped character
                escape_position = buf.position
                buf.skip()  # skip over backslash
                c = buf.peek()
                if not c:
                    state.push_error(
                        &#34;Escape in string literal is incomplete&#34;,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    break
                elif helpers.is_octal_digit(c):
                    # Handle octal escape codes first so special \0 doesn&#39;t kick in yet.
                    # Follow Annex B.1.2 of ECMAScript standard.
                    if &#34;0&#34; &lt;= c &lt;= &#34;3&#34;:
                        maxdigits = 3
                    else:
                        maxdigits = 2
                    digits = buf.popwhile(helpers.is_octal_digit, maxchars=maxdigits)
                    n = helpers.decode_octal(digits)
                    if n == 0:
                        state.push_cond(
                            self.options.zero_byte,
                            &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                            &#34;\\&#34; + digits,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                    else:  # n != 0
                        state.push_cond(
                            self.options.octal_numbers,
                            &#39;JSON does not allow octal character escapes other than &#34;\\0&#34;&#39;,
                            &#34;\\&#34; + digits,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                    should_stop = state.should_stop
                    if n &lt; 128:
                        _append(chr(n))
                    else:
                        _append(helpers.safe_unichr(n))
                elif c in escapes:
                    buf.skip()
                    _append(escapes[c])
                elif c == &#34;u&#34; or c == &#34;x&#34;:
                    buf.skip()
                    esc_opener = &#34;\\&#34; + c
                    esc_closer = &#34;&#34;
                    if c == &#34;u&#34;:
                        if buf.peek() == &#34;{&#34;:
                            buf.skip()
                            esc_opener += &#34;{&#34;
                            esc_closer = &#34;}&#34;
                            maxdigits = None
                            state.push_cond(
                                self.options.extended_unicode_escapes,
                                &#34;JSON strings do not allow \\u{...} escapes&#34;,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                        else:
                            maxdigits = 4
                    else:  # c== &#39;x&#39;
                        state.push_cond(
                            self.options.js_string_escapes,
                            &#34;JSON strings may not use the \\x hex-escape&#34;,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        maxdigits = 2

                    digits = buf.popwhile(helpers.is_hex_digit, maxchars=maxdigits)

                    if esc_closer:
                        if buf.peek() != esc_closer:
                            state.push_error(
                                &#34;Unicode escape sequence is missing closing &#39;%s&#39;&#34;
                                % esc_closer,
                                esc_opener + digits,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                            should_stop = state.should_stop
                        else:
                            buf.skip()

                    esc_sequence = esc_opener + digits + esc_closer

                    if not digits:
                        state.push_error(
                            &#34;numeric character escape sequence is truncated&#34;,
                            esc_sequence,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        codepoint = 0xFFFD  # replacement char
                    else:
                        if maxdigits and len(digits) != maxdigits:
                            state.push_error(
                                &#34;escape sequence has too few hexadecimal digits&#34;,
                                esc_sequence,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                        codepoint = helpers.decode_hex(digits)

                    if codepoint &gt; 0x10FFFF:
                        state.push_error(
                            &#34;Unicode codepoint is beyond U+10FFFF&#34;,
                            esc_opener + digits + esc_closer,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        codepoint = 0xFFFD  # replacement char

                    if high_surrogate:
                        # Decode surrogate pair and clear high surrogate
                        low_surrogate = chr(codepoint)
                        try:
                            uc = helpers.surrogate_pair_as_unicode(
                                high_surrogate, low_surrogate
                            )
                        except ValueError as err:
                            state.push_error(
                                &#34;Illegal Unicode surrogate pair&#34;,
                                (high_surrogate, low_surrogate),
                                position=highsur_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                            should_stop = state.should_stop
                            uc = &#34;\ufffd&#34;  # replacement char
                        _append(uc)
                        high_surrogate = None
                        highsur_position = None
                    elif codepoint &lt; 128:
                        # ASCII chars always go in as a str
                        if codepoint == 0:
                            state.push_cond(
                                self.options.zero_byte,
                                &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                                position=escape_position,
                                outer_position=string_position,
                                context=&#34;String&#34;,
                            )
                            should_stop = state.should_stop
                        _append(chr(codepoint))
                    elif 0xD800 &lt;= codepoint &lt;= 0xDBFF:  # high surrogate
                        high_surrogate = chr(
                            codepoint
                        )  # remember until we get to the low surrogate
                        highsur_position = escape_position.copy()
                    elif 0xDC00 &lt;= codepoint &lt;= 0xDFFF:  # low surrogate
                        state.push_error(
                            &#34;Low unicode surrogate must be proceeded by a high surrogate&#34;,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        _append(&#34;\ufffd&#34;)  # replacement char
                    else:
                        # Other chars go in as a unicode char
                        _append(helpers.safe_unichr(codepoint))
                else:
                    # Unknown escape sequence
                    state.push_cond(
                        self.options.nonescape_characters,
                        &#34;String escape code is not allowed in strict JSON&#34;,
                        &#34;\\&#34; + c,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    _append(c)
                    buf.skip()
            elif ord(c) &lt;= 0x1F:  # A control character
                if ord(c) == 0:
                    state.push_cond(
                        self.options.zero_byte,
                        &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                        position=buf.position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                if self.islineterm(c):
                    if not had_lineterm_error:
                        state.push_error(
                            &#34;Line terminator characters must be escaped inside string literals&#34;,
                            &#34;U+%04X&#34; % ord(c),
                            position=buf.position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        had_lineterm_error = True
                    _append(c)
                    buf.skip()
                elif ccallowed:
                    _append(c)
                    buf.skip()
                else:
                    state.push_error(
                        &#34;Control characters must be escaped inside JSON string literals&#34;,
                        &#34;U+%04X&#34; % ord(c),
                        position=buf.position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    buf.skip()
            elif 0xD800 &lt;= ord(c) &lt;= 0xDBFF:  # a raw high surrogate
                high_surrogate = buf.pop()  # remember until we get to the low surrogate
                highsur_position = buf.position.copy()
            else:  # A normal character; not an escape sequence or end-quote.
                # Find a whole sequence of &#34;safe&#34; characters so we can append them
                # all at once rather than one a time, for speed.
                chunk = buf.popwhile(
                    lambda c: c not in helpers.unsafe_string_chars and c != quote
                )
                if not chunk:
                    _append(c)
                    buf.skip()
                else:
                    _append(chunk)

        # Check proper string termination
        if high_surrogate:
            state.push_error(
                &#34;High unicode surrogate must be followed by a low surrogate&#34;,
                position=highsur_position,
                outer_position=string_position,
                context=&#34;String&#34;,
            )
            _append(&#34;\ufffd&#34;)  # replacement char
            high_surrogate = None
            highsur_position = None

        if not saw_final_quote:
            state.push_error(
                &#34;String literal is not terminated with a quotation mark&#34;,
                position=buf.position,
                outer_position=string_position,
                context=&#34;String&#34;,
            )

        if state.should_stop:
            return undefined

        # Compose the python string and update stats
        s = &#34;&#34;.join(chunks)
        state.update_string_stats(s, position=string_position)

        # Call string hook
        if self.has_hook(&#34;decode_string&#34;):
            try:
                s = self.call_hook(&#34;decode_string&#34;, s, position=string_position)
            except JSONSkipHook:
                pass
            except JSONError as err:
                state.push_exception(err)
                s = undefined
        return s

    def encode_string(self, s, state):
        &#34;&#34;&#34;Encodes a Python string into a JSON string literal.&#34;&#34;&#34;
        # Must handle instances of UserString specially in order to be
        # able to use ord() on it&#39;s simulated &#34;characters&#34;.  Also
        # convert Python2 &#39;str&#39; types to unicode strings first.
        import unicodedata, sys
        import collections

        py2strenc = self.options.py2str_encoding
        if isinstance(s, collections.UserString):

            def tochar(c):
                c2 = c.data
                if py2strenc and not isinstance(c2, str):
                    return c2.decode(py2strenc)
                else:
                    return c2

        elif py2strenc and not isinstance(s, str):
            s = s.decode(py2strenc)
            tochar = None
        else:
            # Could use &#34;lambda c:c&#34;, but that is too slow.  So we set to None
            # and use an explicit if test inside the loop.
            tochar = None

        chunks = []
        chunks.append(&#39;&#34;&#39;)
        revesc = self._rev_escapes
        optrevesc = self._optional_rev_escapes
        asciiencodable = self._asciiencodable
        always_escape = state.options.always_escape_chars
        encunicode = state.escape_unicode_test
        i = 0
        imax = len(s)
        while i &lt; imax:
            if tochar:
                c = tochar(s[i])
            else:
                c = s[i]
            cord = ord(c)
            if (
                cord &lt; 256
                and asciiencodable[cord]
                and isinstance(encunicode, bool)
                and not (always_escape and c in always_escape)
            ):
                # Contiguous runs of plain old printable ASCII can be copied
                # directly to the JSON output without worry (unless the user
                # has supplied a custom is-encodable function).
                j = i
                i += 1
                while i &lt; imax:
                    if tochar:
                        c = tochar(s[i])
                    else:
                        c = s[i]
                    cord = ord(c)
                    if (
                        cord &lt; 256
                        and asciiencodable[cord]
                        and not (always_escape and c in always_escape)
                    ):
                        i += 1
                    else:
                        break
                chunks.append(str(s[j:i]))
            elif c in revesc:
                # Has a shortcut escape sequence, like &#34;\n&#34;
                chunks.append(revesc[c])
                i += 1
            elif cord &lt;= 0x1F:
                # Always unicode escape ASCII-control characters
                chunks.append(r&#34;\u%04x&#34; % cord)
                i += 1
            elif 0xD800 &lt;= cord &lt;= 0xDFFF:
                # A raw surrogate character!
                # This should ONLY happen in &#34;narrow&#34; Python builds
                # where (sys.maxunicode == 65535) as Python itself
                # uses UTF-16.  But for &#34;wide&#34; Python builds, a raw
                # surrogate should never happen.
                handled_raw_surrogates = False
                if (
                    sys.maxunicode == 0xFFFF
                    and 0xD800 &lt;= cord &lt;= 0xDBFF
                    and (i + 1) &lt; imax
                ):
                    # In a NARROW Python, output surrogate pair as-is
                    hsurrogate = cord
                    i += 1
                    if tochar:
                        c = tochar(s[i])
                    else:
                        c = s[i]
                    cord = ord(c)
                    i += 1
                    if 0xDC00 &lt;= cord &lt;= 0xDFFF:
                        lsurrogate = cord
                        chunks.append(r&#34;\u%04x\u%04x&#34; % (hsurrogate, lsurrogate))
                        handled_raw_surrogates = True
                if not handled_raw_surrogates:
                    cname = &#34;U+%04X&#34; % cord
                    raise JSONEncodeError(
                        &#34;can not include or escape a Unicode surrogate character&#34;, cname
                    )
            elif cord &lt;= 0xFFFF:
                # Other BMP Unicode character
                if always_escape and c in always_escape:
                    doesc = True
                elif unicodedata.category(c) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]:
                    doesc = True
                elif callable(encunicode):
                    doesc = encunicode(c)
                else:
                    doesc = encunicode

                if doesc:
                    if c in optrevesc:
                        chunks.append(optrevesc[c])
                    else:
                        chunks.append(r&#34;\u%04x&#34; % cord)
                else:
                    chunks.append(c)
                i += 1
            else:  # ord(c) &gt;= 0x10000
                # Non-BMP Unicode
                if always_escape and c in always_escape:
                    doesc = True
                elif unicodedata.category(c) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]:
                    doesc = True
                elif callable(encunicode):
                    doesc = encunicode(c)
                else:
                    doesc = encunicode

                if doesc:
                    for surrogate in helpers.unicode_as_surrogate_pair(c):
                        chunks.append(r&#34;\u%04x&#34; % ord(surrogate))
                else:
                    chunks.append(c)
                i += 1

        chunks.append(&#39;&#34;&#39;)
        state.append(&#34;&#34;.join(chunks))

    def decode_identifier(self, state, identifier_as_string=False):
        &#34;&#34;&#34;Decodes an identifier/keyword.&#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)
        start_position = buf.position
        obj = None

        kw = buf.pop_identifier()

        if not kw:
            state.push_error(&#34;Expected an identifier&#34;, position=start_position)
        elif kw == &#34;null&#34;:
            obj = None
            state.stats.num_nulls += 1
        elif kw == &#34;true&#34;:
            obj = True
            state.stats.num_bools += 1
        elif kw == &#34;false&#34;:
            obj = False
            state.stats.num_bools += 1
        elif kw == &#34;undefined&#34;:
            state.push_cond(
                self.options.undefined_values,
                &#34;Strict JSON does not allow the &#39;undefined&#39; keyword&#34;,
                kw,
                position=start_position,
            )
            obj = undefined
            state.stats.num_undefineds += 1
        elif kw == &#34;NaN&#34; or kw == &#34;Infinity&#34;:
            state.push_cond(
                self.options.non_numbers,
                &#34;%s literals are not allowed in strict JSON&#34; % kw,
                kw,
                position=start_position,
            )
            if self.has_hook(&#34;decode_float&#34;):
                try:
                    val = self.call_hook(&#34;decode_float&#34;, kw, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    return undefined
                else:
                    return val
            elif self.has_hook(&#34;decode_number&#34;):
                try:
                    val = self.call_hook(&#34;decode_number&#34;, kw, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    return undefined
                else:
                    return val
            if kw == &#34;NaN&#34;:
                state.stats.num_nans += 1
                obj = state.options.nan
            else:
                state.stats.num_infinities += 1
                obj = state.options.inf
        else:
            # Convert unknown identifiers into strings
            if identifier_as_string:
                if kw in helpers.javascript_reserved_words:
                    state.push_warning(
                        &#34;Identifier is a JavaScript reserved word&#34;,
                        kw,
                        position=start_position,
                    )
                state.push_cond(
                    self.options.identifier_keys,
                    &#34;JSON does not allow identifiers to be used as strings&#34;,
                    kw,
                    position=start_position,
                )
                state.stats.num_identifiers += 1
                obj = self.decode_javascript_identifier(kw)
            else:
                state.push_error(&#34;Unknown identifier&#34;, kw, position=start_position)
                obj = undefined
                state.stats.num_identifiers += 1
        return obj

    def skip_comment(self, state):
        &#34;&#34;&#34;Skips an ECMAScript comment, either // or /* style.

        The contents of the comment are returned as a string, as well
        as the index of the character immediately after the comment.

        &#34;&#34;&#34;
        buf = state.buf
        uniws = self.options.unicode_whitespace
        s = buf.peekstr(2)
        if s != &#34;//&#34; and s != &#34;/*&#34;:
            return None
        state.push_cond(
            self.options.comments, &#34;Comments are not allowed in strict JSON&#34;
        )
        start_position = buf.position
        buf.skip(2)
        multiline = s == &#34;/*&#34;
        saw_close = False
        while not buf.at_end:
            if multiline:
                if buf.peekstr(2) == &#34;*/&#34;:
                    buf.skip(2)
                    saw_close = True
                    break
                elif buf.peekstr(2) == &#34;/*&#34;:
                    state.push_error(
                        &#34;Multiline /* */ comments may not nest&#34;,
                        outer_position=start_position,
                        context=&#34;Comment&#34;,
                    )
            else:
                if buf.at_eol(uniws):
                    buf.skip_to_next_line(uniws)
                    saw_close = True
                    break
            buf.pop()

        if not saw_close and multiline:
            state.push_error(
                &#34;Comment was never terminated&#34;,
                outer_position=start_position,
                context=&#34;Comment&#34;,
            )
        state.stats.num_comments += 1

    def skipws_nocomments(self, state):
        &#34;&#34;&#34;Skips whitespace (will not allow comments).&#34;&#34;&#34;
        return state.buf.skipws(not self.options.is_forbid_unicode_whitespace)

    def skipws(self, state):
        &#34;&#34;&#34;Skips all whitespace, including comments and unicode whitespace

        Takes a string and a starting index, and returns the index of the
        next non-whitespace character.

        If the &#39;skip_comments&#39; behavior is True and not running in
        strict JSON mode, then comments will be skipped over just like
        whitespace.

        &#34;&#34;&#34;
        buf = state.buf
        uniws = not self.options.unicode_whitespace
        while not buf.at_end:
            c = buf.peekstr(2)
            if c == &#34;/*&#34; or c == &#34;//&#34;:
                cmt = self.skip_comment(state)
            elif buf.at_ws(uniws):
                buf.skipws(uniws)
            else:
                break

    def decode_composite(self, state):
        &#34;&#34;&#34;Intermediate-level JSON decoder for composite literal types (array and object).&#34;&#34;&#34;
        if state.should_stop:
            return None
        buf = state.buf
        self.skipws(state)
        opener = buf.peek()
        if opener not in &#34;{[&#34;:
            state.push_error(&#39;Composite data must start with &#34;[&#34; or &#34;{&#34;&#39;)
            return None
        start_position = buf.position
        buf.skip()
        if opener == &#34;[&#34;:
            isdict = False
            closer = &#34;]&#34;
            obj = []
        else:
            isdict = True
            closer = &#34;}&#34;
            if state.options.sort_keys == SORT_PRESERVE and _OrderedDict:
                obj = _OrderedDict()
            else:
                obj = {}
        num_items = 0
        self.skipws(state)

        c = buf.peek()
        if c == closer:
            # empty composite
            buf.skip()
            done = True
        else:
            saw_value = False  # set to false at beginning and after commas
            done = False
            while not done and not buf.at_end and not state.should_stop:
                self.skipws(state)
                c = buf.peek()
                if c == &#34;&#34;:
                    break  # will report error futher down because done==False
                elif c == &#34;,&#34;:
                    if not saw_value:
                        # no preceeding value, an elided (omitted) element
                        if isdict:
                            state.push_error(
                                &#34;Can not omit elements of an object (dictionary)&#34;,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        else:
                            state.push_cond(
                                self.options.omitted_array_elements,
                                &#34;Can not omit elements of an array (list)&#34;,
                                outer_position=start_position,
                                context=&#34;Array&#34;,
                            )
                            obj.append(undefined)
                            if state.stats:
                                state.stats.num_undefineds += 1
                    buf.skip()  # skip over comma
                    saw_value = False
                    continue
                elif c == closer:
                    if not saw_value:
                        if isdict:
                            state.push_cond(
                                self.options.trailing_comma,
                                &#34;Strict JSON does not allow a final comma in an object (dictionary) literal&#34;,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        else:
                            state.push_cond(
                                self.options.trailing_comma,
                                &#34;Strict JSON does not allow a final comma in an array (list) literal&#34;,
                                outer_position=start_position,
                                context=&#34;Array&#34;,
                            )
                    buf.skip()  # skip over closer
                    done = True
                    break
                elif c in &#34;]}&#34;:
                    if isdict:
                        cdesc = &#34;Object&#34;
                    else:
                        cdesc = &#34;Array&#34;
                    state.push_error(
                        &#34;Expected a &#39;%c&#39; but saw &#39;%c&#39;&#34; % (closer, c),
                        outer_position=start_position,
                        context=cdesc,
                    )
                    done = True
                    break

                if state.should_stop:
                    break

                # Decode the item/value
                value_position = buf.position

                if isdict:
                    val = self.decodeobj(state, identifier_as_string=True)
                else:
                    val = self.decodeobj(state, identifier_as_string=False)

                if val is syntax_error:
                    recover_c = self.recover_parser(state)
                    if recover_c not in &#34;:&#34;:
                        continue

                if state.should_stop:
                    break

                if saw_value:
                    # Two values without a separating comma
                    if isdict:
                        cdesc = &#34;Object&#34;
                    else:
                        cdesc = &#34;Array&#34;
                    state.push_error(
                        &#34;Values must be separated by a comma&#34;,
                        position=value_position,
                        outer_position=start_position,
                        context=cdesc,
                    )

                saw_value = True
                self.skipws(state)

                if state.should_stop:
                    break

                if isdict:
                    skip_item = False
                    key = val  # Ref 11.1.5
                    key_position = value_position
                    if not helpers.isstringtype(key):
                        if helpers.isnumbertype(key):
                            state.push_cond(
                                self.options.nonstring_keys,
                                &#34;JSON only permits string literals as object properties (keys)&#34;,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        else:
                            state.push_error(
                                &#34;Object properties (keys) must be string literals, numbers, or identifiers&#34;,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                            skip_item = True
                    c = buf.peek()
                    if c != &#34;:&#34;:
                        state.push_error(
                            &#39;Missing value for object property, expected &#34;:&#34;&#39;,
                            position=value_position,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                    buf.skip()  # skip over colon
                    self.skipws(state)

                    rval = self.decodeobj(state)
                    self.skipws(state)
                    if not skip_item:
                        if key in obj:
                            state.push_cond(
                                self.options.duplicate_keys,
                                &#34;Object contains duplicate key&#34;,
                                key,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        if key == &#34;&#34;:
                            state.push_cond(
                                self.options.non_portable,
                                &#39;Using an empty string &#34;&#34; as an object key may not be portable&#39;,
                                position=key_position,
                                outer_position=start_position,
                                context=&#34;Object&#34;,
                            )
                        obj[key] = rval
                        num_items += 1
                else:  # islist
                    obj.append(val)
                    num_items += 1
            # end while

        if state.stats:
            if isdict:
                state.stats.max_items_in_object = max(
                    state.stats.max_items_in_object, num_items
                )
            else:
                state.stats.max_items_in_array = max(
                    state.stats.max_items_in_array, num_items
                )

        if state.should_stop:
            return obj

        # Make sure composite value is properly terminated
        if not done:
            if isdict:
                state.push_error(
                    &#34;Object literal (dictionary) is not terminated&#34;,
                    outer_position=start_position,
                    context=&#34;Object&#34;,
                )
            else:
                state.push_error(
                    &#34;Array literal (list) is not terminated&#34;,
                    outer_position=start_position,
                    context=&#34;Array&#34;,
                )

        # Update stats and run hooks
        if isdict:
            state.stats.num_objects += 1
            if self.has_hook(&#34;decode_object&#34;):
                try:
                    obj = self.call_hook(&#34;decode_object&#34;, obj, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    obj = undefined
        else:
            state.stats.num_arrays += 1
            if self.has_hook(&#34;decode_array&#34;):
                try:
                    obj = self.call_hook(&#34;decode_array&#34;, obj, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    obj = undefined
        return obj

    def decode_javascript_identifier(self, name):
        &#34;&#34;&#34;Convert a JavaScript identifier into a Python string object.

        This method can be overriden by a subclass to redefine how JavaScript
        identifiers are turned into Python objects.  By default this just
        converts them into strings.

        &#34;&#34;&#34;
        return name

    def decodeobj(self, state, identifier_as_string=False, at_document_start=False):
        &#34;&#34;&#34;Intermediate-level JSON decoder.

        Takes a string and a starting index, and returns a two-tuple consting
        of a Python object and the index of the next unparsed character.

        If there is no value at all (empty string, etc), then None is
        returned instead of a tuple.

        &#34;&#34;&#34;
        buf = state.buf
        obj = None
        self.skipws(state)
        if buf.at_end:
            state.push_error(&#34;Unexpected end of input&#34;)

        c = buf.peek()
        if c in &#34;{[&#34;:
            state.cur_depth += 1
            try:
                state.update_depth_stats()
                obj = self.decode_composite(state)
            finally:
                state.cur_depth -= 1
        else:
            if at_document_start:
                state.push_cond(
                    self.options.any_type_at_start,
                    &#34;JSON document must start with an object or array type only&#34;,
                )
            if c in self._string_quotes:
                obj = self.decode_string(state)
            elif c.isdigit() or c in &#34;.+-&#34;:
                obj = self.decode_number(state)
            elif c.isalpha() or c in &#34;_$&#34;:
                obj = self.decode_identifier(
                    state, identifier_as_string=identifier_as_string
                )
            else:
                state.push_error(&#34;Can not decode value starting with character %r&#34; % c)
                buf.skip()
                self.recover_parser(state)
                obj = syntax_error
        return obj

    def decode(self, txt, encoding=None, return_errors=False, return_stats=False):
        &#34;&#34;&#34;Decodes a JSON-encoded string into a Python object.

        The &#39;return_errors&#39; parameter controls what happens if the
        input JSON has errors in it.

            * False: the first error will be raised as a Python
              exception. If there are no errors then the corresponding
              Python object will be returned.

            * True: the return value is always a 2-tuple: (object, error_list)

        &#34;&#34;&#34;
        import sys

        state = decode_state(options=self.options)

        # Prepare the input
        state.set_input(txt, encoding=encoding)

        # Do the decoding
        if not state.has_errors:
            self.__sanity_check_start(state)

        if not state.has_errors:
            try:
                self._do_decode(state)  # DECODE!
            except JSONException as err:
                state.push_exception(err)
            except Exception as err:  # Mainly here to catch maximum recursion depth exceeded
                newerr = JSONDecodeError(
                    &#34;An unexpected failure occured&#34;,
                    severity=&#34;fatal&#34;,
                    position=state.buf.position,
                )
                try:
                    raise newerr from err
                except Exception as err:
                    state.push_exception(newerr)

        if return_stats and state.buf:
            state.stats.num_excess_whitespace = state.buf.num_ws_skipped
            state.stats.total_chars = state.buf.position.char_position

        # Handle the errors
        result_type = _namedtuple(&#34;json_results&#34;, [&#34;object&#34;, &#34;errors&#34;, &#34;stats&#34;])

        if return_errors:
            if return_stats:
                return result_type(state.obj, state.errors, state.stats)
            else:
                return result_type(state.obj, state.errors, None)
        else:
            # Don&#39;t cause warnings to raise an error
            errors = [err for err in state.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)]
            if errors:
                raise errors[0]
            if return_stats:
                return result_type(state.obj, None, state.stats)
            else:
                return state.obj

    def __sanity_check_start(self, state):
        &#34;&#34;&#34;Check that the document seems sane by looking at the first couple characters.

        Check that the decoding seems sane.  Per RFC 4627 section 3:
            &#34;Since the first two characters of a JSON text will
             always be ASCII characters [RFC0020], ...&#34;
        [WAS removed from RFC 7158, but still valid via the grammar.]

        This check is probably not necessary, but it allows us to
        raise a suitably descriptive error rather than an obscure
        syntax error later on.

        Note that the RFC requirements of two ASCII characters seems
        to be an incorrect statement as a JSON string literal may have
        as it&#39;s first character any unicode character.  Thus the first
        two characters will always be ASCII, unless the first
        character is a quotation mark.  And in non-strict mode we can
        also have a few other characters too.

        &#34;&#34;&#34;
        is_sane = True
        unitxt = state.buf.peekstr(2)
        if len(unitxt) &gt;= 2:
            first, second = unitxt[:2]
            if first in self._string_quotes:
                pass  # second can be anything inside string literal
            else:
                if (
                    (ord(first) &lt; 0x20 or ord(first) &gt; 0x7F)
                    or (ord(second) &lt; 0x20 or ord(second) &gt; 0x7F)
                ) and (not self.isws(first) and not self.isws(second)):
                    # Found non-printable ascii, must check unicode
                    # categories to see if the character is legal.
                    # Only whitespace, line and paragraph separators,
                    # and format control chars are legal here.
                    import unicodedata

                    catfirst = unicodedata.category(str(first))
                    catsecond = unicodedata.category(str(second))
                    if catfirst not in (&#34;Zs&#34;, &#34;Zl&#34;, &#34;Zp&#34;, &#34;Cf&#34;) or catsecond not in (
                        &#34;Zs&#34;,
                        &#34;Zl&#34;,
                        &#34;Zp&#34;,
                        &#34;Cf&#34;,
                    ):
                        state.push_fatal(
                            &#34;The input is gibberish, is the Unicode encoding correct?&#34;
                        )
        return is_sane

    def _do_decode(self, state):
        &#34;&#34;&#34;This is the internal function that does the JSON decoding.

        Called by the decode() method, after it has performed any Unicode decoding, etc.
        &#34;&#34;&#34;
        buf = state.buf
        self.skipws(state)

        if buf.at_end:
            state.push_error(&#34;No value to decode&#34;)
        else:
            if state.options.decimal_context:
                dec_ctx = decimal.localcontext(state.options.decimal_context)
            else:
                dec_ctx = _dummy_context_manager

            with dec_ctx:
                state.obj = self.decodeobj(state, at_document_start=True)

            if not state.should_stop:
                # Make sure there&#39;s nothing at the end
                self.skipws(state)
                if not buf.at_end:
                    state.push_error(&#34;Unexpected text after end of JSON value&#34;)

    def _classify_for_encoding(self, obj):
        import datetime

        c = &#34;other&#34;
        if obj is None:
            c = &#34;null&#34;
        elif obj is undefined:
            c = &#34;undefined&#34;
        elif isinstance(obj, bool):
            c = &#34;bool&#34;
        elif isinstance(obj, (int, float, complex)) or (
            decimal and isinstance(obj, decimal.Decimal)
        ):
            c = &#34;number&#34;
        elif isinstance(obj, str) or helpers.isstringtype(obj):
            c = &#34;string&#34;
        else:
            if isinstance(obj, dict):
                c = &#34;dict&#34;
            elif (
                isinstance(obj, tuple)
                and hasattr(obj, &#34;_asdict&#34;)
                and callable(obj._asdict)
            ):
                # Have a named tuple
                enc_nt = self.options.encode_namedtuple_as_object
                if enc_nt and (enc_nt is True or (callable(enc_nt) and enc_nt(obj))):
                    c = &#34;namedtuple&#34;
                else:
                    c = &#34;sequence&#34;
            elif isinstance(obj, (list, tuple, set, frozenset)):
                c = &#34;sequence&#34;
            elif hasattr(obj, &#34;iterkeys&#34;) or (
                hasattr(obj, &#34;__getitem__&#34;) and hasattr(obj, &#34;keys&#34;)
            ):
                c = &#34;dict&#34;
            elif isinstance(obj, datetime.datetime):
                # Check datetime before date because it is a subclass!
                c = &#34;datetime&#34;
            elif isinstance(obj, datetime.date):
                c = &#34;date&#34;
            elif isinstance(obj, datetime.time):
                c = &#34;time&#34;
            elif isinstance(obj, datetime.timedelta):
                c = &#34;timedelta&#34;
            elif _py_major &gt;= 3 and isinstance(obj, (bytes, bytearray)):
                c = &#34;bytes&#34;
            elif _py_major &gt;= 3 and isinstance(obj, memoryview):
                c = &#34;memoryview&#34;
            elif _enum is not None and isinstance(obj, _enum):
                c = &#34;enum&#34;
            else:
                c = &#34;other&#34;
        return c

    def encode(self, obj, encoding=None):
        &#34;&#34;&#34;Encodes the Python object into a JSON string representation.

        This method will first attempt to encode an object by seeing
        if it has a json_equivalent() method.  If so than it will
        call that method and then recursively attempt to encode
        the object resulting from that call.

        Next it will attempt to determine if the object is a native
        type or acts like a squence or dictionary.  If so it will
        encode that object directly.

        Finally, if no other strategy for encoding the object of that
        type exists, it will call the encode_default() method.  That
        method currently raises an error, but it could be overridden
        by subclasses to provide a hook for extending the types which
        can be encoded.

        &#34;&#34;&#34;
        import sys, codecs

        # Make a fresh encoding state
        state = encode_state(self.options)

        # Find the codec to use. CodecInfo will be in &#39;cdk&#39; and name in &#39;encoding&#39;.
        #
        # Also set the state&#39;s &#39;escape_unicode_test&#39; property which is used to
        # determine what characters to \u-escape.
        if encoding is None:
            cdk = None
        elif isinstance(encoding, codecs.CodecInfo):
            cdk = encoding
            encoding = cdk.name
        else:
            cdk = helpers.lookup_codec(encoding)
            if not cdk:
                raise JSONEncodeError(
                    &#34;no codec available for character encoding&#34;, encoding
                )

        if self.options.escape_unicode and callable(self.options.escape_unicode):
            # User-supplied repertoire test function
            state.escape_unicode_test = self.options.escape_unicode
        else:
            if (
                self.options.escape_unicode == True
                or not cdk
                or cdk.name.lower() == &#34;ascii&#34;
            ):
                # ASCII, ISO8859-1, or and Unknown codec -- \u escape anything not ASCII
                state.escape_unicode_test = lambda c: ord(c) &gt;= 0x80
            elif cdk.name == &#34;iso8859-1&#34;:
                state.escape_unicode_test = lambda c: ord(c) &gt;= 0x100
            elif cdk and cdk.name.lower().startswith(&#34;utf&#34;):
                # All UTF-x encodings can do the whole Unicode repertoire, so
                # do nothing special.
                state.escape_unicode_test = False
            else:
                # An unusual codec.  We need to test every character
                # to see if it is in the codec&#39;s repertoire to determine
                # if we should \u escape that character.
                enc_func = cdk.encode

                def escape_unicode_hardway(c):
                    try:
                        enc_func(c)
                    except UnicodeEncodeError:
                        return True
                    else:
                        return False

                state.escape_unicode_test = escape_unicode_hardway

        # Make sure the encoding is not degenerate: it can encode the minimal
        # number of characters needed by the JSON syntax rules.
        if encoding is not None:
            try:
                output, nchars = cdk.encode(JSON.json_syntax_characters)
            except UnicodeError as err:
                raise JSONEncodeError(
                    &#34;Output encoding %s is not sufficient to encode JSON&#34; % cdk.name
                )

        # Do the JSON encoding!
        self._do_encode(obj, state)
        if not self.options.encode_compactly:
            state.append(&#34;\n&#34;)
        unitxt = state.combine()

        # Do the final Unicode encoding
        if encoding is None:
            output = unitxt
        else:
            try:
                output, nchars = cdk.encode(unitxt)
            except UnicodeEncodeError as err:
                # Re-raise as a JSONDecodeError
                newerr = JSONEncodeError(&#34;a Unicode encoding error occurred&#34;)
                raise newerr from err
        return output

    def _do_encode(self, obj, state):
        &#34;&#34;&#34;Internal encode function.&#34;&#34;&#34;
        obj_classification = self._classify_for_encoding(obj)

        if self.has_hook(&#34;encode_value&#34;):
            orig_obj = obj
            try:
                obj = self.call_hook(&#34;encode_value&#34;, obj)
            except JSONSkipHook:
                pass

            if obj is not orig_obj:
                prev_cls = obj_classification
                obj_classification = self._classify_for_encoding(obj)
                if obj_classification != prev_cls:
                    # Got a different type of object, re-encode again
                    self._do_encode(obj, state)
                    return

        if hasattr(obj, &#34;json_equivalent&#34;):
            success = self.encode_equivalent(obj, state)
            if success:
                return

        if obj_classification == &#34;null&#34;:
            self.encode_null(state)
        elif obj_classification == &#34;undefined&#34;:
            if not self.options.is_forbid_undefined_values:
                self.encode_undefined(state)
            else:
                raise JSONEncodeError(&#39;strict JSON does not permit &#34;undefined&#34; values&#39;)
        elif obj_classification == &#34;bool&#34;:
            self.encode_boolean(obj, state)
        elif obj_classification == &#34;number&#34;:
            try:
                self.encode_number(obj, state)
            except JSONEncodeError as err1:
                # Bad number, probably a complex with non-zero imaginary part.
                # Let the default encoders take a shot at encoding.
                try:
                    self.try_encode_default(obj, state)
                except Exception as err2:
                    # Default handlers couldn&#39;t deal with it, re-raise original exception.
                    raise err1
        elif obj_classification == &#34;string&#34;:
            self.encode_string(obj, state)
        elif obj_classification == &#34;enum&#34;:  # Python 3.4 enum.Enum
            self.encode_enum(obj, state)
        elif obj_classification == &#34;datetime&#34;:  # Python datetime.datetime
            self.encode_datetime(obj, state)
        elif obj_classification == &#34;date&#34;:  # Python datetime.date
            self.encode_date(obj, state)
        elif obj_classification == &#34;time&#34;:  # Python datetime.time
            self.encode_time(obj, state)
        elif obj_classification == &#34;timedelta&#34;:  # Python datetime.time
            self.encode_timedelta(obj, state)
        else:
            # Anything left is probably composite, or an unconvertable type.
            self.encode_composite(obj, state)

    def encode_enum(self, val, state):
        &#34;&#34;&#34;Encode a Python Enum value into JSON.&#34;&#34;&#34;
        eas = self.options.encode_enum_as
        if eas == &#34;qname&#34;:
            self.encode_string(str(val), state)
        elif eas == &#34;value&#34;:
            self._do_encode(val.value, state)
        else:  # eas == &#39;name&#39;
            self.encode_string(val.name, state)

    def encode_date(self, dt, state):
        fmt = self.options.date_format
        if not fmt or fmt == &#34;iso&#34;:
            fmt = &#34;%Y-%m-%d&#34;
        self.encode_string(dt.strftime(fmt), state)

    def encode_datetime(self, dt, state):
        fmt = self.options.datetime_format
        is_iso = not fmt or fmt == &#34;iso&#34;
        if is_iso:
            if dt.microsecond == 0:
                fmt = &#34;%Y-%m-%dT%H:%M:%S%z&#34;
            else:
                fmt = &#34;%Y-%m-%dT%H:%M:%S.%f%z&#34;
        s = dt.strftime(fmt)
        if is_iso and s.endswith(&#34;-00:00&#34;) or s.endswith(&#34;+00:00&#34;):
            s = s[:-6] + &#34;Z&#34;  # Change UTC to use &#39;Z&#39; notation
        self.encode_string(s, state)

    def encode_time(self, t, state):
        fmt = self.options.datetime_format
        is_iso = not fmt or fmt == &#34;iso&#34;
        if is_iso:
            if t.microsecond == 0:
                fmt = &#34;T%H:%M:%S%z&#34;
            else:
                fmt = &#34;T%H:%M:%S.%f%z&#34;
        s = t.strftime(fmt)
        if is_iso and s.endswith(&#34;-00:00&#34;) or s.endswith(&#34;+00:00&#34;):
            s = s[:-6] + &#34;Z&#34;  # Change UTC to use &#39;Z&#39; notation
        self.encode_string(s, state)

    def encode_timedelta(self, td, state):
        fmt = self.options.timedelta_format
        if not fmt or fmt == &#34;iso&#34;:
            s = helpers.format_timedelta_iso(td)
        elif fmt == &#34;hms&#34;:
            s = str(td)
        else:
            raise ValueError(&#34;Unknown timedelta_format %r&#34; % fmt)
        self.encode_string(s, state)

    def encode_composite(self, obj, state, obj_classification=None):
        &#34;&#34;&#34;Encodes just composite objects: dictionaries, lists, or sequences.

        Basically handles any python type for which iter() can create
        an iterator object.

        This method is not intended to be called directly.  Use the
        encode() method instead.

        &#34;&#34;&#34;
        import sys

        if not obj_classification:
            obj_classification = self._classify_for_encoding(obj)

        # Convert namedtuples to dictionaries
        if obj_classification == &#34;namedtuple&#34;:
            obj = obj._asdict()
            obj_classification = &#34;dict&#34;

        # Convert &#39;unsigned byte&#39; memory views into plain bytes
        if obj_classification == &#34;memoryview&#34; and obj.format == &#34;B&#34;:
            obj = obj.tobytes()
            obj_classification = &#34;bytes&#34;

        # Run hooks
        hook_name = None
        if obj_classification == &#34;dict&#34;:
            hook_name = &#34;encode_dict&#34;
        elif obj_classification == &#34;sequence&#34;:
            hook_name = &#34;encode_sequence&#34;
        elif obj_classification == &#34;bytes&#34;:
            hook_name = &#34;encode_bytes&#34;

        if self.has_hook(hook_name):
            try:
                new_obj = self.call_hook(hook_name, obj)
            except JSONSkipHook:
                pass
            else:
                if new_obj is not obj:
                    obj = new_obj
                    prev_cls = obj_classification
                    obj_classification = self._classify_for_encoding(obj)
                    if obj_classification != prev_cls:
                        # Transformed to a different kind of object, call
                        # back to the general encode() method.
                        self._do_encode(obj, state)
                        return
                    # Else, fall through

        # At his point we have decided to do with an object or an array
        isdict = obj_classification == &#34;dict&#34;

        # Get iterator
        it = None
        if isdict and hasattr(obj, &#34;iterkeys&#34;):
            try:
                it = iter(obj.keys())
            except AttributeError:
                pass
        else:
            try:
                it = iter(obj)
            except TypeError:
                pass

        # Convert each member to JSON
        if it is not None:
            # Try to get length, but don&#39;t fail if we can&#39;t
            try:
                numitems = len(obj)
            except TypeError:
                numitems = 0

            # Output the opening bracket or brace
            compactly = self.options.encode_compactly
            if not compactly:
                indent0 = self.options.indentation_for_level(state.nest_level)
                indent = self.options.indentation_for_level(state.nest_level + 1)

            spaces_after_opener = &#34;&#34;
            if isdict:
                opener = &#34;{&#34;
                closer = &#34;}&#34;
                if compactly:
                    dictcolon = &#34;:&#34;
                else:
                    dictcolon = &#34; : &#34;
            else:
                opener = &#34;[&#34;
                closer = &#34;]&#34;
            if not compactly:
                # opener = opener + &#39; &#39;
                spaces_after_opener = self.options.spaces_to_next_indent_level(
                    subtract=len(opener)
                )

            state.append(opener)
            state.append(spaces_after_opener)

            # Now iterate through all the items and collect their representations
            parts = []  # Collects each of the members
            part_keys = []  # For dictionary key sorting, tuples (key,index)

            try:  # while not StopIteration
                part_idx = 0
                while True:
                    obj2 = next(it)
                    part_idx += 1  # Note, will start counting at 1
                    if obj2 is obj:
                        raise JSONEncodeError(
                            &#34;trying to encode an infinite sequence&#34;, obj
                        )
                    if isdict:
                        obj3 = obj[obj2]
                        # Dictionary key is in obj2 and value in obj3.

                        # Let any hooks transform the key.
                        if self.has_hook(&#34;encode_value&#34;):
                            try:
                                newobj = self.call_hook(&#34;encode_value&#34;, obj2)
                            except JSONSkipHook:
                                pass
                            else:
                                obj2 = newobj
                        if self.has_hook(&#34;encode_dict_key&#34;):
                            try:
                                newkey = self.call_hook(&#34;encode_dict_key&#34;, obj2)
                            except JSONSkipHook:
                                pass
                            else:
                                obj2 = newkey

                        # Check JSON restrictions on key types
                        if not helpers.isstringtype(obj2):
                            if helpers.isnumbertype(obj2):
                                if not self.options.is_allow_nonstring_keys:
                                    raise JSONEncodeError(
                                        &#34;object properties (dictionary keys) must be strings in strict JSON&#34;,
                                        obj2,
                                    )
                            else:
                                raise JSONEncodeError(
                                    &#34;object properties (dictionary keys) can only be strings or numbers in ECMAScript&#34;,
                                    obj2,
                                )
                        part_keys.append((obj2, part_idx - 1))

                    # Encode this item in the sequence and put into item_chunks
                    substate = state.make_substate()
                    self._do_encode(obj2, substate)
                    if isdict:
                        substate.append(dictcolon)
                        substate2 = substate.make_substate()
                        self._do_encode(obj3, substate2)
                        substate.join_substate(substate2)
                    parts.append(substate)
                # Next item iteration
            except StopIteration:
                pass

            # Sort dictionary keys
            if isdict:
                srt = self.options.sort_keys
                if srt == SORT_PRESERVE:
                    if _OrderedDict and isinstance(obj, _OrderedDict):
                        srt = SORT_NONE  # Will keep order
                    else:
                        srt = SORT_SMART

                if not srt or srt in (SORT_NONE, SORT_PRESERVE):
                    srt = None
                elif callable(srt):
                    part_keys.sort(key=(lambda t: (srt(t[0]), t[0])))
                elif srt == SORT_SMART:
                    part_keys.sort(key=(lambda t: (smart_sort_transform(t[0]), t[0])))
                elif srt == SORT_ALPHA_CI:
                    part_keys.sort(key=(lambda t: (str(t[0]).upper(), t[0])))
                elif srt or srt == SORT_ALPHA:
                    part_keys.sort(key=(lambda t: str(t[0])))
                # Now make parts match the new sort order
                if srt is not None:
                    parts = [parts[pk[1]] for pk in part_keys]

            if compactly:
                sep = &#34;,&#34;
            elif len(parts) &lt;= self.options.max_items_per_line:
                sep = &#34;, &#34;
            else:
                # state.append(spaces_after_opener)
                state.append(&#34;\n&#34; + indent)
                sep = &#34;,\n&#34; + indent

            for pnum, substate in enumerate(parts):
                if pnum &gt; 0:
                    state.append(sep)
                state.join_substate(substate)

            if not compactly:
                if numitems &gt; self.options.max_items_per_line:
                    state.append(&#34;\n&#34; + indent0)
                else:
                    state.append(&#34; &#34;)
            state.append(closer)  # final &#39;}&#39; or &#39;]&#39;
        else:  # Can&#39;t create an iterator for the object
            self.try_encode_default(obj, state)

    def encode_equivalent(self, obj, state):
        &#34;&#34;&#34;This method is used to encode user-defined class objects.

        The object being encoded should have a json_equivalent()
        method defined which returns another equivalent object which
        is easily JSON-encoded.  If the object in question has no
        json_equivalent() method available then None is returned
        instead of a string so that the encoding will attempt the next
        strategy.

        If a caller wishes to disable the calling of json_equivalent()
        methods, then subclass this class and override this method
        to just return None.

        &#34;&#34;&#34;
        if hasattr(obj, &#34;json_equivalent&#34;) and callable(
            getattr(obj, &#34;json_equivalent&#34;)
        ):
            obj2 = obj.json_equivalent()
            if obj2 is obj:
                # Try to prevent careless infinite recursion
                raise JSONEncodeError(
                    &#34;object has a json_equivalent() method that returns itself&#34;, obj
                )
            self._do_encode(obj2, state)
            return True
        else:
            return False

    def try_encode_default(self, obj, state):
        orig_obj = obj
        if self.has_hook(&#34;encode_default&#34;):
            try:
                obj = self.call_hook(&#34;encode_default&#34;, obj)
            except JSONSkipHook:
                pass
            else:
                if obj is not orig_obj:
                    # Hook made a transformation, re-encode it
                    return self._do_encode(obj, state)

        # End of the road.
        raise JSONEncodeError(&#34;can not encode object into a JSON representation&#34;, obj)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="demjson3.JSON.all_hook_names"><code class="name">var <span class="ident">all_hook_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.JSON.json_syntax_characters"><code class="name">var <span class="ident">json_syntax_characters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.JSON.options"><code class="name">var <span class="ident">options</span></code></dt>
<dd>
<div class="desc"><p>The optional behaviors used, e.g., the JSON conformance
strictness.
Returns an instance of json_options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def options(self):
    &#34;&#34;&#34;The optional behaviors used, e.g., the JSON conformance
    strictness.  Returns an instance of json_options.

    &#34;&#34;&#34;
    return self._options</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.JSON.call_hook"><code class="name flex">
<span>def <span class="ident">call_hook</span></span>(<span>self, hook_name, input_object, position=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper function to invoke a user-supplied hook function.</p>
<p>This will capture any exceptions raised by the hook and do something
appropriate with it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_hook(self, hook_name, input_object, position=None, *args, **kwargs):
    &#34;&#34;&#34;Wrapper function to invoke a user-supplied hook function.

    This will capture any exceptions raised by the hook and do something
    appropriate with it.

    &#34;&#34;&#34;
    import sys

    if hook_name not in self.all_hook_names:
        raise AttributeError(&#34;No such hook %r&#34; % hook_name)
    hook = getattr(self, hook_name + &#34;_hook&#34;)
    if not callable(hook):
        raise TypeError(&#34;Hook is not callable: %r&#34; % (hook,))
    try:
        rval = hook(input_object, *args, **kwargs)
    except JSONSkipHook:
        raise  # Do nothing
    except Exception as err:
        exc_info = sys.exc_info()
        if hook_name.startswith(&#34;encode_&#34;):
            ex_class = JSONEncodeHookError
        else:
            ex_class = JSONDecodeHookError

        if isinstance(err, JSONStopProcessing):
            severity = &#34;fatal&#34;
        else:
            severity = &#34;error&#34;

        newerr = ex_class(
            hook_name,
            exc_info,
            input_object,
            *args,
            position=position,
            severity=severity
        )

        # Simulate Python 3&#39;s: &#34;raise X from Y&#34; exception chaining
        newerr.__cause__ = err
        newerr.__traceback__ = exc_info[2]
        raise newerr
    return rval</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.clear_all_hooks"><code class="name flex">
<span>def <span class="ident">clear_all_hooks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsets all hook callbacks, as previously set with set_hook().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_all_hooks(self):
    &#34;&#34;&#34;Unsets all hook callbacks, as previously set with set_hook().&#34;&#34;&#34;
    for hookname in self.all_hook_names:
        self.clear_hook(hookname)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.clear_hook"><code class="name flex">
<span>def <span class="ident">clear_hook</span></span>(<span>self, hookname)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsets a hook callback, as previously set with set_hook().</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_hook(self, hookname):
    &#34;&#34;&#34;Unsets a hook callback, as previously set with set_hook().&#34;&#34;&#34;
    self.set_hook(hookname, None)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, txt, encoding=None, return_errors=False, return_stats=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a JSON-encoded string into a Python object.</p>
<p>The 'return_errors' parameter controls what happens if the
input JSON has errors in it.</p>
<pre><code>* False: the first error will be raised as a Python
  exception. If there are no errors then the corresponding
  Python object will be returned.

* True: the return value is always a 2-tuple: (object, error_list)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self, txt, encoding=None, return_errors=False, return_stats=False):
    &#34;&#34;&#34;Decodes a JSON-encoded string into a Python object.

    The &#39;return_errors&#39; parameter controls what happens if the
    input JSON has errors in it.

        * False: the first error will be raised as a Python
          exception. If there are no errors then the corresponding
          Python object will be returned.

        * True: the return value is always a 2-tuple: (object, error_list)

    &#34;&#34;&#34;
    import sys

    state = decode_state(options=self.options)

    # Prepare the input
    state.set_input(txt, encoding=encoding)

    # Do the decoding
    if not state.has_errors:
        self.__sanity_check_start(state)

    if not state.has_errors:
        try:
            self._do_decode(state)  # DECODE!
        except JSONException as err:
            state.push_exception(err)
        except Exception as err:  # Mainly here to catch maximum recursion depth exceeded
            newerr = JSONDecodeError(
                &#34;An unexpected failure occured&#34;,
                severity=&#34;fatal&#34;,
                position=state.buf.position,
            )
            try:
                raise newerr from err
            except Exception as err:
                state.push_exception(newerr)

    if return_stats and state.buf:
        state.stats.num_excess_whitespace = state.buf.num_ws_skipped
        state.stats.total_chars = state.buf.position.char_position

    # Handle the errors
    result_type = _namedtuple(&#34;json_results&#34;, [&#34;object&#34;, &#34;errors&#34;, &#34;stats&#34;])

    if return_errors:
        if return_stats:
            return result_type(state.obj, state.errors, state.stats)
        else:
            return result_type(state.obj, state.errors, None)
    else:
        # Don&#39;t cause warnings to raise an error
        errors = [err for err in state.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)]
        if errors:
            raise errors[0]
        if return_stats:
            return result_type(state.obj, None, state.stats)
        else:
            return state.obj</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode_boolean"><code class="name flex">
<span>def <span class="ident">decode_boolean</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Intermediate-level decode for JSON boolean literals.</p>
<p>Takes a string and a starting index, and returns a Python bool
(True or False) and the index of the next unparsed character.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_boolean(self, state):
    &#34;&#34;&#34;Intermediate-level decode for JSON boolean literals.

    Takes a string and a starting index, and returns a Python bool
    (True or False) and the index of the next unparsed character.

    &#34;&#34;&#34;
    buf = state.buf
    start_position = buf.position
    kw = buf.pop_identifier()
    if not kw or kw not in (&#34;true&#34;, &#34;false&#34;):
        state.push_error(
            &#34;Expected a &#39;true&#39; or &#39;false&#39; keyword&#39;&#34;, kw, position=start_position
        )
    else:
        state.stats.num_bools += 1
    return kw == &#34;true&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode_composite"><code class="name flex">
<span>def <span class="ident">decode_composite</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Intermediate-level JSON decoder for composite literal types (array and object).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_composite(self, state):
    &#34;&#34;&#34;Intermediate-level JSON decoder for composite literal types (array and object).&#34;&#34;&#34;
    if state.should_stop:
        return None
    buf = state.buf
    self.skipws(state)
    opener = buf.peek()
    if opener not in &#34;{[&#34;:
        state.push_error(&#39;Composite data must start with &#34;[&#34; or &#34;{&#34;&#39;)
        return None
    start_position = buf.position
    buf.skip()
    if opener == &#34;[&#34;:
        isdict = False
        closer = &#34;]&#34;
        obj = []
    else:
        isdict = True
        closer = &#34;}&#34;
        if state.options.sort_keys == SORT_PRESERVE and _OrderedDict:
            obj = _OrderedDict()
        else:
            obj = {}
    num_items = 0
    self.skipws(state)

    c = buf.peek()
    if c == closer:
        # empty composite
        buf.skip()
        done = True
    else:
        saw_value = False  # set to false at beginning and after commas
        done = False
        while not done and not buf.at_end and not state.should_stop:
            self.skipws(state)
            c = buf.peek()
            if c == &#34;&#34;:
                break  # will report error futher down because done==False
            elif c == &#34;,&#34;:
                if not saw_value:
                    # no preceeding value, an elided (omitted) element
                    if isdict:
                        state.push_error(
                            &#34;Can not omit elements of an object (dictionary)&#34;,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                    else:
                        state.push_cond(
                            self.options.omitted_array_elements,
                            &#34;Can not omit elements of an array (list)&#34;,
                            outer_position=start_position,
                            context=&#34;Array&#34;,
                        )
                        obj.append(undefined)
                        if state.stats:
                            state.stats.num_undefineds += 1
                buf.skip()  # skip over comma
                saw_value = False
                continue
            elif c == closer:
                if not saw_value:
                    if isdict:
                        state.push_cond(
                            self.options.trailing_comma,
                            &#34;Strict JSON does not allow a final comma in an object (dictionary) literal&#34;,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                    else:
                        state.push_cond(
                            self.options.trailing_comma,
                            &#34;Strict JSON does not allow a final comma in an array (list) literal&#34;,
                            outer_position=start_position,
                            context=&#34;Array&#34;,
                        )
                buf.skip()  # skip over closer
                done = True
                break
            elif c in &#34;]}&#34;:
                if isdict:
                    cdesc = &#34;Object&#34;
                else:
                    cdesc = &#34;Array&#34;
                state.push_error(
                    &#34;Expected a &#39;%c&#39; but saw &#39;%c&#39;&#34; % (closer, c),
                    outer_position=start_position,
                    context=cdesc,
                )
                done = True
                break

            if state.should_stop:
                break

            # Decode the item/value
            value_position = buf.position

            if isdict:
                val = self.decodeobj(state, identifier_as_string=True)
            else:
                val = self.decodeobj(state, identifier_as_string=False)

            if val is syntax_error:
                recover_c = self.recover_parser(state)
                if recover_c not in &#34;:&#34;:
                    continue

            if state.should_stop:
                break

            if saw_value:
                # Two values without a separating comma
                if isdict:
                    cdesc = &#34;Object&#34;
                else:
                    cdesc = &#34;Array&#34;
                state.push_error(
                    &#34;Values must be separated by a comma&#34;,
                    position=value_position,
                    outer_position=start_position,
                    context=cdesc,
                )

            saw_value = True
            self.skipws(state)

            if state.should_stop:
                break

            if isdict:
                skip_item = False
                key = val  # Ref 11.1.5
                key_position = value_position
                if not helpers.isstringtype(key):
                    if helpers.isnumbertype(key):
                        state.push_cond(
                            self.options.nonstring_keys,
                            &#34;JSON only permits string literals as object properties (keys)&#34;,
                            position=key_position,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                    else:
                        state.push_error(
                            &#34;Object properties (keys) must be string literals, numbers, or identifiers&#34;,
                            position=key_position,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                        skip_item = True
                c = buf.peek()
                if c != &#34;:&#34;:
                    state.push_error(
                        &#39;Missing value for object property, expected &#34;:&#34;&#39;,
                        position=value_position,
                        outer_position=start_position,
                        context=&#34;Object&#34;,
                    )
                buf.skip()  # skip over colon
                self.skipws(state)

                rval = self.decodeobj(state)
                self.skipws(state)
                if not skip_item:
                    if key in obj:
                        state.push_cond(
                            self.options.duplicate_keys,
                            &#34;Object contains duplicate key&#34;,
                            key,
                            position=key_position,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                    if key == &#34;&#34;:
                        state.push_cond(
                            self.options.non_portable,
                            &#39;Using an empty string &#34;&#34; as an object key may not be portable&#39;,
                            position=key_position,
                            outer_position=start_position,
                            context=&#34;Object&#34;,
                        )
                    obj[key] = rval
                    num_items += 1
            else:  # islist
                obj.append(val)
                num_items += 1
        # end while

    if state.stats:
        if isdict:
            state.stats.max_items_in_object = max(
                state.stats.max_items_in_object, num_items
            )
        else:
            state.stats.max_items_in_array = max(
                state.stats.max_items_in_array, num_items
            )

    if state.should_stop:
        return obj

    # Make sure composite value is properly terminated
    if not done:
        if isdict:
            state.push_error(
                &#34;Object literal (dictionary) is not terminated&#34;,
                outer_position=start_position,
                context=&#34;Object&#34;,
            )
        else:
            state.push_error(
                &#34;Array literal (list) is not terminated&#34;,
                outer_position=start_position,
                context=&#34;Array&#34;,
            )

    # Update stats and run hooks
    if isdict:
        state.stats.num_objects += 1
        if self.has_hook(&#34;decode_object&#34;):
            try:
                obj = self.call_hook(&#34;decode_object&#34;, obj, position=start_position)
            except JSONSkipHook:
                pass
            except JSONError as err:
                state.push_exception(err)
                obj = undefined
    else:
        state.stats.num_arrays += 1
        if self.has_hook(&#34;decode_array&#34;):
            try:
                obj = self.call_hook(&#34;decode_array&#34;, obj, position=start_position)
            except JSONSkipHook:
                pass
            except JSONError as err:
                state.push_exception(err)
                obj = undefined
    return obj</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode_identifier"><code class="name flex">
<span>def <span class="ident">decode_identifier</span></span>(<span>self, state, identifier_as_string=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes an identifier/keyword.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_identifier(self, state, identifier_as_string=False):
    &#34;&#34;&#34;Decodes an identifier/keyword.&#34;&#34;&#34;
    buf = state.buf
    self.skipws(state)
    start_position = buf.position
    obj = None

    kw = buf.pop_identifier()

    if not kw:
        state.push_error(&#34;Expected an identifier&#34;, position=start_position)
    elif kw == &#34;null&#34;:
        obj = None
        state.stats.num_nulls += 1
    elif kw == &#34;true&#34;:
        obj = True
        state.stats.num_bools += 1
    elif kw == &#34;false&#34;:
        obj = False
        state.stats.num_bools += 1
    elif kw == &#34;undefined&#34;:
        state.push_cond(
            self.options.undefined_values,
            &#34;Strict JSON does not allow the &#39;undefined&#39; keyword&#34;,
            kw,
            position=start_position,
        )
        obj = undefined
        state.stats.num_undefineds += 1
    elif kw == &#34;NaN&#34; or kw == &#34;Infinity&#34;:
        state.push_cond(
            self.options.non_numbers,
            &#34;%s literals are not allowed in strict JSON&#34; % kw,
            kw,
            position=start_position,
        )
        if self.has_hook(&#34;decode_float&#34;):
            try:
                val = self.call_hook(&#34;decode_float&#34;, kw, position=start_position)
            except JSONSkipHook:
                pass
            except JSONError as err:
                state.push_exception(err)
                return undefined
            else:
                return val
        elif self.has_hook(&#34;decode_number&#34;):
            try:
                val = self.call_hook(&#34;decode_number&#34;, kw, position=start_position)
            except JSONSkipHook:
                pass
            except JSONError as err:
                state.push_exception(err)
                return undefined
            else:
                return val
        if kw == &#34;NaN&#34;:
            state.stats.num_nans += 1
            obj = state.options.nan
        else:
            state.stats.num_infinities += 1
            obj = state.options.inf
    else:
        # Convert unknown identifiers into strings
        if identifier_as_string:
            if kw in helpers.javascript_reserved_words:
                state.push_warning(
                    &#34;Identifier is a JavaScript reserved word&#34;,
                    kw,
                    position=start_position,
                )
            state.push_cond(
                self.options.identifier_keys,
                &#34;JSON does not allow identifiers to be used as strings&#34;,
                kw,
                position=start_position,
            )
            state.stats.num_identifiers += 1
            obj = self.decode_javascript_identifier(kw)
        else:
            state.push_error(&#34;Unknown identifier&#34;, kw, position=start_position)
            obj = undefined
            state.stats.num_identifiers += 1
    return obj</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode_javascript_identifier"><code class="name flex">
<span>def <span class="ident">decode_javascript_identifier</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a JavaScript identifier into a Python string object.</p>
<p>This method can be overriden by a subclass to redefine how JavaScript
identifiers are turned into Python objects.
By default this just
converts them into strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_javascript_identifier(self, name):
    &#34;&#34;&#34;Convert a JavaScript identifier into a Python string object.

    This method can be overriden by a subclass to redefine how JavaScript
    identifiers are turned into Python objects.  By default this just
    converts them into strings.

    &#34;&#34;&#34;
    return name</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode_null"><code class="name flex">
<span>def <span class="ident">decode_null</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Intermediate-level decoder for ECMAScript 'null' keyword.</p>
<p>Takes a string and a starting index, and returns a Python
None object and the index of the next unparsed character.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_null(self, state):
    &#34;&#34;&#34;Intermediate-level decoder for ECMAScript &#39;null&#39; keyword.

    Takes a string and a starting index, and returns a Python
    None object and the index of the next unparsed character.

    &#34;&#34;&#34;
    buf = state.buf
    start_position = buf.position
    kw = buf.pop_identifier()
    if not kw or kw != &#34;null&#34;:
        state.push_error(&#34;Expected a &#39;null&#39; keyword&#39;&#34;, kw, position=start_position)
    else:
        state.stats.num_nulls += 1
    return None</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode_number"><code class="name flex">
<span>def <span class="ident">decode_number</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Intermediate-level decoder for JSON numeric literals.</p>
<p>Takes a string and a starting index, and returns a Python
suitable numeric type and the index of the next unparsed character.</p>
<p>The returned numeric type can be either of a Python int,
long, or float.
In addition some special non-numbers may
also be returned such as nan, inf, and neginf (technically
which are Python floats, but have no numeric value.)</p>
<p>Ref. ECMAScript section 8.5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_number(self, state):
    &#34;&#34;&#34;Intermediate-level decoder for JSON numeric literals.

    Takes a string and a starting index, and returns a Python
    suitable numeric type and the index of the next unparsed character.

    The returned numeric type can be either of a Python int,
    long, or float.  In addition some special non-numbers may
    also be returned such as nan, inf, and neginf (technically
    which are Python floats, but have no numeric value.)

    Ref. ECMAScript section 8.5.

    &#34;&#34;&#34;
    buf = state.buf
    self.skipws(state)
    start_position = buf.position

    # Use external number parser hook if available
    if self.has_hook(&#34;decode_number&#34;) or self.has_hook(&#34;decode_float&#34;):
        c = buf.peek()
        if c and c in &#34;-+0123456789.&#34;:  # First chars for a number-like value
            buf.save_position()
            nbr = buf.pop_while_in(&#34;-+0123456789abcdefABCDEF&#34; &#34;NaN&#34; &#34;Infinity.&#34;)
            if &#34;.&#34; in nbr and self.has_hook(&#34;decode_float&#34;):
                hook_name = &#34;decode_float&#34;
            elif self.has_hook(&#34;decode_number&#34;):
                hook_name = &#34;decode_number&#34;
            else:
                hook_name = None

            if hook_name:
                try:
                    val = self.call_hook(hook_name, nbr, position=start_position)
                except JSONSkipHook:
                    pass
                except JSONError as err:
                    state.push_exception(err)
                    val = undefined
                else:
                    buf.clear_saved_position()
                    return val
            # Hook didn&#39;t handle it, restore old position
            buf.restore_position()

    # Detect initial sign character(s)
    sign = +1
    sign_count = 0
    sign_saw_plus = False
    sign_saw_ws = False
    c = buf.peek()
    while c and c in &#34;+-&#34;:
        if c == &#34;-&#34;:
            sign = sign * -1
        elif c == &#34;+&#34;:
            sign_saw_plus = True
        sign_count += 1
        buf.skip()
        if self.skipws_nocomments(state) &gt; 0:
            sign_saw_ws = True
        c = buf.peek()

    if sign_count &gt; 1 or sign_saw_plus:
        state.push_cond(
            self.options.all_numeric_signs,
            &#39;Numbers may only have a single &#34;-&#34; as a sign prefix&#39;,
            position=start_position,
        )
    if sign_saw_ws:
        state.push_error(
            &#34;Spaces may not appear between a +/- number sign and the digits&#34;,
            position=start_position,
        )

    # Check for ECMAScript symbolic non-numbers
    if not c:
        state.push_error(
            &#34;Missing numeric value after sign&#34;, position=start_position
        )
        self.recover_parser(state)
        self.stats.num_undefineds += 1
        return undefined
    elif c.isalpha() or c in &#34;_$&#34;:
        kw = buf.popwhile(lambda c: c.isalnum() or c in &#34;_$&#34;)
        if kw == &#34;NaN&#34;:
            state.push_cond(
                self.options.non_numbers,
                &#34;NaN literals are not allowed in strict JSON&#34;,
                position=start_position,
            )
            state.stats.num_nans += 1
            return self.options.nan
        elif kw == &#34;Infinity&#34;:
            state.push_cond(
                self.options.non_numbers,
                &#34;Infinity literals are not allowed in strict JSON&#34;,
                position=start_position,
            )
            state.stats.num_infinities += 1
            if sign &lt; 0:
                return self.options.neginf
            else:
                return self.options.inf
        else:
            state.push_error(
                &#34;Unknown numeric value keyword&#34;, kw, position=start_position
            )
            return undefined

    # Check for radix-prefixed numbers
    elif c == &#34;0&#34; and (buf.peek(1) in [&#34;x&#34;, &#34;X&#34;]):
        # ----- HEX NUMBERS 0x123
        prefix = buf.popstr(2)
        digits = buf.popwhile(helpers.is_hex_digit)
        state.push_cond(
            self.options.hex_numbers,
            &#34;Hexadecimal literals are not allowed in strict JSON&#34;,
            prefix + digits,
            position=start_position,
        )
        if len(digits) == 0:
            state.push_error(
                &#34;Hexadecimal number is invalid&#34;, position=start_position
            )
            self.recover_parser(state)
            return undefined
        ival = helpers.decode_hex(digits)
        state.update_integer_stats(ival, sign=sign, position=start_position)
        n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_HEX)
        return n
    elif c == &#34;0&#34; and (buf.peek(1) in [&#34;o&#34;, &#34;O&#34;]):
        # ----- NEW-STYLE OCTAL NUMBERS  0o123
        prefix = buf.popstr(2)
        digits = buf.popwhile(helpers.is_octal_digit)
        state.push_cond(
            self.options.octal_numbers,
            &#34;Octal literals are not allowed in strict JSON&#34;,
            prefix + digits,
            position=start_position,
        )
        if len(digits) == 0:
            state.push_error(&#34;Octal number is invalid&#34;, position=start_position)
            self.recover_parser(state)
            return undefined
        ival = helpers.decode_octal(digits)
        state.update_integer_stats(ival, sign=sign, position=start_position)
        n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_OCTAL)
        return n
    elif c == &#34;0&#34; and (buf.peek(1) in [&#34;b&#34;, &#34;B&#34;]):
        # ----- NEW-STYLE BINARY NUMBERS  0b1101
        prefix = buf.popstr(2)
        digits = buf.popwhile(helpers.is_binary_digit)
        state.push_cond(
            self.options.binary_numbers,
            &#34;Binary literals are not allowed in strict JSON&#34;,
            prefix + digits,
            position=start_position,
        )
        if len(digits) == 0:
            state.push_error(&#34;Binary number is invalid&#34;, position=start_position)
            self.recover_parser(state)
            return undefined
        ival = helpers.decode_binary(digits)
        state.update_integer_stats(ival, sign=sign, position=start_position)
        n = state.options.make_int(ival, sign, number_format=NUMBER_FORMAT_BINARY)
        return n
    else:
        # ----- DECIMAL OR LEGACY-OCTAL NUMBER.   123, 0123
        # General syntax is:  \d+[\.\d+][e[+-]?\d+]
        number = buf.popwhile(lambda c: c in &#34;0123456789.+-eE&#34;)
        imax = len(number)
        if imax == 0:
            state.push_error(&#34;Missing numeric value&#34;, position=start_position)
        has_leading_zero = False
        units_digits = []  # digits making up whole number portion
        fraction_digits = []  # digits making up fractional portion
        exponent_digits = []  # digits making up exponent portion (excluding sign)
        esign = &#34;+&#34;  # sign of exponent
        sigdigits = 0  # number of significant digits (approximate)
        saw_decimal_point = False
        saw_exponent = False

        # Break number into parts in a first pass...use a mini state machine
        in_part = &#34;units&#34;
        for i, c in enumerate(number):

            if c == &#34;.&#34;:
                if in_part != &#34;units&#34;:
                    state.push_error(&#34;Bad number&#34;, number, position=start_position)
                    self.recover_parser(state)
                    return undefined
                in_part = &#34;fraction&#34;
                saw_decimal_point = True
            elif c in &#34;eE&#34;:
                if in_part == &#34;exponent&#34;:
                    state.push_error(&#34;Bad number&#34;, number, position=start_position)
                    self.recover_parser(state)
                    return undefined
                in_part = &#34;exponent&#34;
                saw_exponent = True
            elif c in &#34;+-&#34;:
                if in_part != &#34;exponent&#34; or exponent_digits:
                    state.push_error(&#34;Bad number&#34;, number, position=start_position)
                    self.recover_parser(state)
                    return undefined
                esign = c
            else:  # digit
                if in_part == &#34;units&#34;:
                    units_digits.append(c)
                elif in_part == &#34;fraction&#34;:
                    fraction_digits.append(c)
                elif in_part == &#34;exponent&#34;:
                    exponent_digits.append(c)
        units_s = &#34;&#34;.join(units_digits)
        fraction_s = &#34;&#34;.join(fraction_digits)
        exponent_s = &#34;&#34;.join(exponent_digits)

        # Basic syntax rules checking
        is_integer = not (saw_decimal_point or saw_exponent)

        if not units_s and not fraction_s:
            state.push_error(&#34;Bad number&#34;, number, position=start_position)
            self.recover_parser(state)
            return undefined

        if saw_decimal_point and not fraction_s:
            state.push_cond(
                self.options.trailing_decimal_point,
                &#34;Bad number, decimal point must be followed by at least one digit&#34;,
                number,
                position=start_position,
            )
            fraction_s = &#34;0&#34;

        if saw_exponent and not exponent_s:
            state.push_error(
                &#34;Bad number, exponent is missing&#34;, number, position=start_position
            )
            self.recover_parser(state)
            return undefined

        if not units_s:
            state.push_cond(
                self.options.initial_decimal_point,
                &#34;Bad number, decimal point must be preceded by at least one digit&#34;,
                number,
                position=start_position,
            )
            units = &#34;0&#34;
        elif len(units_s) &gt; 1 and units_s[0] == &#34;0&#34;:
            has_leading_zero = True
            if self.options.is_forbid_leading_zeros:
                state.push_cond(
                    self.options.leading_zeros,
                    &#34;Numbers may not have extra leading zeros&#34;,
                    number,
                    position=start_position,
                )
            elif self.options.is_warn_leading_zeros:
                state.push_cond(
                    self.options.leading_zeros,
                    &#34;Numbers may not have leading zeros; interpreting as %s&#34;
                    % self.options.leading_zero_radix_as_word,
                    number,
                    position=start_position,
                )

        # Estimate number of significant digits
        sigdigits = len((units_s + fraction_s).replace(&#34;0&#34;, &#34; &#34;).strip())

        # Handle legacy octal integers.
        if has_leading_zero and is_integer and self.options.leading_zero_radix == 8:
            # ----- LEGACY-OCTAL  0123
            try:
                ival = helpers.decode_octal(units_s)
            except ValueError:
                state.push_error(
                    &#34;Bad number, not a valid octal value&#34;,
                    number,
                    position=start_position,
                )
                self.recover_parser(state)
                return self.options.nan  # undefined
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(
                ival, sign, number_format=NUMBER_FORMAT_LEGACYOCTAL
            )
            return n

        # Determine the exponential part
        if exponent_s:
            try:
                exponent = int(exponent_s)
            except ValueError:
                state.push_error(
                    &#34;Bad number, bad exponent&#34;, number, position=start_position
                )
                self.recover_parser(state)
                return undefined
            if esign == &#34;-&#34;:
                exponent = -exponent
        else:
            exponent = 0

        # Try to make an int/long first.
        if not saw_decimal_point and exponent &gt;= 0:
            # ----- A DECIMAL INTEGER
            ival = int(units_s)
            if exponent != 0:
                ival *= 10 ** exponent
            state.update_integer_stats(ival, sign=sign, position=start_position)
            n = state.options.make_int(ival, sign)
        else:
            # ----- A FLOATING-POINT NUMBER
            try:
                if (
                    exponent &lt; float_minexp
                    or exponent &gt; float_maxexp
                    or sigdigits &gt; float_sigdigits
                ):
                    n = state.options.make_decimal(number, sign)
                else:
                    n = state.options.make_float(number, sign)
            except ValueError as err:
                state.push_error(
                    &#34;Bad number, %s&#34; % err.message, number, position=start_position
                )
                n = undefined
            else:
                state.update_float_stats(n, sign=sign, position=start_position)
        return n</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decode_string"><code class="name flex">
<span>def <span class="ident">decode_string</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Intermediate-level decoder for JSON string literals.</p>
<p>Takes a string and a starting index, and returns a Python
string (or unicode string) and the index of the next unparsed
character.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_string(self, state):
    &#34;&#34;&#34;Intermediate-level decoder for JSON string literals.

    Takes a string and a starting index, and returns a Python
    string (or unicode string) and the index of the next unparsed
    character.

    &#34;&#34;&#34;
    buf = state.buf
    self.skipws(state)
    quote = buf.peek()
    if quote == &#39;&#34;&#39;:
        pass
    elif quote == &#34;&#39;&#34;:
        state.push_cond(
            self.options.single_quoted_strings,
            &#34;String literals must use double quotation marks in strict JSON&#34;,
        )
    else:
        state.push_error(&#34;String literal must be properly quoted&#34;)
        return undefined

    string_position = buf.position
    buf.skip()

    if self.options.is_forbid_js_string_escapes:
        escapes = self._escapes_json
    else:
        escapes = self._escapes_js
    ccallowed = not self.options.is_forbid_control_char_in_string
    chunks = []
    _append = chunks.append

    # Used to track the last seen high-surrogate character
    high_surrogate = None
    highsur_position = None

    # Used to track if errors occured so we don&#39;t keep reporting multiples
    had_lineterm_error = False

    # Start looping character by character until the final quotation mark
    saw_final_quote = False
    should_stop = False
    while not saw_final_quote and not should_stop:
        if buf.at_end:
            state.push_error(
                &#34;String literal is not terminated&#34;,
                outer_position=string_position,
                context=&#34;String&#34;,
            )
            break
        c = buf.peek()

        # Make sure a high surrogate is immediately followed by a low surrogate
        if high_surrogate:
            if 0xDC00 &lt;= ord(c) &lt;= 0xDFFF:
                low_surrogate = buf.pop()
                try:
                    uc = helpers.surrogate_pair_as_unicode(
                        high_surrogate, low_surrogate
                    )
                except ValueError as err:
                    state.push_error(
                        &#34;Illegal Unicode surrogate pair&#34;,
                        (high_surrogate, low_surrogate),
                        position=highsur_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    uc = &#34;\ufffd&#34;  # replacement char
                _append(uc)
                high_surrogate = None
                highsur_position = None
                continue  # ==== NEXT CHAR
            elif buf.peekstr(2) != &#34;\\u&#34;:
                state.push_error(
                    &#34;High unicode surrogate must be followed by a low surrogate&#34;,
                    position=highsur_position,
                    outer_position=string_position,
                    context=&#34;String&#34;,
                )
                should_stop = state.should_stop
                _append(&#34;\ufffd&#34;)  # replacement char
                high_surrogate = None
                highsur_position = None

        if c == quote:
            buf.skip()  # skip over closing quote
            saw_final_quote = True
            break
        elif c == &#34;\\&#34;:
            # Escaped character
            escape_position = buf.position
            buf.skip()  # skip over backslash
            c = buf.peek()
            if not c:
                state.push_error(
                    &#34;Escape in string literal is incomplete&#34;,
                    position=escape_position,
                    outer_position=string_position,
                    context=&#34;String&#34;,
                )
                should_stop = state.should_stop
                break
            elif helpers.is_octal_digit(c):
                # Handle octal escape codes first so special \0 doesn&#39;t kick in yet.
                # Follow Annex B.1.2 of ECMAScript standard.
                if &#34;0&#34; &lt;= c &lt;= &#34;3&#34;:
                    maxdigits = 3
                else:
                    maxdigits = 2
                digits = buf.popwhile(helpers.is_octal_digit, maxchars=maxdigits)
                n = helpers.decode_octal(digits)
                if n == 0:
                    state.push_cond(
                        self.options.zero_byte,
                        &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                        &#34;\\&#34; + digits,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                else:  # n != 0
                    state.push_cond(
                        self.options.octal_numbers,
                        &#39;JSON does not allow octal character escapes other than &#34;\\0&#34;&#39;,
                        &#34;\\&#34; + digits,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                should_stop = state.should_stop
                if n &lt; 128:
                    _append(chr(n))
                else:
                    _append(helpers.safe_unichr(n))
            elif c in escapes:
                buf.skip()
                _append(escapes[c])
            elif c == &#34;u&#34; or c == &#34;x&#34;:
                buf.skip()
                esc_opener = &#34;\\&#34; + c
                esc_closer = &#34;&#34;
                if c == &#34;u&#34;:
                    if buf.peek() == &#34;{&#34;:
                        buf.skip()
                        esc_opener += &#34;{&#34;
                        esc_closer = &#34;}&#34;
                        maxdigits = None
                        state.push_cond(
                            self.options.extended_unicode_escapes,
                            &#34;JSON strings do not allow \\u{...} escapes&#34;,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                    else:
                        maxdigits = 4
                else:  # c== &#39;x&#39;
                    state.push_cond(
                        self.options.js_string_escapes,
                        &#34;JSON strings may not use the \\x hex-escape&#34;,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    maxdigits = 2

                digits = buf.popwhile(helpers.is_hex_digit, maxchars=maxdigits)

                if esc_closer:
                    if buf.peek() != esc_closer:
                        state.push_error(
                            &#34;Unicode escape sequence is missing closing &#39;%s&#39;&#34;
                            % esc_closer,
                            esc_opener + digits,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                    else:
                        buf.skip()

                esc_sequence = esc_opener + digits + esc_closer

                if not digits:
                    state.push_error(
                        &#34;numeric character escape sequence is truncated&#34;,
                        esc_sequence,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    codepoint = 0xFFFD  # replacement char
                else:
                    if maxdigits and len(digits) != maxdigits:
                        state.push_error(
                            &#34;escape sequence has too few hexadecimal digits&#34;,
                            esc_sequence,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                    codepoint = helpers.decode_hex(digits)

                if codepoint &gt; 0x10FFFF:
                    state.push_error(
                        &#34;Unicode codepoint is beyond U+10FFFF&#34;,
                        esc_opener + digits + esc_closer,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    codepoint = 0xFFFD  # replacement char

                if high_surrogate:
                    # Decode surrogate pair and clear high surrogate
                    low_surrogate = chr(codepoint)
                    try:
                        uc = helpers.surrogate_pair_as_unicode(
                            high_surrogate, low_surrogate
                        )
                    except ValueError as err:
                        state.push_error(
                            &#34;Illegal Unicode surrogate pair&#34;,
                            (high_surrogate, low_surrogate),
                            position=highsur_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                        uc = &#34;\ufffd&#34;  # replacement char
                    _append(uc)
                    high_surrogate = None
                    highsur_position = None
                elif codepoint &lt; 128:
                    # ASCII chars always go in as a str
                    if codepoint == 0:
                        state.push_cond(
                            self.options.zero_byte,
                            &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                            position=escape_position,
                            outer_position=string_position,
                            context=&#34;String&#34;,
                        )
                        should_stop = state.should_stop
                    _append(chr(codepoint))
                elif 0xD800 &lt;= codepoint &lt;= 0xDBFF:  # high surrogate
                    high_surrogate = chr(
                        codepoint
                    )  # remember until we get to the low surrogate
                    highsur_position = escape_position.copy()
                elif 0xDC00 &lt;= codepoint &lt;= 0xDFFF:  # low surrogate
                    state.push_error(
                        &#34;Low unicode surrogate must be proceeded by a high surrogate&#34;,
                        position=escape_position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    _append(&#34;\ufffd&#34;)  # replacement char
                else:
                    # Other chars go in as a unicode char
                    _append(helpers.safe_unichr(codepoint))
            else:
                # Unknown escape sequence
                state.push_cond(
                    self.options.nonescape_characters,
                    &#34;String escape code is not allowed in strict JSON&#34;,
                    &#34;\\&#34; + c,
                    position=escape_position,
                    outer_position=string_position,
                    context=&#34;String&#34;,
                )
                should_stop = state.should_stop
                _append(c)
                buf.skip()
        elif ord(c) &lt;= 0x1F:  # A control character
            if ord(c) == 0:
                state.push_cond(
                    self.options.zero_byte,
                    &#34;Zero-byte character (U+0000) in string may not be universally safe&#34;,
                    position=buf.position,
                    outer_position=string_position,
                    context=&#34;String&#34;,
                )
                should_stop = state.should_stop
            if self.islineterm(c):
                if not had_lineterm_error:
                    state.push_error(
                        &#34;Line terminator characters must be escaped inside string literals&#34;,
                        &#34;U+%04X&#34; % ord(c),
                        position=buf.position,
                        outer_position=string_position,
                        context=&#34;String&#34;,
                    )
                    should_stop = state.should_stop
                    had_lineterm_error = True
                _append(c)
                buf.skip()
            elif ccallowed:
                _append(c)
                buf.skip()
            else:
                state.push_error(
                    &#34;Control characters must be escaped inside JSON string literals&#34;,
                    &#34;U+%04X&#34; % ord(c),
                    position=buf.position,
                    outer_position=string_position,
                    context=&#34;String&#34;,
                )
                should_stop = state.should_stop
                buf.skip()
        elif 0xD800 &lt;= ord(c) &lt;= 0xDBFF:  # a raw high surrogate
            high_surrogate = buf.pop()  # remember until we get to the low surrogate
            highsur_position = buf.position.copy()
        else:  # A normal character; not an escape sequence or end-quote.
            # Find a whole sequence of &#34;safe&#34; characters so we can append them
            # all at once rather than one a time, for speed.
            chunk = buf.popwhile(
                lambda c: c not in helpers.unsafe_string_chars and c != quote
            )
            if not chunk:
                _append(c)
                buf.skip()
            else:
                _append(chunk)

    # Check proper string termination
    if high_surrogate:
        state.push_error(
            &#34;High unicode surrogate must be followed by a low surrogate&#34;,
            position=highsur_position,
            outer_position=string_position,
            context=&#34;String&#34;,
        )
        _append(&#34;\ufffd&#34;)  # replacement char
        high_surrogate = None
        highsur_position = None

    if not saw_final_quote:
        state.push_error(
            &#34;String literal is not terminated with a quotation mark&#34;,
            position=buf.position,
            outer_position=string_position,
            context=&#34;String&#34;,
        )

    if state.should_stop:
        return undefined

    # Compose the python string and update stats
    s = &#34;&#34;.join(chunks)
    state.update_string_stats(s, position=string_position)

    # Call string hook
    if self.has_hook(&#34;decode_string&#34;):
        try:
            s = self.call_hook(&#34;decode_string&#34;, s, position=string_position)
        except JSONSkipHook:
            pass
        except JSONError as err:
            state.push_exception(err)
            s = undefined
    return s</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.decodeobj"><code class="name flex">
<span>def <span class="ident">decodeobj</span></span>(<span>self, state, identifier_as_string=False, at_document_start=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Intermediate-level JSON decoder.</p>
<p>Takes a string and a starting index, and returns a two-tuple consting
of a Python object and the index of the next unparsed character.</p>
<p>If there is no value at all (empty string, etc), then None is
returned instead of a tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decodeobj(self, state, identifier_as_string=False, at_document_start=False):
    &#34;&#34;&#34;Intermediate-level JSON decoder.

    Takes a string and a starting index, and returns a two-tuple consting
    of a Python object and the index of the next unparsed character.

    If there is no value at all (empty string, etc), then None is
    returned instead of a tuple.

    &#34;&#34;&#34;
    buf = state.buf
    obj = None
    self.skipws(state)
    if buf.at_end:
        state.push_error(&#34;Unexpected end of input&#34;)

    c = buf.peek()
    if c in &#34;{[&#34;:
        state.cur_depth += 1
        try:
            state.update_depth_stats()
            obj = self.decode_composite(state)
        finally:
            state.cur_depth -= 1
    else:
        if at_document_start:
            state.push_cond(
                self.options.any_type_at_start,
                &#34;JSON document must start with an object or array type only&#34;,
            )
        if c in self._string_quotes:
            obj = self.decode_string(state)
        elif c.isdigit() or c in &#34;.+-&#34;:
            obj = self.decode_number(state)
        elif c.isalpha() or c in &#34;_$&#34;:
            obj = self.decode_identifier(
                state, identifier_as_string=identifier_as_string
            )
        else:
            state.push_error(&#34;Can not decode value starting with character %r&#34; % c)
            buf.skip()
            self.recover_parser(state)
            obj = syntax_error
    return obj</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, obj, encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the Python object into a JSON string representation.</p>
<p>This method will first attempt to encode an object by seeing
if it has a json_equivalent() method.
If so than it will
call that method and then recursively attempt to encode
the object resulting from that call.</p>
<p>Next it will attempt to determine if the object is a native
type or acts like a squence or dictionary.
If so it will
encode that object directly.</p>
<p>Finally, if no other strategy for encoding the object of that
type exists, it will call the encode_default() method.
That
method currently raises an error, but it could be overridden
by subclasses to provide a hook for extending the types which
can be encoded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self, obj, encoding=None):
    &#34;&#34;&#34;Encodes the Python object into a JSON string representation.

    This method will first attempt to encode an object by seeing
    if it has a json_equivalent() method.  If so than it will
    call that method and then recursively attempt to encode
    the object resulting from that call.

    Next it will attempt to determine if the object is a native
    type or acts like a squence or dictionary.  If so it will
    encode that object directly.

    Finally, if no other strategy for encoding the object of that
    type exists, it will call the encode_default() method.  That
    method currently raises an error, but it could be overridden
    by subclasses to provide a hook for extending the types which
    can be encoded.

    &#34;&#34;&#34;
    import sys, codecs

    # Make a fresh encoding state
    state = encode_state(self.options)

    # Find the codec to use. CodecInfo will be in &#39;cdk&#39; and name in &#39;encoding&#39;.
    #
    # Also set the state&#39;s &#39;escape_unicode_test&#39; property which is used to
    # determine what characters to \u-escape.
    if encoding is None:
        cdk = None
    elif isinstance(encoding, codecs.CodecInfo):
        cdk = encoding
        encoding = cdk.name
    else:
        cdk = helpers.lookup_codec(encoding)
        if not cdk:
            raise JSONEncodeError(
                &#34;no codec available for character encoding&#34;, encoding
            )

    if self.options.escape_unicode and callable(self.options.escape_unicode):
        # User-supplied repertoire test function
        state.escape_unicode_test = self.options.escape_unicode
    else:
        if (
            self.options.escape_unicode == True
            or not cdk
            or cdk.name.lower() == &#34;ascii&#34;
        ):
            # ASCII, ISO8859-1, or and Unknown codec -- \u escape anything not ASCII
            state.escape_unicode_test = lambda c: ord(c) &gt;= 0x80
        elif cdk.name == &#34;iso8859-1&#34;:
            state.escape_unicode_test = lambda c: ord(c) &gt;= 0x100
        elif cdk and cdk.name.lower().startswith(&#34;utf&#34;):
            # All UTF-x encodings can do the whole Unicode repertoire, so
            # do nothing special.
            state.escape_unicode_test = False
        else:
            # An unusual codec.  We need to test every character
            # to see if it is in the codec&#39;s repertoire to determine
            # if we should \u escape that character.
            enc_func = cdk.encode

            def escape_unicode_hardway(c):
                try:
                    enc_func(c)
                except UnicodeEncodeError:
                    return True
                else:
                    return False

            state.escape_unicode_test = escape_unicode_hardway

    # Make sure the encoding is not degenerate: it can encode the minimal
    # number of characters needed by the JSON syntax rules.
    if encoding is not None:
        try:
            output, nchars = cdk.encode(JSON.json_syntax_characters)
        except UnicodeError as err:
            raise JSONEncodeError(
                &#34;Output encoding %s is not sufficient to encode JSON&#34; % cdk.name
            )

    # Do the JSON encoding!
    self._do_encode(obj, state)
    if not self.options.encode_compactly:
        state.append(&#34;\n&#34;)
    unitxt = state.combine()

    # Do the final Unicode encoding
    if encoding is None:
        output = unitxt
    else:
        try:
            output, nchars = cdk.encode(unitxt)
        except UnicodeEncodeError as err:
            # Re-raise as a JSONDecodeError
            newerr = JSONEncodeError(&#34;a Unicode encoding error occurred&#34;)
            raise newerr from err
    return output</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_boolean"><code class="name flex">
<span>def <span class="ident">encode_boolean</span></span>(<span>self, bval, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the Python boolean into a JSON Boolean literal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_boolean(self, bval, state):
    &#34;&#34;&#34;Encodes the Python boolean into a JSON Boolean literal.&#34;&#34;&#34;
    state.append(&#34;true&#34; if bool(bval) else &#34;false&#34;)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_composite"><code class="name flex">
<span>def <span class="ident">encode_composite</span></span>(<span>self, obj, state, obj_classification=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes just composite objects: dictionaries, lists, or sequences.</p>
<p>Basically handles any python type for which iter() can create
an iterator object.</p>
<p>This method is not intended to be called directly.
Use the
encode() method instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_composite(self, obj, state, obj_classification=None):
    &#34;&#34;&#34;Encodes just composite objects: dictionaries, lists, or sequences.

    Basically handles any python type for which iter() can create
    an iterator object.

    This method is not intended to be called directly.  Use the
    encode() method instead.

    &#34;&#34;&#34;
    import sys

    if not obj_classification:
        obj_classification = self._classify_for_encoding(obj)

    # Convert namedtuples to dictionaries
    if obj_classification == &#34;namedtuple&#34;:
        obj = obj._asdict()
        obj_classification = &#34;dict&#34;

    # Convert &#39;unsigned byte&#39; memory views into plain bytes
    if obj_classification == &#34;memoryview&#34; and obj.format == &#34;B&#34;:
        obj = obj.tobytes()
        obj_classification = &#34;bytes&#34;

    # Run hooks
    hook_name = None
    if obj_classification == &#34;dict&#34;:
        hook_name = &#34;encode_dict&#34;
    elif obj_classification == &#34;sequence&#34;:
        hook_name = &#34;encode_sequence&#34;
    elif obj_classification == &#34;bytes&#34;:
        hook_name = &#34;encode_bytes&#34;

    if self.has_hook(hook_name):
        try:
            new_obj = self.call_hook(hook_name, obj)
        except JSONSkipHook:
            pass
        else:
            if new_obj is not obj:
                obj = new_obj
                prev_cls = obj_classification
                obj_classification = self._classify_for_encoding(obj)
                if obj_classification != prev_cls:
                    # Transformed to a different kind of object, call
                    # back to the general encode() method.
                    self._do_encode(obj, state)
                    return
                # Else, fall through

    # At his point we have decided to do with an object or an array
    isdict = obj_classification == &#34;dict&#34;

    # Get iterator
    it = None
    if isdict and hasattr(obj, &#34;iterkeys&#34;):
        try:
            it = iter(obj.keys())
        except AttributeError:
            pass
    else:
        try:
            it = iter(obj)
        except TypeError:
            pass

    # Convert each member to JSON
    if it is not None:
        # Try to get length, but don&#39;t fail if we can&#39;t
        try:
            numitems = len(obj)
        except TypeError:
            numitems = 0

        # Output the opening bracket or brace
        compactly = self.options.encode_compactly
        if not compactly:
            indent0 = self.options.indentation_for_level(state.nest_level)
            indent = self.options.indentation_for_level(state.nest_level + 1)

        spaces_after_opener = &#34;&#34;
        if isdict:
            opener = &#34;{&#34;
            closer = &#34;}&#34;
            if compactly:
                dictcolon = &#34;:&#34;
            else:
                dictcolon = &#34; : &#34;
        else:
            opener = &#34;[&#34;
            closer = &#34;]&#34;
        if not compactly:
            # opener = opener + &#39; &#39;
            spaces_after_opener = self.options.spaces_to_next_indent_level(
                subtract=len(opener)
            )

        state.append(opener)
        state.append(spaces_after_opener)

        # Now iterate through all the items and collect their representations
        parts = []  # Collects each of the members
        part_keys = []  # For dictionary key sorting, tuples (key,index)

        try:  # while not StopIteration
            part_idx = 0
            while True:
                obj2 = next(it)
                part_idx += 1  # Note, will start counting at 1
                if obj2 is obj:
                    raise JSONEncodeError(
                        &#34;trying to encode an infinite sequence&#34;, obj
                    )
                if isdict:
                    obj3 = obj[obj2]
                    # Dictionary key is in obj2 and value in obj3.

                    # Let any hooks transform the key.
                    if self.has_hook(&#34;encode_value&#34;):
                        try:
                            newobj = self.call_hook(&#34;encode_value&#34;, obj2)
                        except JSONSkipHook:
                            pass
                        else:
                            obj2 = newobj
                    if self.has_hook(&#34;encode_dict_key&#34;):
                        try:
                            newkey = self.call_hook(&#34;encode_dict_key&#34;, obj2)
                        except JSONSkipHook:
                            pass
                        else:
                            obj2 = newkey

                    # Check JSON restrictions on key types
                    if not helpers.isstringtype(obj2):
                        if helpers.isnumbertype(obj2):
                            if not self.options.is_allow_nonstring_keys:
                                raise JSONEncodeError(
                                    &#34;object properties (dictionary keys) must be strings in strict JSON&#34;,
                                    obj2,
                                )
                        else:
                            raise JSONEncodeError(
                                &#34;object properties (dictionary keys) can only be strings or numbers in ECMAScript&#34;,
                                obj2,
                            )
                    part_keys.append((obj2, part_idx - 1))

                # Encode this item in the sequence and put into item_chunks
                substate = state.make_substate()
                self._do_encode(obj2, substate)
                if isdict:
                    substate.append(dictcolon)
                    substate2 = substate.make_substate()
                    self._do_encode(obj3, substate2)
                    substate.join_substate(substate2)
                parts.append(substate)
            # Next item iteration
        except StopIteration:
            pass

        # Sort dictionary keys
        if isdict:
            srt = self.options.sort_keys
            if srt == SORT_PRESERVE:
                if _OrderedDict and isinstance(obj, _OrderedDict):
                    srt = SORT_NONE  # Will keep order
                else:
                    srt = SORT_SMART

            if not srt or srt in (SORT_NONE, SORT_PRESERVE):
                srt = None
            elif callable(srt):
                part_keys.sort(key=(lambda t: (srt(t[0]), t[0])))
            elif srt == SORT_SMART:
                part_keys.sort(key=(lambda t: (smart_sort_transform(t[0]), t[0])))
            elif srt == SORT_ALPHA_CI:
                part_keys.sort(key=(lambda t: (str(t[0]).upper(), t[0])))
            elif srt or srt == SORT_ALPHA:
                part_keys.sort(key=(lambda t: str(t[0])))
            # Now make parts match the new sort order
            if srt is not None:
                parts = [parts[pk[1]] for pk in part_keys]

        if compactly:
            sep = &#34;,&#34;
        elif len(parts) &lt;= self.options.max_items_per_line:
            sep = &#34;, &#34;
        else:
            # state.append(spaces_after_opener)
            state.append(&#34;\n&#34; + indent)
            sep = &#34;,\n&#34; + indent

        for pnum, substate in enumerate(parts):
            if pnum &gt; 0:
                state.append(sep)
            state.join_substate(substate)

        if not compactly:
            if numitems &gt; self.options.max_items_per_line:
                state.append(&#34;\n&#34; + indent0)
            else:
                state.append(&#34; &#34;)
        state.append(closer)  # final &#39;}&#39; or &#39;]&#39;
    else:  # Can&#39;t create an iterator for the object
        self.try_encode_default(obj, state)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_date"><code class="name flex">
<span>def <span class="ident">encode_date</span></span>(<span>self, dt, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_date(self, dt, state):
    fmt = self.options.date_format
    if not fmt or fmt == &#34;iso&#34;:
        fmt = &#34;%Y-%m-%d&#34;
    self.encode_string(dt.strftime(fmt), state)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_datetime"><code class="name flex">
<span>def <span class="ident">encode_datetime</span></span>(<span>self, dt, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_datetime(self, dt, state):
    fmt = self.options.datetime_format
    is_iso = not fmt or fmt == &#34;iso&#34;
    if is_iso:
        if dt.microsecond == 0:
            fmt = &#34;%Y-%m-%dT%H:%M:%S%z&#34;
        else:
            fmt = &#34;%Y-%m-%dT%H:%M:%S.%f%z&#34;
    s = dt.strftime(fmt)
    if is_iso and s.endswith(&#34;-00:00&#34;) or s.endswith(&#34;+00:00&#34;):
        s = s[:-6] + &#34;Z&#34;  # Change UTC to use &#39;Z&#39; notation
    self.encode_string(s, state)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_enum"><code class="name flex">
<span>def <span class="ident">encode_enum</span></span>(<span>self, val, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode a Python Enum value into JSON.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_enum(self, val, state):
    &#34;&#34;&#34;Encode a Python Enum value into JSON.&#34;&#34;&#34;
    eas = self.options.encode_enum_as
    if eas == &#34;qname&#34;:
        self.encode_string(str(val), state)
    elif eas == &#34;value&#34;:
        self._do_encode(val.value, state)
    else:  # eas == &#39;name&#39;
        self.encode_string(val.name, state)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_equivalent"><code class="name flex">
<span>def <span class="ident">encode_equivalent</span></span>(<span>self, obj, state)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used to encode user-defined class objects.</p>
<p>The object being encoded should have a json_equivalent()
method defined which returns another equivalent object which
is easily JSON-encoded.
If the object in question has no
json_equivalent() method available then None is returned
instead of a string so that the encoding will attempt the next
strategy.</p>
<p>If a caller wishes to disable the calling of json_equivalent()
methods, then subclass this class and override this method
to just return None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_equivalent(self, obj, state):
    &#34;&#34;&#34;This method is used to encode user-defined class objects.

    The object being encoded should have a json_equivalent()
    method defined which returns another equivalent object which
    is easily JSON-encoded.  If the object in question has no
    json_equivalent() method available then None is returned
    instead of a string so that the encoding will attempt the next
    strategy.

    If a caller wishes to disable the calling of json_equivalent()
    methods, then subclass this class and override this method
    to just return None.

    &#34;&#34;&#34;
    if hasattr(obj, &#34;json_equivalent&#34;) and callable(
        getattr(obj, &#34;json_equivalent&#34;)
    ):
        obj2 = obj.json_equivalent()
        if obj2 is obj:
            # Try to prevent careless infinite recursion
            raise JSONEncodeError(
                &#34;object has a json_equivalent() method that returns itself&#34;, obj
            )
        self._do_encode(obj2, state)
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_null"><code class="name flex">
<span>def <span class="ident">encode_null</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces the JSON 'null' keyword.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_null(self, state):
    &#34;&#34;&#34;Produces the JSON &#39;null&#39; keyword.&#34;&#34;&#34;
    state.append(&#34;null&#34;)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_number"><code class="name flex">
<span>def <span class="ident">encode_number</span></span>(<span>self, n, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a Python numeric type into a JSON numeric literal.</p>
<p>The special non-numeric values of float('nan'), float('inf')
and float('-inf') are translated into appropriate JSON
literals.</p>
<p>Note that Python complex types are not handled, as there is no
ECMAScript equivalent type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_number(self, n, state):
    &#34;&#34;&#34;Encodes a Python numeric type into a JSON numeric literal.

    The special non-numeric values of float(&#39;nan&#39;), float(&#39;inf&#39;)
    and float(&#39;-inf&#39;) are translated into appropriate JSON
    literals.

    Note that Python complex types are not handled, as there is no
    ECMAScript equivalent type.

    &#34;&#34;&#34;
    if isinstance(n, complex):
        if n.imag:
            raise JSONEncodeError(
                &#34;Can not encode a complex number that has a non-zero imaginary part&#34;,
                n,
            )
        n = n.real

    if isinstance(n, json_int):
        state.append(n.json_format())
        return

    if isinstance(n, int):
        state.append(str(n))
        return

    if isinstance(n, decimal.Decimal):
        if n.is_nan():  # Could be &#39;NaN&#39; or &#39;sNaN&#39;
            state.append(&#34;NaN&#34;)
        elif n.is_infinite():
            if n.is_signed():
                state.append(&#34;-Infinity&#34;)
            else:
                state.append(&#34;Infinity&#34;)
        else:
            s = str(n).lower()
            if &#34;e&#34; not in s and &#34;.&#34; not in s:
                s = s + &#34;.0&#34;
            state.append(s)
        return

    global nan, inf, neginf
    if n is nan:
        state.append(&#34;NaN&#34;)
    elif n is inf:
        state.append(&#34;Infinity&#34;)
    elif n is neginf:
        state.append(&#34;-Infinity&#34;)
    elif isinstance(n, float):
        # Check for non-numbers.
        # In python nan == inf == -inf, so must use repr() to distinguish
        reprn = repr(n).lower()
        if (&#34;inf&#34; in reprn and &#34;-&#34; in reprn) or n == neginf:
            state.append(&#34;-Infinity&#34;)
        elif &#34;inf&#34; in reprn or n is inf:
            state.append(&#34;Infinity&#34;)
        elif &#34;nan&#34; in reprn or n is nan:
            state.append(&#34;NaN&#34;)
        else:
            # A normal float.
            state.append(repr(n))
    else:
        raise TypeError(
            &#34;encode_number expected an integral, float, or decimal number type&#34;,
            type(n),
        )</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_string"><code class="name flex">
<span>def <span class="ident">encode_string</span></span>(<span>self, s, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a Python string into a JSON string literal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_string(self, s, state):
    &#34;&#34;&#34;Encodes a Python string into a JSON string literal.&#34;&#34;&#34;
    # Must handle instances of UserString specially in order to be
    # able to use ord() on it&#39;s simulated &#34;characters&#34;.  Also
    # convert Python2 &#39;str&#39; types to unicode strings first.
    import unicodedata, sys
    import collections

    py2strenc = self.options.py2str_encoding
    if isinstance(s, collections.UserString):

        def tochar(c):
            c2 = c.data
            if py2strenc and not isinstance(c2, str):
                return c2.decode(py2strenc)
            else:
                return c2

    elif py2strenc and not isinstance(s, str):
        s = s.decode(py2strenc)
        tochar = None
    else:
        # Could use &#34;lambda c:c&#34;, but that is too slow.  So we set to None
        # and use an explicit if test inside the loop.
        tochar = None

    chunks = []
    chunks.append(&#39;&#34;&#39;)
    revesc = self._rev_escapes
    optrevesc = self._optional_rev_escapes
    asciiencodable = self._asciiencodable
    always_escape = state.options.always_escape_chars
    encunicode = state.escape_unicode_test
    i = 0
    imax = len(s)
    while i &lt; imax:
        if tochar:
            c = tochar(s[i])
        else:
            c = s[i]
        cord = ord(c)
        if (
            cord &lt; 256
            and asciiencodable[cord]
            and isinstance(encunicode, bool)
            and not (always_escape and c in always_escape)
        ):
            # Contiguous runs of plain old printable ASCII can be copied
            # directly to the JSON output without worry (unless the user
            # has supplied a custom is-encodable function).
            j = i
            i += 1
            while i &lt; imax:
                if tochar:
                    c = tochar(s[i])
                else:
                    c = s[i]
                cord = ord(c)
                if (
                    cord &lt; 256
                    and asciiencodable[cord]
                    and not (always_escape and c in always_escape)
                ):
                    i += 1
                else:
                    break
            chunks.append(str(s[j:i]))
        elif c in revesc:
            # Has a shortcut escape sequence, like &#34;\n&#34;
            chunks.append(revesc[c])
            i += 1
        elif cord &lt;= 0x1F:
            # Always unicode escape ASCII-control characters
            chunks.append(r&#34;\u%04x&#34; % cord)
            i += 1
        elif 0xD800 &lt;= cord &lt;= 0xDFFF:
            # A raw surrogate character!
            # This should ONLY happen in &#34;narrow&#34; Python builds
            # where (sys.maxunicode == 65535) as Python itself
            # uses UTF-16.  But for &#34;wide&#34; Python builds, a raw
            # surrogate should never happen.
            handled_raw_surrogates = False
            if (
                sys.maxunicode == 0xFFFF
                and 0xD800 &lt;= cord &lt;= 0xDBFF
                and (i + 1) &lt; imax
            ):
                # In a NARROW Python, output surrogate pair as-is
                hsurrogate = cord
                i += 1
                if tochar:
                    c = tochar(s[i])
                else:
                    c = s[i]
                cord = ord(c)
                i += 1
                if 0xDC00 &lt;= cord &lt;= 0xDFFF:
                    lsurrogate = cord
                    chunks.append(r&#34;\u%04x\u%04x&#34; % (hsurrogate, lsurrogate))
                    handled_raw_surrogates = True
            if not handled_raw_surrogates:
                cname = &#34;U+%04X&#34; % cord
                raise JSONEncodeError(
                    &#34;can not include or escape a Unicode surrogate character&#34;, cname
                )
        elif cord &lt;= 0xFFFF:
            # Other BMP Unicode character
            if always_escape and c in always_escape:
                doesc = True
            elif unicodedata.category(c) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]:
                doesc = True
            elif callable(encunicode):
                doesc = encunicode(c)
            else:
                doesc = encunicode

            if doesc:
                if c in optrevesc:
                    chunks.append(optrevesc[c])
                else:
                    chunks.append(r&#34;\u%04x&#34; % cord)
            else:
                chunks.append(c)
            i += 1
        else:  # ord(c) &gt;= 0x10000
            # Non-BMP Unicode
            if always_escape and c in always_escape:
                doesc = True
            elif unicodedata.category(c) in [&#34;Cc&#34;, &#34;Cf&#34;, &#34;Zl&#34;, &#34;Zp&#34;]:
                doesc = True
            elif callable(encunicode):
                doesc = encunicode(c)
            else:
                doesc = encunicode

            if doesc:
                for surrogate in helpers.unicode_as_surrogate_pair(c):
                    chunks.append(r&#34;\u%04x&#34; % ord(surrogate))
            else:
                chunks.append(c)
            i += 1

    chunks.append(&#39;&#34;&#39;)
    state.append(&#34;&#34;.join(chunks))</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_time"><code class="name flex">
<span>def <span class="ident">encode_time</span></span>(<span>self, t, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_time(self, t, state):
    fmt = self.options.datetime_format
    is_iso = not fmt or fmt == &#34;iso&#34;
    if is_iso:
        if t.microsecond == 0:
            fmt = &#34;T%H:%M:%S%z&#34;
        else:
            fmt = &#34;T%H:%M:%S.%f%z&#34;
    s = t.strftime(fmt)
    if is_iso and s.endswith(&#34;-00:00&#34;) or s.endswith(&#34;+00:00&#34;):
        s = s[:-6] + &#34;Z&#34;  # Change UTC to use &#39;Z&#39; notation
    self.encode_string(s, state)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_timedelta"><code class="name flex">
<span>def <span class="ident">encode_timedelta</span></span>(<span>self, td, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_timedelta(self, td, state):
    fmt = self.options.timedelta_format
    if not fmt or fmt == &#34;iso&#34;:
        s = helpers.format_timedelta_iso(td)
    elif fmt == &#34;hms&#34;:
        s = str(td)
    else:
        raise ValueError(&#34;Unknown timedelta_format %r&#34; % fmt)
    self.encode_string(s, state)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.encode_undefined"><code class="name flex">
<span>def <span class="ident">encode_undefined</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces the ECMAScript 'undefined' keyword.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_undefined(self, state):
    &#34;&#34;&#34;Produces the ECMAScript &#39;undefined&#39; keyword.&#34;&#34;&#34;
    state.append(&#34;undefined&#34;)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.has_hook"><code class="name flex">
<span>def <span class="ident">has_hook</span></span>(<span>self, hook_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_hook(self, hook_name):
    if not hook_name or hook_name not in self.all_hook_names:
        return False
    hook = getattr(self, hook_name + &#34;_hook&#34;)
    return callable(hook)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.islineterm"><code class="name flex">
<span>def <span class="ident">islineterm</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is considered a line terminator.</p>
<p>Ref. ECMAScript section 7.3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def islineterm(self, c):
    &#34;&#34;&#34;Determines if the given character is considered a line terminator.

    Ref. ECMAScript section 7.3

    &#34;&#34;&#34;
    if c == &#34;\r&#34; or c == &#34;\n&#34;:
        return True
    if c == &#34;\u2028&#34; or c == &#34;\u2029&#34;:  # unicodedata.category(c) in  [&#39;Zl&#39;, &#39;Zp&#39;]
        return True
    return False</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.isws"><code class="name flex">
<span>def <span class="ident">isws</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is considered as white space.</p>
<p>Note that Javscript is much more permissive on what it considers
to be whitespace than does JSON.</p>
<p>Ref. ECMAScript section 7.2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isws(self, c):
    &#34;&#34;&#34;Determines if the given character is considered as white space.

    Note that Javscript is much more permissive on what it considers
    to be whitespace than does JSON.

    Ref. ECMAScript section 7.2

    &#34;&#34;&#34;
    if not self.options.unicode_whitespace:
        return c in &#34; \t\n\r&#34;
    else:
        if not isinstance(c, str):
            c = str(c)
        if c in &#34; \t\n\r\f\v&#34;:
            return True
        import unicodedata

        return unicodedata.category(c) == &#34;Zs&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.recover_parser"><code class="name flex">
<span>def <span class="ident">recover_parser</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to recover after a syntax error by locating the next "known" position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recover_parser(self, state):
    &#34;&#34;&#34;Try to recover after a syntax error by locating the next &#34;known&#34; position.&#34;&#34;&#34;
    buf = state.buf
    buf.skipuntil(lambda c: c in &#34;,:[]{}\&#34;&#39;;&#34; or helpers.char_is_unicode_eol(c))
    stopchar = buf.peek()
    self.skipws(state)
    if buf.at_end:
        state.push_info(
            &#34;Could not recover parsing after previous error&#34;, position=buf.position
        )
    else:
        state.push_info(
            &#34;Recovering parsing after character %r&#34; % stopchar,
            position=buf.position,
        )
    return stopchar</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.set_hook"><code class="name flex">
<span>def <span class="ident">set_hook</span></span>(<span>self, hookname, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a user-defined callback function used during encoding or decoding.</p>
<p>The 'hookname' argument must be a string containing the name of
one of the available hooks, listed below.</p>
<p>The 'function' argument must either be None, which disables the hook,
or a callable function.
Hooks do not stack, if you set a hook it will
undo any previously set hook.</p>
<p>Netsted values.
When decoding JSON that has nested objects or
arrays, the decoding hooks will be called once for every
corresponding value, even if nested.
Generally the decoding
hooks will be called from the inner-most value outward, and
then left to right.</p>
<p>Skipping. Any hook function may raise a JSONSkipHook exception
if it does not wish to handle the particular invocation.
This
will have the effect of skipping the hook for that particular
value, as if the hook was net set.</p>
<p>AVAILABLE HOOKS:</p>
<ul>
<li>
<p>decode_string
Called for every JSON string literal with the
Python-equivalent string value as an argument. Expects to
get a Python object in return.</p>
</li>
<li>
<p>decode_float:
Called for every JSON number that looks like a float (has
a ".").
The string representation of the number is passed
as an argument.
Expects to get a Python object in return.</p>
</li>
<li>
<p>decode_number:
Called for every JSON number. The string representation of
the number is passed as an argument.
Expects to get a
Python object in return.
NOTE: If the number looks like a
float and the 'decode_float' hook is set, then this hook
will not be called.</p>
</li>
<li>
<p>decode_array:
Called for every JSON array. A Python list is passed as
the argument, and expects to get a Python object back.
NOTE: this hook will get called for every array, even
for nested arrays.</p>
</li>
<li>
<p>decode_object:
Called for every JSON object.
A Python dictionary is passed
as the argument, and expects to get a Python object back.
NOTE: this hook will get called for every object, even
for nested objects.</p>
</li>
<li>
<p>encode_value:
Called for every Python object which is to be encoded into JSON.</p>
</li>
<li>
<p>encode_dict:
Called for every Python dictionary or anything that looks
like a dictionary.</p>
</li>
<li>
<p>encode_dict_key:
Called for every dictionary key.</p>
</li>
<li>
<p>encode_sequence:
Called for every Python sequence-like object that is not a
dictionary or string. This includes lists and tuples.</p>
</li>
<li>
<p>encode_bytes:
Called for every Python bytes or bytearray type; or for
any memoryview with a byte ('B') item type.
(Python 3 only)</p>
</li>
<li>
<p>encode_default:
Called for any Python type which can not otherwise be converted
into JSON, even after applying any other encoding hooks.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_hook(self, hookname, function):
    &#34;&#34;&#34;Sets a user-defined callback function used during encoding or decoding.

    The &#39;hookname&#39; argument must be a string containing the name of
    one of the available hooks, listed below.

    The &#39;function&#39; argument must either be None, which disables the hook,
    or a callable function.  Hooks do not stack, if you set a hook it will
    undo any previously set hook.

    Netsted values.  When decoding JSON that has nested objects or
    arrays, the decoding hooks will be called once for every
    corresponding value, even if nested.  Generally the decoding
    hooks will be called from the inner-most value outward, and
    then left to right.

    Skipping. Any hook function may raise a JSONSkipHook exception
    if it does not wish to handle the particular invocation.  This
    will have the effect of skipping the hook for that particular
    value, as if the hook was net set.

    AVAILABLE HOOKS:

    * decode_string
        Called for every JSON string literal with the
        Python-equivalent string value as an argument. Expects to
        get a Python object in return.

    * decode_float:
        Called for every JSON number that looks like a float (has
        a &#34;.&#34;).  The string representation of the number is passed
        as an argument.  Expects to get a Python object in return.

    * decode_number:
        Called for every JSON number. The string representation of
        the number is passed as an argument.  Expects to get a
        Python object in return.  NOTE: If the number looks like a
        float and the &#39;decode_float&#39; hook is set, then this hook
        will not be called.

    * decode_array:
        Called for every JSON array. A Python list is passed as
        the argument, and expects to get a Python object back.
        NOTE: this hook will get called for every array, even
        for nested arrays.

    * decode_object:
        Called for every JSON object.  A Python dictionary is passed
        as the argument, and expects to get a Python object back.
        NOTE: this hook will get called for every object, even
        for nested objects.

    * encode_value:
        Called for every Python object which is to be encoded into JSON.

    * encode_dict:
        Called for every Python dictionary or anything that looks
        like a dictionary.

    * encode_dict_key:
        Called for every dictionary key.

    * encode_sequence:
        Called for every Python sequence-like object that is not a
        dictionary or string. This includes lists and tuples.

    * encode_bytes:
        Called for every Python bytes or bytearray type; or for
        any memoryview with a byte (&#39;B&#39;) item type.  (Python 3 only)

    * encode_default:
        Called for any Python type which can not otherwise be converted
        into JSON, even after applying any other encoding hooks.

    &#34;&#34;&#34;
    if hookname in self.all_hook_names:
        att = hookname + &#34;_hook&#34;
        if function != None and not callable(function):
            raise ValueError(
                &#34;Hook %r must be None or a callable function&#34; % hookname
            )
        setattr(self, att, function)
    else:
        raise ValueError(&#34;Unknown hook name %r&#34; % hookname)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.skip_comment"><code class="name flex">
<span>def <span class="ident">skip_comment</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Skips an ECMAScript comment, either // or /* style.</p>
<p>The contents of the comment are returned as a string, as well
as the index of the character immediately after the comment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_comment(self, state):
    &#34;&#34;&#34;Skips an ECMAScript comment, either // or /* style.

    The contents of the comment are returned as a string, as well
    as the index of the character immediately after the comment.

    &#34;&#34;&#34;
    buf = state.buf
    uniws = self.options.unicode_whitespace
    s = buf.peekstr(2)
    if s != &#34;//&#34; and s != &#34;/*&#34;:
        return None
    state.push_cond(
        self.options.comments, &#34;Comments are not allowed in strict JSON&#34;
    )
    start_position = buf.position
    buf.skip(2)
    multiline = s == &#34;/*&#34;
    saw_close = False
    while not buf.at_end:
        if multiline:
            if buf.peekstr(2) == &#34;*/&#34;:
                buf.skip(2)
                saw_close = True
                break
            elif buf.peekstr(2) == &#34;/*&#34;:
                state.push_error(
                    &#34;Multiline /* */ comments may not nest&#34;,
                    outer_position=start_position,
                    context=&#34;Comment&#34;,
                )
        else:
            if buf.at_eol(uniws):
                buf.skip_to_next_line(uniws)
                saw_close = True
                break
        buf.pop()

    if not saw_close and multiline:
        state.push_error(
            &#34;Comment was never terminated&#34;,
            outer_position=start_position,
            context=&#34;Comment&#34;,
        )
    state.stats.num_comments += 1</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.skipws"><code class="name flex">
<span>def <span class="ident">skipws</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Skips all whitespace, including comments and unicode whitespace</p>
<p>Takes a string and a starting index, and returns the index of the
next non-whitespace character.</p>
<p>If the 'skip_comments' behavior is True and not running in
strict JSON mode, then comments will be skipped over just like
whitespace.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skipws(self, state):
    &#34;&#34;&#34;Skips all whitespace, including comments and unicode whitespace

    Takes a string and a starting index, and returns the index of the
    next non-whitespace character.

    If the &#39;skip_comments&#39; behavior is True and not running in
    strict JSON mode, then comments will be skipped over just like
    whitespace.

    &#34;&#34;&#34;
    buf = state.buf
    uniws = not self.options.unicode_whitespace
    while not buf.at_end:
        c = buf.peekstr(2)
        if c == &#34;/*&#34; or c == &#34;//&#34;:
            cmt = self.skip_comment(state)
        elif buf.at_ws(uniws):
            buf.skipws(uniws)
        else:
            break</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.skipws_nocomments"><code class="name flex">
<span>def <span class="ident">skipws_nocomments</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Skips whitespace (will not allow comments).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skipws_nocomments(self, state):
    &#34;&#34;&#34;Skips whitespace (will not allow comments).&#34;&#34;&#34;
    return state.buf.skipws(not self.options.is_forbid_unicode_whitespace)</code></pre>
</details>
</dd>
<dt id="demjson3.JSON.try_encode_default"><code class="name flex">
<span>def <span class="ident">try_encode_default</span></span>(<span>self, obj, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_encode_default(self, obj, state):
    orig_obj = obj
    if self.has_hook(&#34;encode_default&#34;):
        try:
            obj = self.call_hook(&#34;encode_default&#34;, obj)
        except JSONSkipHook:
            pass
        else:
            if obj is not orig_obj:
                # Hook made a transformation, re-encode it
                return self._do_encode(obj, state)

    # End of the road.
    raise JSONEncodeError(&#34;can not encode object into a JSON representation&#34;, obj)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.JSONAbort"><code class="flex name class">
<span>class <span class="ident">JSONAbort</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all JSON-related exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONAbort(JSONException):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="demjson3.JSONDecodeError"><code class="flex name class">
<span>class <span class="ident">JSONDecodeError</span></span>
<span>(</span><span>message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception class raised when a JSON decoding error (syntax error) occurs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONDecodeError(JSONError):
    &#34;&#34;&#34;An exception class raised when a JSON decoding error (syntax error) occurs.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONError" href="#demjson3.JSONError">JSONError</a></li>
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="demjson3.JSONDecodeHookError" href="#demjson3.JSONDecodeHookError">JSONDecodeHookError</a></li>
</ul>
</dd>
<dt id="demjson3.JSONDecodeHookError"><code class="flex name class">
<span>class <span class="ident">JSONDecodeHookError</span></span>
<span>(</span><span>hook_name, exc_info, encoded_obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception that occured within a decoder hook.</p>
<p>The original exception is available in the 'hook_exception' attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONDecodeHookError(JSONDecodeError):
    &#34;&#34;&#34;An exception that occured within a decoder hook.

    The original exception is available in the &#39;hook_exception&#39; attribute.
    &#34;&#34;&#34;

    def __init__(self, hook_name, exc_info, encoded_obj, *args, **kwargs):
        self.hook_name = hook_name
        if not exc_info:
            exc_info = (None, None, None)
        exc_type, self.hook_exception, self.hook_traceback = exc_info
        self.object_type = type(encoded_obj)
        msg = &#34;Hook %s raised %r while decoding type &lt;%s&gt;&#34; % (
            hook_name,
            self.hook_exception.__class__.__name__
            if self.hook_exception is not None
            else None,
            self.object_type.__name__,
        )
        if len(args) &gt;= 1:
            msg += &#34;: &#34; + str(args[0])
            args = args[1:]
        super(JSONDecodeHookError, self).__init__(msg, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONDecodeError" href="#demjson3.JSONDecodeError">JSONDecodeError</a></li>
<li><a title="demjson3.JSONError" href="#demjson3.JSONError">JSONError</a></li>
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="demjson3.JSONEncodeError"><code class="flex name class">
<span>class <span class="ident">JSONEncodeError</span></span>
<span>(</span><span>message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception class raised when a python object can not be encoded as a JSON string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONEncodeError(JSONError):
    &#34;&#34;&#34;An exception class raised when a python object can not be encoded as a JSON string.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONError" href="#demjson3.JSONError">JSONError</a></li>
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="demjson3.JSONEncodeHookError" href="#demjson3.JSONEncodeHookError">JSONEncodeHookError</a></li>
</ul>
</dd>
<dt id="demjson3.JSONEncodeHookError"><code class="flex name class">
<span>class <span class="ident">JSONEncodeHookError</span></span>
<span>(</span><span>hook_name, exc_info, encoded_obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception that occured within an encoder hook.</p>
<p>The original exception is available in the 'hook_exception' attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONEncodeHookError(JSONEncodeError):
    &#34;&#34;&#34;An exception that occured within an encoder hook.

    The original exception is available in the &#39;hook_exception&#39; attribute.
    &#34;&#34;&#34;

    def __init__(self, hook_name, exc_info, encoded_obj, *args, **kwargs):
        self.hook_name = hook_name
        if not exc_info:
            exc_info = (None, None, None)
        exc_type, self.hook_exception, self.hook_traceback = exc_info
        self.object_type = type(encoded_obj)
        msg = &#34;Hook %s raised %r while encoding type &lt;%s&gt;&#34; % (
            self.hook_name,
            self.hook_exception.__class__.__name__
            if self.hook_exception is not None
            else None,
            self.object_type.__name__,
        )
        if len(args) &gt;= 1:
            msg += &#34;: &#34; + str(args[0])
            args = args[1:]
        super(JSONEncodeHookError, self).__init__(msg, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONEncodeError" href="#demjson3.JSONEncodeError">JSONEncodeError</a></li>
<li><a title="demjson3.JSONError" href="#demjson3.JSONError">JSONError</a></li>
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="demjson3.JSONError"><code class="flex name class">
<span>class <span class="ident">JSONError</span></span>
<span>(</span><span>message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all JSON-related errors.</p>
<p>In addition to standard Python exceptions, these exceptions may
also have additional properties:</p>
<pre><code>* severity - One of: 'fatal', 'error', 'warning', 'info'
* position - An indication of the position in the input where the error occured.
* outer_position - A secondary position (optional) that gives
  the location of the outer data item in which the error
  occured, such as the beginning of a string or an array.
* context_description - A string that identifies the context
  in which the error occured.  Default is "Context".
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONError(JSONException):
    &#34;&#34;&#34;Base class for all JSON-related errors.

    In addition to standard Python exceptions, these exceptions may
    also have additional properties:

        * severity - One of: &#39;fatal&#39;, &#39;error&#39;, &#39;warning&#39;, &#39;info&#39;
        * position - An indication of the position in the input where the error occured.
        * outer_position - A secondary position (optional) that gives
          the location of the outer data item in which the error
          occured, such as the beginning of a string or an array.
        * context_description - A string that identifies the context
          in which the error occured.  Default is &#34;Context&#34;.
    &#34;&#34;&#34;

    severities = frozenset([&#34;fatal&#34;, &#34;error&#34;, &#34;warning&#34;, &#34;info&#34;])

    def __init__(self, message, *args, **kwargs):
        self.severity = &#34;error&#34;
        self._position = None
        self.outer_position = None
        self.context_description = None
        for kw, val in list(kwargs.items()):
            if kw == &#34;severity&#34;:
                if val not in self.severities:
                    raise TypeError(
                        &#34;%s given invalid severity %r&#34; % (self.__class__.__name__, val)
                    )
                self.severity = val
            elif kw == &#34;position&#34;:
                self.position = val
            elif kw == &#34;outer_position&#34;:
                self.outer_position = val
            elif kw == &#34;context_description&#34; or kw == &#34;context&#34;:
                self.context_description = val
            else:
                raise TypeError(
                    &#34;%s does not accept %r keyword argument&#34;
                    % (self.__class__.__name__, kw)
                )
        super(JSONError, self).__init__(message, *args)
        self.message = message

    @property
    def position(self):
        return self._position

    @position.setter
    def position(self, pos):
        if pos == 0:
            self._position = 0  # position_marker() # start of input
        else:
            self._position = pos

    def __repr__(self):
        s = &#34;%s(%r&#34; % (self.__class__.__name__, self.message)
        for a in self.args[1:]:
            s += &#34;, %r&#34; % (a,)
        if self.position:
            s += &#34;, position=%r&#34; % (self.position,)
        if self.outer_position:
            s += &#34;, outer_position=%r&#34; % (self.outer_position,)
        s += &#34;, severity=%r)&#34; % (self.severity,)
        return s

    def pretty_description(self, show_positions=True, filename=None):
        if filename:
            pfx = filename.rstrip().rstrip(&#34;:&#34;) + &#34;:&#34;
        else:
            pfx = &#34;&#34;
        # Print file position as numeric abbreviation
        err = pfx
        if self.position == 0:
            err += &#34;0:0:&#34;
        elif self.position:
            err += &#34;%d:%d:&#34; % (self.position.line, self.position.column)
        else:
            err += &#34;    &#34;
        # Print severity and main error message
        err += &#34; %s: %s&#34; % (self.severity.capitalize(), self.message)
        if len(self.args) &gt; 1:
            err += &#34;: &#34;
            for anum, a in enumerate(self.args[1:]):
                if anum &gt; 1:
                    err += &#34;, &#34;
                astr = repr(a)
                if len(astr) &gt; 30:
                    astr = astr[:30] + &#34;...&#34;
                err += astr
        # Print out exception chain
        e2 = self
        while e2:
            if hasattr(e2, &#34;__cause__&#34;) and isinstance(e2.__cause__, Exception):
                e2 = e2.__cause__
                e2desc = str(e2).strip()
                if not e2desc:
                    e2desc = repr(e2).strip()
                err += &#34;\n   |  Cause: %s&#34; % e2desc.strip().replace(
                    &#34;\n&#34;, &#34;\n   |         &#34;
                )
            else:
                e2 = None
        # Show file position
        if show_positions and self.position is not None:
            if self.position == 0:
                err += &#34;\n   |  At start of input&#34;
            else:
                err += &#34;\n   |  At %s&#34; % (self.position.describe(show_text=False),)
                if self.position.text_after:
                    err += &#34;\n   |    near text: %r&#34; % (self.position.text_after,)
        # Show context
        if show_positions and self.outer_position:
            if self.context_description:
                cdesc = self.context_description.capitalize()
            else:
                cdesc = &#34;Context&#34;
            err += &#34;\n   |  %s started at %s&#34; % (
                cdesc,
                self.outer_position.describe(show_text=False),
            )
            if self.outer_position.text_after:
                err += &#34;\n   |    with text: %r&#34; % (self.outer_position.text_after,)
        return err</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="demjson3.JSONDecodeError" href="#demjson3.JSONDecodeError">JSONDecodeError</a></li>
<li><a title="demjson3.JSONEncodeError" href="#demjson3.JSONEncodeError">JSONEncodeError</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="demjson3.JSONError.severities"><code class="name">var <span class="ident">severities</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.JSONError.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    return self._position</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.JSONError.pretty_description"><code class="name flex">
<span>def <span class="ident">pretty_description</span></span>(<span>self, show_positions=True, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_description(self, show_positions=True, filename=None):
    if filename:
        pfx = filename.rstrip().rstrip(&#34;:&#34;) + &#34;:&#34;
    else:
        pfx = &#34;&#34;
    # Print file position as numeric abbreviation
    err = pfx
    if self.position == 0:
        err += &#34;0:0:&#34;
    elif self.position:
        err += &#34;%d:%d:&#34; % (self.position.line, self.position.column)
    else:
        err += &#34;    &#34;
    # Print severity and main error message
    err += &#34; %s: %s&#34; % (self.severity.capitalize(), self.message)
    if len(self.args) &gt; 1:
        err += &#34;: &#34;
        for anum, a in enumerate(self.args[1:]):
            if anum &gt; 1:
                err += &#34;, &#34;
            astr = repr(a)
            if len(astr) &gt; 30:
                astr = astr[:30] + &#34;...&#34;
            err += astr
    # Print out exception chain
    e2 = self
    while e2:
        if hasattr(e2, &#34;__cause__&#34;) and isinstance(e2.__cause__, Exception):
            e2 = e2.__cause__
            e2desc = str(e2).strip()
            if not e2desc:
                e2desc = repr(e2).strip()
            err += &#34;\n   |  Cause: %s&#34; % e2desc.strip().replace(
                &#34;\n&#34;, &#34;\n   |         &#34;
            )
        else:
            e2 = None
    # Show file position
    if show_positions and self.position is not None:
        if self.position == 0:
            err += &#34;\n   |  At start of input&#34;
        else:
            err += &#34;\n   |  At %s&#34; % (self.position.describe(show_text=False),)
            if self.position.text_after:
                err += &#34;\n   |    near text: %r&#34; % (self.position.text_after,)
    # Show context
    if show_positions and self.outer_position:
        if self.context_description:
            cdesc = self.context_description.capitalize()
        else:
            cdesc = &#34;Context&#34;
        err += &#34;\n   |  %s started at %s&#34; % (
            cdesc,
            self.outer_position.describe(show_text=False),
        )
        if self.outer_position.text_after:
            err += &#34;\n   |    with text: %r&#34; % (self.outer_position.text_after,)
    return err</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.JSONException"><code class="flex name class">
<span>class <span class="ident">JSONException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all JSON-related exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONException(Exception):
    &#34;&#34;&#34;Base class for all JSON-related exceptions.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="demjson3.JSONAbort" href="#demjson3.JSONAbort">JSONAbort</a></li>
<li><a title="demjson3.JSONError" href="#demjson3.JSONError">JSONError</a></li>
<li><a title="demjson3.JSONSkipHook" href="#demjson3.JSONSkipHook">JSONSkipHook</a></li>
<li><a title="demjson3.JSONStopProcessing" href="#demjson3.JSONStopProcessing">JSONStopProcessing</a></li>
</ul>
</dd>
<dt id="demjson3.JSONSkipHook"><code class="flex name class">
<span>class <span class="ident">JSONSkipHook</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception to be raised by user-defined code within hook
callbacks to indicate the callback does not want to handle the
situation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONSkipHook(JSONException):
    &#34;&#34;&#34;An exception to be raised by user-defined code within hook
    callbacks to indicate the callback does not want to handle the
    situation.

    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="demjson3.JSONStopProcessing"><code class="flex name class">
<span>class <span class="ident">JSONStopProcessing</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Can be raised by anyplace, including inside a hook function, to
cause the entire encode or decode process to immediately stop
with an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONStopProcessing(JSONException):
    &#34;&#34;&#34;Can be raised by anyplace, including inside a hook function, to
    cause the entire encode or decode process to immediately stop
    with an error.

    &#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="demjson3.buffered_stream"><code class="flex name class">
<span>class <span class="ident">buffered_stream</span></span>
<span>(</span><span>txt='', encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A helper class for the JSON parser.</p>
<p>It allows for reading an input document, while handling some
low-level Unicode issues as well as tracking the current position
in terms of line and column position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class buffered_stream(object):
    &#34;&#34;&#34;A helper class for the JSON parser.

    It allows for reading an input document, while handling some
    low-level Unicode issues as well as tracking the current position
    in terms of line and column position.

    &#34;&#34;&#34;

    def __init__(self, txt=&#34;&#34;, encoding=None):
        self.reset()
        self.set_text(txt, encoding)

    def reset(self):
        &#34;&#34;&#34;Clears the state to nothing.&#34;&#34;&#34;
        self.__pos = position_marker()
        self.__saved_pos = []  # Stack of saved positions
        self.__bom = helpers.make_raw_bytes(
            []
        )  # contains copy of byte-order mark, if any
        self.__codec = None  # The CodecInfo
        self.__encoding = None  # The name of the codec&#39;s encoding
        self.__input_is_bytes = False
        self.__rawbuf = None
        self.__raw_bytes = None
        self.__cmax = 0
        self.num_ws_skipped = 0

    def save_position(self):
        self.__saved_pos.append(self.__pos.copy())
        return True

    def clear_saved_position(self):
        if self.__saved_pos:
            self.__saved_pos.pop()
            return True
        else:
            return False

    def restore_position(self):
        try:
            old_pos = self.__saved_pos.pop()  # Can raise IndexError
        except IndexError as err:
            raise IndexError(&#34;Attempt to restore buffer position that was never saved&#34;)
        else:
            self.__pos = old_pos
            return True

    def _find_codec(self, encoding):
        if encoding is None:
            self.__codec = None
            self.__encoding = None
        elif isinstance(encoding, codecs.CodecInfo):
            self.__codec = encoding
            self.__encoding = self.__codec.name
        else:
            self.__encoding = encoding
            self.__codec = helpers.lookup_codec(encoding)
            if not self.__codec:
                raise JSONDecodeError(
                    &#34;no codec available for character encoding&#34;, encoding
                )
        return self.__codec

    def set_text(self, txt, encoding=None):
        &#34;&#34;&#34;Changes the input text document and rewinds the position to
        the start of the new document.

        &#34;&#34;&#34;
        import sys

        self.rewind()
        self.__codec = None
        self.__bom = None
        self.__rawbuf = &#34;&#34;
        self.__cmax = 0  # max number of chars in input
        try:
            decoded = helpers.unicode_decode(txt, encoding)
        except JSONError:
            raise
        except Exception as err:
            # Re-raise as a JSONDecodeError
            newerr = JSONDecodeError(&#34;a Unicode decoding error occurred&#34;)
            raise newerr from err
        else:
            self.__codec = decoded.codec
            self.__bom = decoded.bom
            self.__rawbuf = decoded.string
            self.__cmax = len(self.__rawbuf)

    def __repr__(self):
        return &#34;&lt;%s at %r text %r&gt;&#34; % (
            self.__class__.__name__,
            self.__pos,
            self.text_context,
        )

    def rewind(self):
        &#34;&#34;&#34;Resets the position back to the start of the input text.&#34;&#34;&#34;
        self.__pos.rewind()

    @property
    def codec(self):
        &#34;&#34;&#34;The codec object used to perform Unicode decoding, or None.&#34;&#34;&#34;
        return self.__codec

    @property
    def bom(self):
        &#34;&#34;&#34;The Unicode Byte-Order Mark (BOM), if any, that was present
        at the start of the input text.  The returned BOM is a string
        of the raw bytes, and is not Unicode-decoded.

        &#34;&#34;&#34;
        return self.__bom

    @property
    def cpos(self):
        &#34;&#34;&#34;The current character offset from the start of the document.&#34;&#34;&#34;
        return self.__pos.char_position

    @property
    def position(self):
        &#34;&#34;&#34;The current position (as a position_marker object).
        Returns a copy.

        &#34;&#34;&#34;
        p = self.__pos.copy()
        p.text_after = self.text_context
        p.at_end = self.at_end
        return p

    @property
    def at_start(self):
        &#34;&#34;&#34;Returns True if the position is currently at the start of
        the document, or False otherwise.

        &#34;&#34;&#34;
        return self.__pos.at_start

    @property
    def at_end(self):
        &#34;&#34;&#34;Returns True if the position is currently at the end of the
        document, of False otherwise.

        &#34;&#34;&#34;
        c = self.peek()
        return not c

    def at_ws(self, allow_unicode_whitespace=True):
        &#34;&#34;&#34;Returns True if the current position contains a white-space
        character.

        &#34;&#34;&#34;
        c = self.peek()
        if not c:
            return False
        elif allow_unicode_whitespace:
            return helpers.char_is_unicode_ws(c)
        else:
            return helpers.char_is_json_ws(c)

    def at_eol(self, allow_unicode_eol=True):
        &#34;&#34;&#34;Returns True if the current position contains an
        end-of-line control character.

        &#34;&#34;&#34;
        c = self.peek()
        if not c:
            return True  # End of file is treated as end of line
        elif allow_unicode_eol:
            return helpers.char_is_unicode_eol(c)
        else:
            return helpers.char_is_json_eol(c)

    def peek(self, offset=0):
        &#34;&#34;&#34;Returns the character at the current position, or at a
        given offset away from the current position.  If the position
        is beyond the limits of the document size, then an empty
        string &#39;&#39; is returned.

        &#34;&#34;&#34;
        i = self.cpos + offset
        if i &lt; 0 or i &gt;= self.__cmax:
            return &#34;&#34;
        return self.__rawbuf[i]

    def peekstr(self, span=1, offset=0):
        &#34;&#34;&#34;Returns one or more characters starting at the current
        position, or at a given offset away from the current position,
        and continuing for the given span length.  If the offset and
        span go outside the limit of the current document size, then
        the returned string may be shorter than the requested span
        length.

        &#34;&#34;&#34;
        i = self.cpos + offset
        j = i + span
        if i &lt; 0 or i &gt;= self.__cmax:
            return &#34;&#34;
        return self.__rawbuf[i:j]

    @property
    def text_context(self, context_size=20):
        &#34;&#34;&#34;A short human-readable textual excerpt of the document at
        the current position, in English.

        &#34;&#34;&#34;
        context_size = max(context_size, 4)
        s = self.peekstr(context_size + 1)
        if not s:
            return &#34;&#34;
        if len(s) &gt; context_size:
            s = s[: context_size - 3] + &#34;...&#34;
        return s

    def startswith(self, s):
        &#34;&#34;&#34;Determines if the text at the current position starts with
        the given string.

        See also method: pop_if_startswith()

        &#34;&#34;&#34;
        s2 = self.peekstr(len(s))
        return s == s2

    def skip(self, span=1):
        &#34;&#34;&#34;Advances the current position by one (or the given number)
        of characters.  Will not advance beyond the end of the
        document.  Returns the number of characters skipped.

        &#34;&#34;&#34;

        i = self.cpos
        self.__pos.advance(self.peekstr(span))
        return self.cpos - i

    def skipuntil(self, testfn):
        &#34;&#34;&#34;Advances the current position until a given predicate test
        function succeeds, or the end of the document is reached.

        Returns the actual number of characters skipped.

        The provided test function should take a single unicode
        character and return a boolean value, such as:

            lambda c : c == &#39;.&#39;   # Skip to next period

        See also methods: skipwhile() and popuntil()

        &#34;&#34;&#34;
        i = self.cpos
        while True:
            c = self.peek()
            if not c or testfn(c):
                break
            else:
                self.__pos.advance(c)
        return self.cpos - i

    def skipwhile(self, testfn):
        &#34;&#34;&#34;Advances the current position until a given predicate test
        function fails, or the end of the document is reached.

        Returns the actual number of characters skipped.

        The provided test function should take a single unicode
        character and return a boolean value, such as:

            lambda c : c.isdigit()   # Skip all digits

        See also methods: skipuntil() and popwhile()

        &#34;&#34;&#34;
        return self.skipuntil(lambda c: not testfn(c))

    def skip_to_next_line(self, allow_unicode_eol=True):
        &#34;&#34;&#34;Advances the current position to the start of the next
        line.  Will not advance beyond the end of the file.  Note that
        the two-character sequence CR+LF is recognized as being just a
        single end-of-line marker.

        &#34;&#34;&#34;
        ln = self.__pos.line
        while True:
            c = self.pop()
            if not c or self.__pos.line &gt; ln:
                if c == &#34;\r&#34; and self.peek() == &#34;\n&#34;:
                    self.skip()
                break

    def skipws(self, allow_unicode_whitespace=True):
        &#34;&#34;&#34;Advances the current position past all whitespace, or until
        the end of the document is reached.

        &#34;&#34;&#34;
        if allow_unicode_whitespace:
            n = self.skipwhile(helpers.char_is_unicode_ws)
        else:
            n = self.skipwhile(helpers.char_is_json_ws)
        self.num_ws_skipped += n
        return n

    def pop(self):
        &#34;&#34;&#34;Returns the character at the current position and advances
        the position to the next character.  At the end of the
        document this function returns an empty string.

        &#34;&#34;&#34;
        c = self.peek()
        if c:
            self.__pos.advance(c)
        return c

    def popstr(self, span=1, offset=0):
        &#34;&#34;&#34;Returns a string of one or more characters starting at the
        current position, and advances the position to the following
        character after the span.  Will not go beyond the end of the
        document, so the returned string may be shorter than the
        requested span.

        &#34;&#34;&#34;
        s = self.peekstr(span)
        if s:
            self.__pos.advance(s)
        return s

    def popif(self, testfn):
        &#34;&#34;&#34;Just like the pop() function, but only returns the
        character if the given predicate test function succeeds.
        &#34;&#34;&#34;
        c = self.peek()
        if c and testfn(c):
            self.__pos.advance(c)
            return c
        return &#34;&#34;

    def pop_while_in(self, chars):
        &#34;&#34;&#34;Pops a sequence of characters at the current position
        as long as each of them is in the given set of characters.

        &#34;&#34;&#34;
        if not isinstance(chars, (set, frozenset)):
            chars = set(chars)
        c = self.peek()
        if c and c in chars:
            s = self.popwhile(lambda c: c and c in chars)
            return s
        return None

    def pop_identifier(self, match=None):
        &#34;&#34;&#34;Pops the sequence of characters at the current position
        that match the syntax for a JavaScript identifier.

        &#34;&#34;&#34;
        c = self.peek()
        if c and helpers.char_is_identifier_leader(c):
            s = self.popwhile(helpers.char_is_identifier_tail)
            return s
        return None

    def pop_if_startswith(self, s):
        &#34;&#34;&#34;Pops the sequence of characters if they match the given string.

        See also method: startswith()

        &#34;&#34;&#34;
        s2 = self.peekstr(len(s))
        if s2 != s:
            return None
        self.__pos.advance(s2)
        return s2

    def popwhile(self, testfn, maxchars=None):
        &#34;&#34;&#34;Pops all the characters starting at the current position as
        long as each character passes the given predicate function
        test.  If maxchars a numeric value instead of None then then
        no more than that number of characters will be popped
        regardless of the predicate test.

        See also methods: skipwhile() and popuntil()

        &#34;&#34;&#34;
        s = []
        i = 0
        while maxchars is None or i &lt; maxchars:
            c = self.popif(testfn)
            if not c:
                break
            s.append(c)
            i += 1
        return &#34;&#34;.join(s)

    def popuntil(self, testfn, maxchars=None):
        &#34;&#34;&#34;Just like popwhile() method except the predicate function
        should return True to stop the sequence rather than False.

        See also methods: skipuntil() and popwhile()

        &#34;&#34;&#34;
        return self.popwhile(lambda c: not testfn(c), maxchars=maxchars)

    def __getitem__(self, index):
        &#34;&#34;&#34;Returns the character at the given index relative to the current position.

        If the index goes beyond the end of the input, or prior to the
        start when negative, then &#39;&#39; is returned.

        If the index provided is a slice object, then that range of
        characters is returned as a string. Note that a stride value other
        than 1 is not supported in the slice.  To use a slice, do:

            s = my_stream[ 1:4 ]

        &#34;&#34;&#34;
        if isinstance(index, slice):
            return self.peekstr(index.stop - index.start, index.start)
        else:
            return self.peek(index)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.buffered_stream.at_end"><code class="name">var <span class="ident">at_end</span></code></dt>
<dd>
<div class="desc"><p>Returns True if the position is currently at the end of the
document, of False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def at_end(self):
    &#34;&#34;&#34;Returns True if the position is currently at the end of the
    document, of False otherwise.

    &#34;&#34;&#34;
    c = self.peek()
    return not c</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.at_start"><code class="name">var <span class="ident">at_start</span></code></dt>
<dd>
<div class="desc"><p>Returns True if the position is currently at the start of
the document, or False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def at_start(self):
    &#34;&#34;&#34;Returns True if the position is currently at the start of
    the document, or False otherwise.

    &#34;&#34;&#34;
    return self.__pos.at_start</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.bom"><code class="name">var <span class="ident">bom</span></code></dt>
<dd>
<div class="desc"><p>The Unicode Byte-Order Mark (BOM), if any, that was present
at the start of the input text.
The returned BOM is a string
of the raw bytes, and is not Unicode-decoded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bom(self):
    &#34;&#34;&#34;The Unicode Byte-Order Mark (BOM), if any, that was present
    at the start of the input text.  The returned BOM is a string
    of the raw bytes, and is not Unicode-decoded.

    &#34;&#34;&#34;
    return self.__bom</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.codec"><code class="name">var <span class="ident">codec</span></code></dt>
<dd>
<div class="desc"><p>The codec object used to perform Unicode decoding, or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def codec(self):
    &#34;&#34;&#34;The codec object used to perform Unicode decoding, or None.&#34;&#34;&#34;
    return self.__codec</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.cpos"><code class="name">var <span class="ident">cpos</span></code></dt>
<dd>
<div class="desc"><p>The current character offset from the start of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpos(self):
    &#34;&#34;&#34;The current character offset from the start of the document.&#34;&#34;&#34;
    return self.__pos.char_position</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"><p>The current position (as a position_marker object).
Returns a copy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    &#34;&#34;&#34;The current position (as a position_marker object).
    Returns a copy.

    &#34;&#34;&#34;
    p = self.__pos.copy()
    p.text_after = self.text_context
    p.at_end = self.at_end
    return p</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.text_context"><code class="name">var <span class="ident">text_context</span></code></dt>
<dd>
<div class="desc"><p>A short human-readable textual excerpt of the document at
the current position, in English.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text_context(self, context_size=20):
    &#34;&#34;&#34;A short human-readable textual excerpt of the document at
    the current position, in English.

    &#34;&#34;&#34;
    context_size = max(context_size, 4)
    s = self.peekstr(context_size + 1)
    if not s:
        return &#34;&#34;
    if len(s) &gt; context_size:
        s = s[: context_size - 3] + &#34;...&#34;
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.buffered_stream.at_eol"><code class="name flex">
<span>def <span class="ident">at_eol</span></span>(<span>self, allow_unicode_eol=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the current position contains an
end-of-line control character.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_eol(self, allow_unicode_eol=True):
    &#34;&#34;&#34;Returns True if the current position contains an
    end-of-line control character.

    &#34;&#34;&#34;
    c = self.peek()
    if not c:
        return True  # End of file is treated as end of line
    elif allow_unicode_eol:
        return helpers.char_is_unicode_eol(c)
    else:
        return helpers.char_is_json_eol(c)</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.at_ws"><code class="name flex">
<span>def <span class="ident">at_ws</span></span>(<span>self, allow_unicode_whitespace=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the current position contains a white-space
character.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_ws(self, allow_unicode_whitespace=True):
    &#34;&#34;&#34;Returns True if the current position contains a white-space
    character.

    &#34;&#34;&#34;
    c = self.peek()
    if not c:
        return False
    elif allow_unicode_whitespace:
        return helpers.char_is_unicode_ws(c)
    else:
        return helpers.char_is_json_ws(c)</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.clear_saved_position"><code class="name flex">
<span>def <span class="ident">clear_saved_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_saved_position(self):
    if self.__saved_pos:
        self.__saved_pos.pop()
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.peek"><code class="name flex">
<span>def <span class="ident">peek</span></span>(<span>self, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the character at the current position, or at a
given offset away from the current position.
If the position
is beyond the limits of the document size, then an empty
string '' is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peek(self, offset=0):
    &#34;&#34;&#34;Returns the character at the current position, or at a
    given offset away from the current position.  If the position
    is beyond the limits of the document size, then an empty
    string &#39;&#39; is returned.

    &#34;&#34;&#34;
    i = self.cpos + offset
    if i &lt; 0 or i &gt;= self.__cmax:
        return &#34;&#34;
    return self.__rawbuf[i]</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.peekstr"><code class="name flex">
<span>def <span class="ident">peekstr</span></span>(<span>self, span=1, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns one or more characters starting at the current
position, or at a given offset away from the current position,
and continuing for the given span length.
If the offset and
span go outside the limit of the current document size, then
the returned string may be shorter than the requested span
length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peekstr(self, span=1, offset=0):
    &#34;&#34;&#34;Returns one or more characters starting at the current
    position, or at a given offset away from the current position,
    and continuing for the given span length.  If the offset and
    span go outside the limit of the current document size, then
    the returned string may be shorter than the requested span
    length.

    &#34;&#34;&#34;
    i = self.cpos + offset
    j = i + span
    if i &lt; 0 or i &gt;= self.__cmax:
        return &#34;&#34;
    return self.__rawbuf[i:j]</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the character at the current position and advances
the position to the next character.
At the end of the
document this function returns an empty string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self):
    &#34;&#34;&#34;Returns the character at the current position and advances
    the position to the next character.  At the end of the
    document this function returns an empty string.

    &#34;&#34;&#34;
    c = self.peek()
    if c:
        self.__pos.advance(c)
    return c</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.pop_identifier"><code class="name flex">
<span>def <span class="ident">pop_identifier</span></span>(<span>self, match=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pops the sequence of characters at the current position
that match the syntax for a JavaScript identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_identifier(self, match=None):
    &#34;&#34;&#34;Pops the sequence of characters at the current position
    that match the syntax for a JavaScript identifier.

    &#34;&#34;&#34;
    c = self.peek()
    if c and helpers.char_is_identifier_leader(c):
        s = self.popwhile(helpers.char_is_identifier_tail)
        return s
    return None</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.pop_if_startswith"><code class="name flex">
<span>def <span class="ident">pop_if_startswith</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Pops the sequence of characters if they match the given string.</p>
<p>See also method: startswith()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_if_startswith(self, s):
    &#34;&#34;&#34;Pops the sequence of characters if they match the given string.

    See also method: startswith()

    &#34;&#34;&#34;
    s2 = self.peekstr(len(s))
    if s2 != s:
        return None
    self.__pos.advance(s2)
    return s2</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.pop_while_in"><code class="name flex">
<span>def <span class="ident">pop_while_in</span></span>(<span>self, chars)</span>
</code></dt>
<dd>
<div class="desc"><p>Pops a sequence of characters at the current position
as long as each of them is in the given set of characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_while_in(self, chars):
    &#34;&#34;&#34;Pops a sequence of characters at the current position
    as long as each of them is in the given set of characters.

    &#34;&#34;&#34;
    if not isinstance(chars, (set, frozenset)):
        chars = set(chars)
    c = self.peek()
    if c and c in chars:
        s = self.popwhile(lambda c: c and c in chars)
        return s
    return None</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.popif"><code class="name flex">
<span>def <span class="ident">popif</span></span>(<span>self, testfn)</span>
</code></dt>
<dd>
<div class="desc"><p>Just like the pop() function, but only returns the
character if the given predicate test function succeeds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popif(self, testfn):
    &#34;&#34;&#34;Just like the pop() function, but only returns the
    character if the given predicate test function succeeds.
    &#34;&#34;&#34;
    c = self.peek()
    if c and testfn(c):
        self.__pos.advance(c)
        return c
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.popstr"><code class="name flex">
<span>def <span class="ident">popstr</span></span>(<span>self, span=1, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a string of one or more characters starting at the
current position, and advances the position to the following
character after the span.
Will not go beyond the end of the
document, so the returned string may be shorter than the
requested span.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popstr(self, span=1, offset=0):
    &#34;&#34;&#34;Returns a string of one or more characters starting at the
    current position, and advances the position to the following
    character after the span.  Will not go beyond the end of the
    document, so the returned string may be shorter than the
    requested span.

    &#34;&#34;&#34;
    s = self.peekstr(span)
    if s:
        self.__pos.advance(s)
    return s</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.popuntil"><code class="name flex">
<span>def <span class="ident">popuntil</span></span>(<span>self, testfn, maxchars=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Just like popwhile() method except the predicate function
should return True to stop the sequence rather than False.</p>
<p>See also methods: skipuntil() and popwhile()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popuntil(self, testfn, maxchars=None):
    &#34;&#34;&#34;Just like popwhile() method except the predicate function
    should return True to stop the sequence rather than False.

    See also methods: skipuntil() and popwhile()

    &#34;&#34;&#34;
    return self.popwhile(lambda c: not testfn(c), maxchars=maxchars)</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.popwhile"><code class="name flex">
<span>def <span class="ident">popwhile</span></span>(<span>self, testfn, maxchars=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pops all the characters starting at the current position as
long as each character passes the given predicate function
test.
If maxchars a numeric value instead of None then then
no more than that number of characters will be popped
regardless of the predicate test.</p>
<p>See also methods: skipwhile() and popuntil()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popwhile(self, testfn, maxchars=None):
    &#34;&#34;&#34;Pops all the characters starting at the current position as
    long as each character passes the given predicate function
    test.  If maxchars a numeric value instead of None then then
    no more than that number of characters will be popped
    regardless of the predicate test.

    See also methods: skipwhile() and popuntil()

    &#34;&#34;&#34;
    s = []
    i = 0
    while maxchars is None or i &lt; maxchars:
        c = self.popif(testfn)
        if not c:
            break
        s.append(c)
        i += 1
    return &#34;&#34;.join(s)</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the state to nothing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Clears the state to nothing.&#34;&#34;&#34;
    self.__pos = position_marker()
    self.__saved_pos = []  # Stack of saved positions
    self.__bom = helpers.make_raw_bytes(
        []
    )  # contains copy of byte-order mark, if any
    self.__codec = None  # The CodecInfo
    self.__encoding = None  # The name of the codec&#39;s encoding
    self.__input_is_bytes = False
    self.__rawbuf = None
    self.__raw_bytes = None
    self.__cmax = 0
    self.num_ws_skipped = 0</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.restore_position"><code class="name flex">
<span>def <span class="ident">restore_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_position(self):
    try:
        old_pos = self.__saved_pos.pop()  # Can raise IndexError
    except IndexError as err:
        raise IndexError(&#34;Attempt to restore buffer position that was never saved&#34;)
    else:
        self.__pos = old_pos
        return True</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.rewind"><code class="name flex">
<span>def <span class="ident">rewind</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the position back to the start of the input text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewind(self):
    &#34;&#34;&#34;Resets the position back to the start of the input text.&#34;&#34;&#34;
    self.__pos.rewind()</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.save_position"><code class="name flex">
<span>def <span class="ident">save_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_position(self):
    self.__saved_pos.append(self.__pos.copy())
    return True</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.set_text"><code class="name flex">
<span>def <span class="ident">set_text</span></span>(<span>self, txt, encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the input text document and rewinds the position to
the start of the new document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text(self, txt, encoding=None):
    &#34;&#34;&#34;Changes the input text document and rewinds the position to
    the start of the new document.

    &#34;&#34;&#34;
    import sys

    self.rewind()
    self.__codec = None
    self.__bom = None
    self.__rawbuf = &#34;&#34;
    self.__cmax = 0  # max number of chars in input
    try:
        decoded = helpers.unicode_decode(txt, encoding)
    except JSONError:
        raise
    except Exception as err:
        # Re-raise as a JSONDecodeError
        newerr = JSONDecodeError(&#34;a Unicode decoding error occurred&#34;)
        raise newerr from err
    else:
        self.__codec = decoded.codec
        self.__bom = decoded.bom
        self.__rawbuf = decoded.string
        self.__cmax = len(self.__rawbuf)</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.skip"><code class="name flex">
<span>def <span class="ident">skip</span></span>(<span>self, span=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Advances the current position by one (or the given number)
of characters.
Will not advance beyond the end of the
document.
Returns the number of characters skipped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip(self, span=1):
    &#34;&#34;&#34;Advances the current position by one (or the given number)
    of characters.  Will not advance beyond the end of the
    document.  Returns the number of characters skipped.

    &#34;&#34;&#34;

    i = self.cpos
    self.__pos.advance(self.peekstr(span))
    return self.cpos - i</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.skip_to_next_line"><code class="name flex">
<span>def <span class="ident">skip_to_next_line</span></span>(<span>self, allow_unicode_eol=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Advances the current position to the start of the next
line.
Will not advance beyond the end of the file.
Note that
the two-character sequence CR+LF is recognized as being just a
single end-of-line marker.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skip_to_next_line(self, allow_unicode_eol=True):
    &#34;&#34;&#34;Advances the current position to the start of the next
    line.  Will not advance beyond the end of the file.  Note that
    the two-character sequence CR+LF is recognized as being just a
    single end-of-line marker.

    &#34;&#34;&#34;
    ln = self.__pos.line
    while True:
        c = self.pop()
        if not c or self.__pos.line &gt; ln:
            if c == &#34;\r&#34; and self.peek() == &#34;\n&#34;:
                self.skip()
            break</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.skipuntil"><code class="name flex">
<span>def <span class="ident">skipuntil</span></span>(<span>self, testfn)</span>
</code></dt>
<dd>
<div class="desc"><p>Advances the current position until a given predicate test
function succeeds, or the end of the document is reached.</p>
<p>Returns the actual number of characters skipped.</p>
<p>The provided test function should take a single unicode
character and return a boolean value, such as:</p>
<pre><code>lambda c : c == '.'   # Skip to next period
</code></pre>
<p>See also methods: skipwhile() and popuntil()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skipuntil(self, testfn):
    &#34;&#34;&#34;Advances the current position until a given predicate test
    function succeeds, or the end of the document is reached.

    Returns the actual number of characters skipped.

    The provided test function should take a single unicode
    character and return a boolean value, such as:

        lambda c : c == &#39;.&#39;   # Skip to next period

    See also methods: skipwhile() and popuntil()

    &#34;&#34;&#34;
    i = self.cpos
    while True:
        c = self.peek()
        if not c or testfn(c):
            break
        else:
            self.__pos.advance(c)
    return self.cpos - i</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.skipwhile"><code class="name flex">
<span>def <span class="ident">skipwhile</span></span>(<span>self, testfn)</span>
</code></dt>
<dd>
<div class="desc"><p>Advances the current position until a given predicate test
function fails, or the end of the document is reached.</p>
<p>Returns the actual number of characters skipped.</p>
<p>The provided test function should take a single unicode
character and return a boolean value, such as:</p>
<pre><code>lambda c : c.isdigit()   # Skip all digits
</code></pre>
<p>See also methods: skipuntil() and popwhile()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skipwhile(self, testfn):
    &#34;&#34;&#34;Advances the current position until a given predicate test
    function fails, or the end of the document is reached.

    Returns the actual number of characters skipped.

    The provided test function should take a single unicode
    character and return a boolean value, such as:

        lambda c : c.isdigit()   # Skip all digits

    See also methods: skipuntil() and popwhile()

    &#34;&#34;&#34;
    return self.skipuntil(lambda c: not testfn(c))</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.skipws"><code class="name flex">
<span>def <span class="ident">skipws</span></span>(<span>self, allow_unicode_whitespace=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Advances the current position past all whitespace, or until
the end of the document is reached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skipws(self, allow_unicode_whitespace=True):
    &#34;&#34;&#34;Advances the current position past all whitespace, or until
    the end of the document is reached.

    &#34;&#34;&#34;
    if allow_unicode_whitespace:
        n = self.skipwhile(helpers.char_is_unicode_ws)
    else:
        n = self.skipwhile(helpers.char_is_json_ws)
    self.num_ws_skipped += n
    return n</code></pre>
</details>
</dd>
<dt id="demjson3.buffered_stream.startswith"><code class="name flex">
<span>def <span class="ident">startswith</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the text at the current position starts with
the given string.</p>
<p>See also method: pop_if_startswith()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startswith(self, s):
    &#34;&#34;&#34;Determines if the text at the current position starts with
    the given string.

    See also method: pop_if_startswith()

    &#34;&#34;&#34;
    s2 = self.peekstr(len(s))
    return s == s2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.decode_state"><code class="flex name class">
<span>class <span class="ident">decode_state</span></span>
<span>(</span><span>options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An internal transient object used during JSON decoding to
record the current parsing state and error messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class decode_state(object):
    &#34;&#34;&#34;An internal transient object used during JSON decoding to
    record the current parsing state and error messages.

    &#34;&#34;&#34;

    def __init__(self, options=None):
        self.reset()
        self.options = options

    def reset(self):
        &#34;&#34;&#34;Clears all errors, statistics, and input text.&#34;&#34;&#34;
        self.buf = None
        self.errors = []
        self.obj = None
        self.cur_depth = 0  # how deep in nested structures are we?
        self.stats = decode_statistics()
        self._have_warned_nonbmp = False
        self._have_warned_long_string = False
        self._have_warned_max_depth = False

    @property
    def should_stop(self):
        if self.has_fatal:
            return True
        return False

    @property
    def has_errors(self):
        &#34;&#34;&#34;Have any errors been seen already?&#34;&#34;&#34;
        return (
            len([err for err in self.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)]) &gt; 0
        )

    @property
    def has_fatal(self):
        &#34;&#34;&#34;Have any errors been seen already?&#34;&#34;&#34;
        return len([err for err in self.errors if err.severity in (&#34;fatal&#34;,)]) &gt; 0

    def set_input(self, txt, encoding=None):
        &#34;&#34;&#34;Initialize the state by setting the input document text.&#34;&#34;&#34;
        import sys

        self.reset()
        try:
            self.buf = buffered_stream(txt, encoding=encoding)
        except JSONError as err:
            err.position = 0  # set position to start of file
            err.severity = &#34;fatal&#34;
            self.push_exception(err)
        except Exception as err:
            # Re-raise as JSONDecodeError
            e2 = sys.exc_info()
            newerr = JSONDecodeError(
                &#34;Error while reading input&#34;, position=0, severity=&#34;fatal&#34;
            )
            self.push_exception(err)
            self.buf = None
        else:
            if self.buf.bom:
                self.push_cond(
                    self.options.bom,
                    &#34;JSON document was prefixed by a BOM (Byte Order Mark)&#34;,
                    self.buf.bom,
                )
        if not self.buf:
            self.push_fatal(&#34;Aborting, can not read JSON document.&#34;, position=0)

    def push_exception(self, exc):
        &#34;&#34;&#34;Add an already-built exception to the error list.&#34;&#34;&#34;
        self.errors.append(exc)

    def push_fatal(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create a fatal error.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;fatal&#34;
        self.__push_err(message, *args, **kwargs)

    def push_error(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create an error.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;error&#34;
        self.__push_err(message, *args, **kwargs)

    def push_warning(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create a warning.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;warning&#34;
        self.__push_err(message, *args, **kwargs)

    def push_info(self, message, *args, **kwargs):
        &#34;&#34;&#34;Create a informational message.&#34;&#34;&#34;
        kwargs[&#34;severity&#34;] = &#34;info&#34;
        self.__push_err(message, *args, **kwargs)

    def push_cond(self, behavior_value, message, *args, **kwargs):
        &#34;&#34;&#34;Creates an conditional error or warning message.

        The behavior value (from json_options) controls whether
        a message will be pushed and whether it is an error
        or warning message.

        &#34;&#34;&#34;
        if behavior_value == ALLOW:
            return
        elif behavior_value == WARN:
            kwargs[&#34;severity&#34;] = &#34;warning&#34;
        else:
            kwargs[&#34;severity&#34;] = &#34;error&#34;
        self.__push_err(message, *args, **kwargs)

    def __push_err(self, message, *args, **kwargs):
        &#34;&#34;&#34;Stores an error in the error list.&#34;&#34;&#34;
        position = None
        outer_position = None
        severity = &#34;error&#34;
        context_description = None
        for kw, val in list(kwargs.items()):
            if kw == &#34;position&#34;:
                position = val
            elif kw == &#34;outer_position&#34;:
                outer_position = val
            elif kw == &#34;severity&#34;:
                severity = val
            elif kw == &#34;context_description&#34; or kw == &#34;context&#34;:
                context_description = val
            else:
                raise TypeError(&#34;Unknown keyword argument&#34;, kw)
        if position is None and self.buf:
            position = self.buf.position  # Current position
        err = JSONDecodeError(
            message,
            position=position,
            outer_position=outer_position,
            context_description=context_description,
            severity=severity,
            *args
        )
        self.push_exception(err)

    def update_depth_stats(self, **kwargs):
        st = self.stats
        st.max_depth = max(st.max_depth, self.cur_depth)
        if (
            not self._have_warned_max_depth
            and self.cur_depth &gt; self.options.warn_max_depth
        ):
            self._have_warned_max_depth = True
            self.push_cond(
                self.options.non_portable,
                &#34;Arrays or objects nested deeper than %d levels may not be portable&#34;
                % self.options.warn_max_depth,
            )

    def update_string_stats(self, s, **kwargs):
        st = self.stats
        st.num_strings += 1
        st.max_string_length = max(st.max_string_length, len(s))
        st.total_string_length += len(s)
        if (
            self.options.warn_string_length
            and len(s) &gt; self.options.warn_string_length
            and not self._have_warned_long_string
        ):
            self._have_warned_long_string = True
            self.push_cond(
                self.options.non_portable,
                &#34;Strings longer than %d may not be portable&#34;
                % self.options.warn_string_length,
                **kwargs
            )
        if len(s) &gt; 0:
            mincp = ord(min(s))
            maxcp = ord(max(s))
            if st.min_codepoint is None:
                st.min_codepoint = mincp
                st.max_codepoint = maxcp
            else:
                st.min_codepoint = min(st.min_codepoint, mincp)
                st.max_codepoint = max(st.max_codepoint, maxcp)
            if maxcp &gt; 0xFFFF and not self._have_warned_nonbmp:
                self._have_warned_nonbmp = True
                self.push_cond(
                    self.options.non_portable,
                    &#34;Strings containing non-BMP characters (U+%04X) may not be portable&#34;
                    % maxcp,
                    **kwargs
                )

    def update_negzero_int_stats(self, **kwargs):
        st = self.stats
        st.num_negative_zero_ints += 1
        if st.num_negative_zero_ints == 1:  # Only warn once
            self.push_cond(
                self.options.non_portable,
                &#34;Negative zero (-0) integers are usually not portable&#34;,
                **kwargs
            )

    def update_negzero_float_stats(self, **kwargs):
        st = self.stats
        st.num_negative_zero_floats += 1
        if st.num_negative_zero_floats == 1:  # Only warn once
            self.push_cond(
                self.options.non_portable,
                &#34;Negative zero (-0.0) numbers may not be portable&#34;,
                **kwargs
            )

    def update_float_stats(self, float_value, **kwargs):
        st = self.stats
        if &#34;sign&#34; in kwargs:
            del kwargs[&#34;sign&#34;]

        if helpers.is_negzero(float_value):
            self.update_negzero_float_stats(**kwargs)

        if helpers.is_infinite(float_value):
            st.num_infinities += 1

        if isinstance(float_value, decimal.Decimal):
            st.num_floats_decimal += 1
            if st.num_floats_decimal == 1:  # Only warn once
                self.push_cond(
                    self.options.non_portable,
                    &#39;Floats larger or more precise than an IEEE &#34;double&#34; may not be portable&#39;,
                    **kwargs
                )
        elif isinstance(float_value, float):
            st.num_floats += 1

    def update_integer_stats(self, int_value, **kwargs):
        sign = kwargs.get(&#34;sign&#34;, 1)
        if &#34;sign&#34; in kwargs:
            del kwargs[&#34;sign&#34;]

        if int_value == 0 and sign &lt; 0:
            self.update_negzero_int_stats(**kwargs)

        if sign &lt; 0:
            int_value = -int_value

        st = self.stats
        st.num_ints += 1
        if st.int8_min &lt;= int_value &lt;= st.int8_max:
            st.num_ints_8bit += 1
        elif st.int16_min &lt;= int_value &lt;= st.int16_max:
            st.num_ints_16bit += 1
        elif st.int32_min &lt;= int_value &lt;= st.int32_max:
            st.num_ints_32bit += 1
        elif st.int64_min &lt;= int_value &lt;= st.int64_max:
            st.num_ints_64bit += 1
        else:
            st.num_ints_long += 1

        if int_value &lt; st.double_int_min or st.double_int_max &lt; int_value:
            st.num_ints_53bit += 1
            if st.num_ints_53bit == 1:  # Only warn once
                self.push_cond(
                    self.options.non_portable,
                    &#34;Integers larger than 53-bits are not portable&#34;,
                    **kwargs
                )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.decode_state.has_errors"><code class="name">var <span class="ident">has_errors</span></code></dt>
<dd>
<div class="desc"><p>Have any errors been seen already?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_errors(self):
    &#34;&#34;&#34;Have any errors been seen already?&#34;&#34;&#34;
    return (
        len([err for err in self.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)]) &gt; 0
    )</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.has_fatal"><code class="name">var <span class="ident">has_fatal</span></code></dt>
<dd>
<div class="desc"><p>Have any errors been seen already?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_fatal(self):
    &#34;&#34;&#34;Have any errors been seen already?&#34;&#34;&#34;
    return len([err for err in self.errors if err.severity in (&#34;fatal&#34;,)]) &gt; 0</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.should_stop"><code class="name">var <span class="ident">should_stop</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def should_stop(self):
    if self.has_fatal:
        return True
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.decode_state.push_cond"><code class="name flex">
<span>def <span class="ident">push_cond</span></span>(<span>self, behavior_value, message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an conditional error or warning message.</p>
<p>The behavior value (from json_options) controls whether
a message will be pushed and whether it is an error
or warning message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_cond(self, behavior_value, message, *args, **kwargs):
    &#34;&#34;&#34;Creates an conditional error or warning message.

    The behavior value (from json_options) controls whether
    a message will be pushed and whether it is an error
    or warning message.

    &#34;&#34;&#34;
    if behavior_value == ALLOW:
        return
    elif behavior_value == WARN:
        kwargs[&#34;severity&#34;] = &#34;warning&#34;
    else:
        kwargs[&#34;severity&#34;] = &#34;error&#34;
    self.__push_err(message, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.push_error"><code class="name flex">
<span>def <span class="ident">push_error</span></span>(<span>self, message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_error(self, message, *args, **kwargs):
    &#34;&#34;&#34;Create an error.&#34;&#34;&#34;
    kwargs[&#34;severity&#34;] = &#34;error&#34;
    self.__push_err(message, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.push_exception"><code class="name flex">
<span>def <span class="ident">push_exception</span></span>(<span>self, exc)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an already-built exception to the error list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_exception(self, exc):
    &#34;&#34;&#34;Add an already-built exception to the error list.&#34;&#34;&#34;
    self.errors.append(exc)</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.push_fatal"><code class="name flex">
<span>def <span class="ident">push_fatal</span></span>(<span>self, message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a fatal error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_fatal(self, message, *args, **kwargs):
    &#34;&#34;&#34;Create a fatal error.&#34;&#34;&#34;
    kwargs[&#34;severity&#34;] = &#34;fatal&#34;
    self.__push_err(message, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.push_info"><code class="name flex">
<span>def <span class="ident">push_info</span></span>(<span>self, message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a informational message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_info(self, message, *args, **kwargs):
    &#34;&#34;&#34;Create a informational message.&#34;&#34;&#34;
    kwargs[&#34;severity&#34;] = &#34;info&#34;
    self.__push_err(message, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.push_warning"><code class="name flex">
<span>def <span class="ident">push_warning</span></span>(<span>self, message, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a warning.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_warning(self, message, *args, **kwargs):
    &#34;&#34;&#34;Create a warning.&#34;&#34;&#34;
    kwargs[&#34;severity&#34;] = &#34;warning&#34;
    self.__push_err(message, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears all errors, statistics, and input text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Clears all errors, statistics, and input text.&#34;&#34;&#34;
    self.buf = None
    self.errors = []
    self.obj = None
    self.cur_depth = 0  # how deep in nested structures are we?
    self.stats = decode_statistics()
    self._have_warned_nonbmp = False
    self._have_warned_long_string = False
    self._have_warned_max_depth = False</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.set_input"><code class="name flex">
<span>def <span class="ident">set_input</span></span>(<span>self, txt, encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the state by setting the input document text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_input(self, txt, encoding=None):
    &#34;&#34;&#34;Initialize the state by setting the input document text.&#34;&#34;&#34;
    import sys

    self.reset()
    try:
        self.buf = buffered_stream(txt, encoding=encoding)
    except JSONError as err:
        err.position = 0  # set position to start of file
        err.severity = &#34;fatal&#34;
        self.push_exception(err)
    except Exception as err:
        # Re-raise as JSONDecodeError
        e2 = sys.exc_info()
        newerr = JSONDecodeError(
            &#34;Error while reading input&#34;, position=0, severity=&#34;fatal&#34;
        )
        self.push_exception(err)
        self.buf = None
    else:
        if self.buf.bom:
            self.push_cond(
                self.options.bom,
                &#34;JSON document was prefixed by a BOM (Byte Order Mark)&#34;,
                self.buf.bom,
            )
    if not self.buf:
        self.push_fatal(&#34;Aborting, can not read JSON document.&#34;, position=0)</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.update_depth_stats"><code class="name flex">
<span>def <span class="ident">update_depth_stats</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_depth_stats(self, **kwargs):
    st = self.stats
    st.max_depth = max(st.max_depth, self.cur_depth)
    if (
        not self._have_warned_max_depth
        and self.cur_depth &gt; self.options.warn_max_depth
    ):
        self._have_warned_max_depth = True
        self.push_cond(
            self.options.non_portable,
            &#34;Arrays or objects nested deeper than %d levels may not be portable&#34;
            % self.options.warn_max_depth,
        )</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.update_float_stats"><code class="name flex">
<span>def <span class="ident">update_float_stats</span></span>(<span>self, float_value, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_float_stats(self, float_value, **kwargs):
    st = self.stats
    if &#34;sign&#34; in kwargs:
        del kwargs[&#34;sign&#34;]

    if helpers.is_negzero(float_value):
        self.update_negzero_float_stats(**kwargs)

    if helpers.is_infinite(float_value):
        st.num_infinities += 1

    if isinstance(float_value, decimal.Decimal):
        st.num_floats_decimal += 1
        if st.num_floats_decimal == 1:  # Only warn once
            self.push_cond(
                self.options.non_portable,
                &#39;Floats larger or more precise than an IEEE &#34;double&#34; may not be portable&#39;,
                **kwargs
            )
    elif isinstance(float_value, float):
        st.num_floats += 1</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.update_integer_stats"><code class="name flex">
<span>def <span class="ident">update_integer_stats</span></span>(<span>self, int_value, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_integer_stats(self, int_value, **kwargs):
    sign = kwargs.get(&#34;sign&#34;, 1)
    if &#34;sign&#34; in kwargs:
        del kwargs[&#34;sign&#34;]

    if int_value == 0 and sign &lt; 0:
        self.update_negzero_int_stats(**kwargs)

    if sign &lt; 0:
        int_value = -int_value

    st = self.stats
    st.num_ints += 1
    if st.int8_min &lt;= int_value &lt;= st.int8_max:
        st.num_ints_8bit += 1
    elif st.int16_min &lt;= int_value &lt;= st.int16_max:
        st.num_ints_16bit += 1
    elif st.int32_min &lt;= int_value &lt;= st.int32_max:
        st.num_ints_32bit += 1
    elif st.int64_min &lt;= int_value &lt;= st.int64_max:
        st.num_ints_64bit += 1
    else:
        st.num_ints_long += 1

    if int_value &lt; st.double_int_min or st.double_int_max &lt; int_value:
        st.num_ints_53bit += 1
        if st.num_ints_53bit == 1:  # Only warn once
            self.push_cond(
                self.options.non_portable,
                &#34;Integers larger than 53-bits are not portable&#34;,
                **kwargs
            )</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.update_negzero_float_stats"><code class="name flex">
<span>def <span class="ident">update_negzero_float_stats</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_negzero_float_stats(self, **kwargs):
    st = self.stats
    st.num_negative_zero_floats += 1
    if st.num_negative_zero_floats == 1:  # Only warn once
        self.push_cond(
            self.options.non_portable,
            &#34;Negative zero (-0.0) numbers may not be portable&#34;,
            **kwargs
        )</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.update_negzero_int_stats"><code class="name flex">
<span>def <span class="ident">update_negzero_int_stats</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_negzero_int_stats(self, **kwargs):
    st = self.stats
    st.num_negative_zero_ints += 1
    if st.num_negative_zero_ints == 1:  # Only warn once
        self.push_cond(
            self.options.non_portable,
            &#34;Negative zero (-0) integers are usually not portable&#34;,
            **kwargs
        )</code></pre>
</details>
</dd>
<dt id="demjson3.decode_state.update_string_stats"><code class="name flex">
<span>def <span class="ident">update_string_stats</span></span>(<span>self, s, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_string_stats(self, s, **kwargs):
    st = self.stats
    st.num_strings += 1
    st.max_string_length = max(st.max_string_length, len(s))
    st.total_string_length += len(s)
    if (
        self.options.warn_string_length
        and len(s) &gt; self.options.warn_string_length
        and not self._have_warned_long_string
    ):
        self._have_warned_long_string = True
        self.push_cond(
            self.options.non_portable,
            &#34;Strings longer than %d may not be portable&#34;
            % self.options.warn_string_length,
            **kwargs
        )
    if len(s) &gt; 0:
        mincp = ord(min(s))
        maxcp = ord(max(s))
        if st.min_codepoint is None:
            st.min_codepoint = mincp
            st.max_codepoint = maxcp
        else:
            st.min_codepoint = min(st.min_codepoint, mincp)
            st.max_codepoint = max(st.max_codepoint, maxcp)
        if maxcp &gt; 0xFFFF and not self._have_warned_nonbmp:
            self._have_warned_nonbmp = True
            self.push_cond(
                self.options.non_portable,
                &#34;Strings containing non-BMP characters (U+%04X) may not be portable&#34;
                % maxcp,
                **kwargs
            )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.decode_statistics"><code class="flex name class">
<span>class <span class="ident">decode_statistics</span></span>
</code></dt>
<dd>
<div class="desc"><p>An object that records various statistics about a decoded JSON document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class decode_statistics(object):
    &#34;&#34;&#34;An object that records various statistics about a decoded JSON document.&#34;&#34;&#34;

    int8_max = 0x7F
    int8_min = -0x7F - 1
    int16_max = 0x7FFF
    int16_min = -0x7FFF - 1
    int32_max = 0x7FFFFFFF
    int32_min = -0x7FFFFFFF - 1
    int64_max = 0x7FFFFFFFFFFFFFFF
    int64_min = -0x7FFFFFFFFFFFFFFF - 1

    double_int_max = 2 ** 53 - 1
    double_int_min = -(2 ** 53 - 1)

    def __init__(self):
        # Nesting
        self.max_depth = 0
        self.max_items_in_array = 0
        self.max_items_in_object = 0
        # Integer stats
        self.num_ints = 0
        self.num_ints_8bit = 0
        self.num_ints_16bit = 0
        self.num_ints_32bit = 0
        self.num_ints_53bit = 0  # ints which will overflow IEEE doubles
        self.num_ints_64bit = 0
        self.num_ints_long = 0
        self.num_negative_zero_ints = 0
        self.total_chars = 0
        # Floating-point stats
        self.num_negative_zero_floats = 0
        self.num_floats = 0
        self.num_floats_decimal = 0  # overflowed &#39;float&#39;
        # String stats
        self.num_strings = 0
        self.max_string_length = 0
        self.total_string_length = 0
        self.min_codepoint = None
        self.max_codepoint = None
        # Other data type stats
        self.num_arrays = 0
        self.num_objects = 0
        self.num_bools = 0
        self.num_nulls = 0
        self.num_undefineds = 0
        self.num_nans = 0
        self.num_infinities = 0
        self.num_comments = 0
        self.num_identifiers = 0  # JavaScript identifiers
        self.num_excess_whitespace = 0

    @property
    def num_infinites(self):
        &#34;&#34;&#34;Misspelled &#39;num_infinities&#39; for backwards compatibility&#34;&#34;&#34;
        return self.num_infinities

    def pretty_description(self, prefix=&#34;&#34;):
        import unicodedata

        lines = [
            &#34;Number of integers:&#34;,
            &#34;    8-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_8bit, self.int8_min, self.int8_max),
            &#34;   16-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_16bit, self.int16_min, self.int16_max),
            &#34;   32-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_32bit, self.int32_min, self.int32_max),
            &#34; &gt; 53-bit:     %5d   (%d to %d - overflows JavaScript)&#34;
            % (self.num_ints_53bit, self.double_int_min, self.double_int_max),
            &#34;   64-bit:     %5d   (%d to %d)&#34;
            % (self.num_ints_64bit, self.int64_min, self.int64_max),
            &#39; &gt; 64 bit:     %5d   (not portable, may require a &#34;Big Num&#34; package)&#39;
            % self.num_ints_long,
            &#34;   total ints: %5d&#34; % self.num_ints,
            &#34;   Num -0:     %5d   (negative-zero integers are not portable)&#34;
            % self.num_negative_zero_ints,
            &#34;Number of floats:&#34;,
            &#34;   doubles:    %5d&#34; % self.num_floats,
            &#34; &gt; doubles:    %5d   (will overflow IEEE doubles)&#34;
            % self.num_floats_decimal,
            &#34;   total flts: %5d&#34; % (self.num_floats + self.num_floats_decimal),
            &#34;   Num -0.0:   %5d   (negative-zero floats are usually portable)&#34;
            % self.num_negative_zero_floats,
            &#34;Number of:&#34;,
            &#34;   nulls:      %5d&#34; % self.num_nulls,
            &#34;   booleans:   %5d&#34; % self.num_bools,
            &#34;   arrays:     %5d&#34; % self.num_arrays,
            &#34;   objects:    %5d&#34; % self.num_objects,
            &#34;Strings:&#34;,
            &#34;   number:         %5d strings&#34; % self.num_strings,
            &#34;   max length:     %5d characters&#34; % self.max_string_length,
            &#34;   total chars:    %5d across all strings&#34; % self.total_string_length,
        ]

        if self.min_codepoint is not None:
            cp = &#34;U+%04X&#34; % self.min_codepoint
            try:
                charname = unicodedata.name(chr(self.min_codepoint))
            except ValueError:
                charname = &#34;? UNKNOWN CHARACTER&#34;
            lines.append(&#34;   min codepoint: %6s  (%s)&#34; % (cp, charname))
        else:
            lines.append(&#34;   min codepoint: %6s&#34; % (&#34;n/a&#34;,))

        if self.max_codepoint is not None:
            cp = &#34;U+%04X&#34; % self.max_codepoint
            try:
                charname = unicodedata.name(chr(self.max_codepoint))
            except ValueError:
                charname = &#34;? UNKNOWN CHARACTER&#34;
            lines.append(&#34;   max codepoint: %6s  (%s)&#34; % (cp, charname))
        else:
            lines.append(&#34;   max codepoint: %6s&#34; % (&#34;n/a&#34;,))

        lines.extend(
            [
                &#34;Other JavaScript items:&#34;,
                &#34;   NaN:         %5d&#34; % self.num_nans,
                &#34;   Infinite:    %5d&#34; % self.num_infinities,
                &#34;   undefined:   %5d&#34; % self.num_undefineds,
                &#34;   Comments:    %5d&#34; % self.num_comments,
                &#34;   Identifiers: %5d&#34; % self.num_identifiers,
                &#34;Max items in any array: %5d&#34; % self.max_items_in_array,
                &#34;Max keys in any object: %5d&#34; % self.max_items_in_object,
                &#34;Max nesting depth:      %5d&#34; % self.max_depth,
            ]
        )
        if self.total_chars == 0:
            lines.append(&#34;Unnecessary whitespace:     0 of 0 characters&#34;)
        else:
            lines.append(
                &#34;Unnecessary whitespace: %5d of %d characters (%.2f%%)&#34;
                % (
                    self.num_excess_whitespace,
                    self.total_chars,
                    self.num_excess_whitespace * 100.0 / self.total_chars,
                )
            )
        if prefix:
            return &#34;\n&#34;.join([prefix + s for s in lines]) + &#34;\n&#34;
        else:
            return &#34;\n&#34;.join(lines) + &#34;\n&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="demjson3.decode_statistics.double_int_max"><code class="name">var <span class="ident">double_int_max</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.double_int_min"><code class="name">var <span class="ident">double_int_min</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int16_max"><code class="name">var <span class="ident">int16_max</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int16_min"><code class="name">var <span class="ident">int16_min</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int32_max"><code class="name">var <span class="ident">int32_max</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int32_min"><code class="name">var <span class="ident">int32_min</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int64_max"><code class="name">var <span class="ident">int64_max</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int64_min"><code class="name">var <span class="ident">int64_min</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int8_max"><code class="name">var <span class="ident">int8_max</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.decode_statistics.int8_min"><code class="name">var <span class="ident">int8_min</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.decode_statistics.num_infinites"><code class="name">var <span class="ident">num_infinites</span></code></dt>
<dd>
<div class="desc"><p>Misspelled 'num_infinities' for backwards compatibility</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_infinites(self):
    &#34;&#34;&#34;Misspelled &#39;num_infinities&#39; for backwards compatibility&#34;&#34;&#34;
    return self.num_infinities</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.decode_statistics.pretty_description"><code class="name flex">
<span>def <span class="ident">pretty_description</span></span>(<span>self, prefix='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_description(self, prefix=&#34;&#34;):
    import unicodedata

    lines = [
        &#34;Number of integers:&#34;,
        &#34;    8-bit:     %5d   (%d to %d)&#34;
        % (self.num_ints_8bit, self.int8_min, self.int8_max),
        &#34;   16-bit:     %5d   (%d to %d)&#34;
        % (self.num_ints_16bit, self.int16_min, self.int16_max),
        &#34;   32-bit:     %5d   (%d to %d)&#34;
        % (self.num_ints_32bit, self.int32_min, self.int32_max),
        &#34; &gt; 53-bit:     %5d   (%d to %d - overflows JavaScript)&#34;
        % (self.num_ints_53bit, self.double_int_min, self.double_int_max),
        &#34;   64-bit:     %5d   (%d to %d)&#34;
        % (self.num_ints_64bit, self.int64_min, self.int64_max),
        &#39; &gt; 64 bit:     %5d   (not portable, may require a &#34;Big Num&#34; package)&#39;
        % self.num_ints_long,
        &#34;   total ints: %5d&#34; % self.num_ints,
        &#34;   Num -0:     %5d   (negative-zero integers are not portable)&#34;
        % self.num_negative_zero_ints,
        &#34;Number of floats:&#34;,
        &#34;   doubles:    %5d&#34; % self.num_floats,
        &#34; &gt; doubles:    %5d   (will overflow IEEE doubles)&#34;
        % self.num_floats_decimal,
        &#34;   total flts: %5d&#34; % (self.num_floats + self.num_floats_decimal),
        &#34;   Num -0.0:   %5d   (negative-zero floats are usually portable)&#34;
        % self.num_negative_zero_floats,
        &#34;Number of:&#34;,
        &#34;   nulls:      %5d&#34; % self.num_nulls,
        &#34;   booleans:   %5d&#34; % self.num_bools,
        &#34;   arrays:     %5d&#34; % self.num_arrays,
        &#34;   objects:    %5d&#34; % self.num_objects,
        &#34;Strings:&#34;,
        &#34;   number:         %5d strings&#34; % self.num_strings,
        &#34;   max length:     %5d characters&#34; % self.max_string_length,
        &#34;   total chars:    %5d across all strings&#34; % self.total_string_length,
    ]

    if self.min_codepoint is not None:
        cp = &#34;U+%04X&#34; % self.min_codepoint
        try:
            charname = unicodedata.name(chr(self.min_codepoint))
        except ValueError:
            charname = &#34;? UNKNOWN CHARACTER&#34;
        lines.append(&#34;   min codepoint: %6s  (%s)&#34; % (cp, charname))
    else:
        lines.append(&#34;   min codepoint: %6s&#34; % (&#34;n/a&#34;,))

    if self.max_codepoint is not None:
        cp = &#34;U+%04X&#34; % self.max_codepoint
        try:
            charname = unicodedata.name(chr(self.max_codepoint))
        except ValueError:
            charname = &#34;? UNKNOWN CHARACTER&#34;
        lines.append(&#34;   max codepoint: %6s  (%s)&#34; % (cp, charname))
    else:
        lines.append(&#34;   max codepoint: %6s&#34; % (&#34;n/a&#34;,))

    lines.extend(
        [
            &#34;Other JavaScript items:&#34;,
            &#34;   NaN:         %5d&#34; % self.num_nans,
            &#34;   Infinite:    %5d&#34; % self.num_infinities,
            &#34;   undefined:   %5d&#34; % self.num_undefineds,
            &#34;   Comments:    %5d&#34; % self.num_comments,
            &#34;   Identifiers: %5d&#34; % self.num_identifiers,
            &#34;Max items in any array: %5d&#34; % self.max_items_in_array,
            &#34;Max keys in any object: %5d&#34; % self.max_items_in_object,
            &#34;Max nesting depth:      %5d&#34; % self.max_depth,
        ]
    )
    if self.total_chars == 0:
        lines.append(&#34;Unnecessary whitespace:     0 of 0 characters&#34;)
    else:
        lines.append(
            &#34;Unnecessary whitespace: %5d of %d characters (%.2f%%)&#34;
            % (
                self.num_excess_whitespace,
                self.total_chars,
                self.num_excess_whitespace * 100.0 / self.total_chars,
            )
        )
    if prefix:
        return &#34;\n&#34;.join([prefix + s for s in lines]) + &#34;\n&#34;
    else:
        return &#34;\n&#34;.join(lines) + &#34;\n&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.encode_state"><code class="flex name class">
<span>class <span class="ident">encode_state</span></span>
<span>(</span><span>jsopts=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>An internal transient object used during JSON encoding to
record the current construction state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class encode_state(object):
    &#34;&#34;&#34;An internal transient object used during JSON encoding to
    record the current construction state.

    &#34;&#34;&#34;

    def __init__(self, jsopts=None, parent=None):
        import sys

        self.chunks = []
        if not parent:
            self.parent = None
            self.nest_level = 0
            self.options = jsopts
            self.escape_unicode_test = False  # or a function f(unichar)=&gt;True/False
        else:
            self.parent = parent
            self.nest_level = parent.nest_level + 1
            self.escape_unicode_test = parent.escape_unicode_test
            self.options = parent.options

    def make_substate(self):
        return encode_state(parent=self)

    def join_substate(self, other_state):
        self.chunks.extend(other_state.chunks)
        other_state.chunks = []

    def append(self, s):
        &#34;&#34;&#34;Adds a string to the end of the current JSON document&#34;&#34;&#34;
        self.chunks.append(s)

    def combine(self):
        &#34;&#34;&#34;Returns the accumulated string and resets the state to empty&#34;&#34;&#34;
        s = &#34;&#34;.join(self.chunks)
        self.chunks = []
        return s

    def __eq__(self, other_state):
        return (
            self.nest_level == other_state.nest_level
            and self.chunks == other_state.chunks
        )

    def __lt__(self, other_state):
        if self.nest_level != other_state.nest_level:
            return self.nest_level &lt; other_state.nest_level
        return self.chunks &lt; other_state.chunks</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="demjson3.encode_state.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a string to the end of the current JSON document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, s):
    &#34;&#34;&#34;Adds a string to the end of the current JSON document&#34;&#34;&#34;
    self.chunks.append(s)</code></pre>
</details>
</dd>
<dt id="demjson3.encode_state.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the accumulated string and resets the state to empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine(self):
    &#34;&#34;&#34;Returns the accumulated string and resets the state to empty&#34;&#34;&#34;
    s = &#34;&#34;.join(self.chunks)
    self.chunks = []
    return s</code></pre>
</details>
</dd>
<dt id="demjson3.encode_state.join_substate"><code class="name flex">
<span>def <span class="ident">join_substate</span></span>(<span>self, other_state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_substate(self, other_state):
    self.chunks.extend(other_state.chunks)
    other_state.chunks = []</code></pre>
</details>
</dd>
<dt id="demjson3.encode_state.make_substate"><code class="name flex">
<span>def <span class="ident">make_substate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_substate(self):
    return encode_state(parent=self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.helpers"><code class="flex name class">
<span>class <span class="ident">helpers</span></span>
</code></dt>
<dd>
<div class="desc"><p>A set of utility functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class helpers(object):
    &#34;&#34;&#34;A set of utility functions.&#34;&#34;&#34;

    hexdigits = &#34;0123456789ABCDEFabcdef&#34;
    octaldigits = &#34;01234567&#34;
    unsafe_string_chars = _make_unsafe_string_chars()

    import sys

    maxunicode = sys.maxunicode

    always_use_custom_codecs = False  # If True use demjson&#39;s codecs
    # before system codecs. This
    # is mainly here for testing.

    javascript_reserved_words = frozenset(
        [
            # Keywords (plus &#34;let&#34;)  (ECMAScript 6 section 11.6.2.1)
            &#34;break&#34;,
            &#34;case&#34;,
            &#34;catch&#34;,
            &#34;class&#34;,
            &#34;const&#34;,
            &#34;continue&#34;,
            &#34;debugger&#34;,
            &#34;default&#34;,
            &#34;delete&#34;,
            &#34;do&#34;,
            &#34;else&#34;,
            &#34;export&#34;,
            &#34;extends&#34;,
            &#34;finally&#34;,
            &#34;for&#34;,
            &#34;function&#34;,
            &#34;if&#34;,
            &#34;import&#34;,
            &#34;in&#34;,
            &#34;instanceof&#34;,
            &#34;let&#34;,
            &#34;new&#34;,
            &#34;return&#34;,
            &#34;super&#34;,
            &#34;switch&#34;,
            &#34;this&#34;,
            &#34;throw&#34;,
            &#34;try&#34;,
            &#34;typeof&#34;,
            &#34;var&#34;,
            &#34;void&#34;,
            &#34;while&#34;,
            &#34;with&#34;,
            &#34;yield&#34;,
            # Future reserved words (ECMAScript 6 section 11.6.2.2)
            &#34;enum&#34;,
            &#34;implements&#34;,
            &#34;interface&#34;,
            &#34;package&#34;,
            &#34;private&#34;,
            &#34;protected&#34;,
            &#34;public&#34;,
            &#34;static&#34;,
            # null/boolean literals
            &#34;null&#34;,
            &#34;true&#34;,
            &#34;false&#34;,
        ]
    )

    @staticmethod
    def make_raw_bytes(byte_list):
        &#34;&#34;&#34;Constructs a byte array (bytes in Python 3, str in Python 2) from a list of byte values (0-255).&#34;&#34;&#34;
        return _make_raw_bytes(byte_list)

    @staticmethod
    def is_hex_digit(c):
        &#34;&#34;&#34;Determines if the given character is a valid hexadecimal digit (0-9, a-f, A-F).&#34;&#34;&#34;
        return c in helpers.hexdigits

    @staticmethod
    def is_octal_digit(c):
        &#34;&#34;&#34;Determines if the given character is a valid octal digit (0-7).&#34;&#34;&#34;
        return c in helpers.octaldigits

    @staticmethod
    def is_binary_digit(c):
        &#34;&#34;&#34;Determines if the given character is a valid binary digit (0 or 1).&#34;&#34;&#34;
        return c == &#34;0&#34; or c == &#34;1&#34;

    @staticmethod
    def char_is_json_ws(c):
        &#34;&#34;&#34;Determines if the given character is a JSON white-space character&#34;&#34;&#34;
        return c in &#34; \t\n\r&#34;

    @staticmethod
    def safe_unichr(codepoint):
        &#34;&#34;&#34;Just like Python&#39;s unichr() but works in narrow-Unicode Pythons.&#34;&#34;&#34;
        if codepoint &gt;= 0x10000 and codepoint &gt; helpers.maxunicode:
            # Narrow-Unicode python, construct a UTF-16 surrogate pair.
            w1, w2 = helpers.make_surrogate_pair(codepoint)
            if w2 is None:
                c = chr(w1)
            else:
                c = chr(w1) + chr(w2)
        else:
            c = chr(codepoint)
        return c

    @staticmethod
    def char_is_unicode_ws(c):
        &#34;&#34;&#34;Determines if the given character is a Unicode space character&#34;&#34;&#34;
        if not isinstance(c, str):
            c = str(c)
        if c in &#34; \t\n\r\f\v&#34;:
            return True
        import unicodedata

        return unicodedata.category(c) == &#34;Zs&#34;

    @staticmethod
    def char_is_json_eol(c):
        &#34;&#34;&#34;Determines if the given character is a JSON line separator&#34;&#34;&#34;
        return c in &#34;\n\r&#34;

    @staticmethod
    def char_is_unicode_eol(c):
        &#34;&#34;&#34;Determines if the given character is a Unicode line or
        paragraph separator. These correspond to CR and LF as well as
        Unicode characters in the Zl or Zp categories.

        &#34;&#34;&#34;
        return c in &#34;\r\n\u2028\u2029&#34;

    @staticmethod
    def char_is_identifier_leader(c):
        &#34;&#34;&#34;Determines if the character may be the first character of a
        JavaScript identifier.
        &#34;&#34;&#34;
        return c.isalpha() or c in &#34;_$&#34;

    @staticmethod
    def char_is_identifier_tail(c):
        &#34;&#34;&#34;Determines if the character may be part of a JavaScript
        identifier.
        &#34;&#34;&#34;
        return c.isalnum() or c in &#34;_$\u200c\u200d&#34;

    @staticmethod
    def extend_and_flatten_list_with_sep(orig_seq, extension_seq, separator=&#34;&#34;):
        for i, part in enumerate(extension_seq):
            if i &gt; 0 and separator:
                orig_seq.append(separator)
            orig_seq.extend(part)

    @staticmethod
    def strip_format_control_chars(txt):
        &#34;&#34;&#34;Filters out all Unicode format control characters from the string.

        ECMAScript permits any Unicode &#34;format control characters&#34; to
        appear at any place in the source code.  They are to be
        ignored as if they are not there before any other lexical
        tokenization occurs.  Note that JSON does not allow them,
        except within string literals.

        * Ref. ECMAScript section 7.1.
        * http://en.wikipedia.org/wiki/Unicode_control_characters

        There are dozens of Format Control Characters, for example:
            U+00AD   SOFT HYPHEN
            U+200B   ZERO WIDTH SPACE
            U+2060   WORD JOINER

        &#34;&#34;&#34;
        import unicodedata

        txt2 = [c for c in txt if unicodedata.category(str(c)) != &#34;Cf&#34;]

        # 2to3 NOTE: The following is needed to work around a broken
        # Python3 conversion in which filter() will be transformed
        # into a list rather than a string.
        if not isinstance(txt2, str):
            txt2 = &#34;&#34;.join(txt2)
        return txt2

    @staticmethod
    def lookup_codec(encoding):
        &#34;&#34;&#34;Wrapper around codecs.lookup().

        Returns None if codec not found, rather than raising a LookupError.
        &#34;&#34;&#34;
        import codecs

        if isinstance(encoding, codecs.CodecInfo):
            return encoding
        encoding = encoding.lower()
        import codecs

        if helpers.always_use_custom_codecs:
            # Try custom utf32 first, then standard python codecs
            cdk = utf32.lookup(encoding)
            if not cdk:
                try:
                    cdk = codecs.lookup(encoding)
                except LookupError:
                    cdk = None
        else:
            # Try standard python codecs first, then custom utf32
            try:
                cdk = codecs.lookup(encoding)
            except LookupError:
                cdk = utf32.lookup(encoding)
        return cdk

    @staticmethod
    def auto_detect_encoding(s):
        &#34;&#34;&#34;Takes a string (or byte array) and tries to determine the Unicode encoding it is in.

        Returns the encoding name, as a string.

        &#34;&#34;&#34;
        if not s or len(s) == 0:
            return &#34;utf-8&#34;

        # Get the byte values of up to the first 4 bytes
        ords = []
        for i in range(0, min(len(s), 4)):
            x = s[i]
            if isinstance(x, str):
                x = ord(x)
            ords.append(x)

        # Look for BOM marker
        import sys, codecs

        bom2, bom3, bom4 = None, None, None
        if len(s) &gt;= 2:
            bom2 = s[:2]
        if len(s) &gt;= 3:
            bom3 = s[:3]
        if len(s) &gt;= 4:
            bom4 = s[:4]

        # Assign values of first four bytes to: a, b, c, d; and last byte to: z
        a, b, c, d, z = None, None, None, None, None
        if len(s) &gt;= 1:
            a = ords[0]
        if len(s) &gt;= 2:
            b = ords[1]
        if len(s) &gt;= 3:
            c = ords[2]
        if len(s) &gt;= 4:
            d = ords[3]

        z = s[-1]
        if isinstance(z, str):
            z = ord(z)

        if bom4 and (
            (hasattr(codecs, &#34;BOM_UTF32_LE&#34;) and bom4 == codecs.BOM_UTF32_LE)
            or (bom4 == utf32.BOM_UTF32_LE)
        ):
            encoding = &#34;utf-32le&#34;
            s = s[4:]
        elif bom4 and (
            (hasattr(codecs, &#34;BOM_UTF32_BE&#34;) and bom4 == codecs.BOM_UTF32_BE)
            or (bom4 == utf32.BOM_UTF32_BE)
        ):
            encoding = &#34;utf-32be&#34;
            s = s[4:]
        elif bom2 and bom2 == codecs.BOM_UTF16_LE:
            encoding = &#34;utf-16le&#34;
            s = s[2:]
        elif bom2 and bom2 == codecs.BOM_UTF16_BE:
            encoding = &#34;utf-16be&#34;
            s = s[2:]
        elif bom3 and bom3 == codecs.BOM_UTF8:
            encoding = &#34;utf-8&#34;
            s = s[3:]

        # No BOM, so autodetect encoding used by looking at first four
        # bytes according to RFC 4627 section 3.  The first and last bytes
        # in a JSON document will be ASCII.  The second byte will be ASCII
        # unless the first byte was a quotation mark.

        elif (
            len(s) &gt;= 4 and a == 0 and b == 0 and c == 0 and d != 0
        ):  # UTF-32BE  (0 0 0 x)
            encoding = &#34;utf-32be&#34;
        elif (
            len(s) &gt;= 4 and a != 0 and b == 0 and c == 0 and d == 0 and z == 0
        ):  # UTF-32LE  (x 0 0 0 [... 0])
            encoding = &#34;utf-32le&#34;
        elif len(s) &gt;= 2 and a == 0 and b != 0:  # UTF-16BE  (0 x)
            encoding = &#34;utf-16be&#34;
        elif len(s) &gt;= 2 and a != 0 and b == 0 and z == 0:  # UTF-16LE  (x 0 [... 0])
            encoding = &#34;utf-16le&#34;
        elif ord(&#34;\t&#34;) &lt;= a &lt;= 127:
            # First byte appears to be ASCII, so guess UTF-8.
            encoding = &#34;utf8&#34;
        else:
            raise ValueError(&#34;Can not determine the Unicode encoding for byte stream&#34;)

        return encoding

    @staticmethod
    def unicode_decode(txt, encoding=None):
        &#34;&#34;&#34;Takes a string (or byte array) and tries to convert it to a Unicode string.

        Returns a named tuple:  (string, codec, bom)

        The &#39;encoding&#39; argument, if supplied, should either the name of
        a character encoding, or an instance of codecs.CodecInfo.  If
        the encoding argument is None or &#34;auto&#34; then the encoding is
        automatically determined, if possible.

        Any BOM (Byte Order Mark) that is found at the beginning of the
        input will be stripped off and placed in the &#39;bom&#39; portion of
        the returned value.

        &#34;&#34;&#34;
        if isinstance(txt, str):
            res = _namedtuple(&#34;DecodedString&#34;, [&#34;string&#34;, &#34;codec&#34;, &#34;bom&#34;])(
                txt, None, None
            )
        else:
            if encoding is None or encoding == &#34;auto&#34;:
                encoding = helpers.auto_detect_encoding(txt)

            cdk = helpers.lookup_codec(encoding)
            if not cdk:
                raise LookupError(&#34;Can not find codec for encoding %r&#34; % encoding)

            try:
                # Determine if codec takes arguments; try a decode of nothing
                cdk.decode(helpers.make_raw_bytes([]), errors=&#34;strict&#34;)
            except TypeError:
                cdk_kw = {}  # This coded doesn&#39;t like the errors argument
            else:
                cdk_kw = {&#34;errors&#34;: &#34;strict&#34;}

            unitxt, numbytes = cdk.decode(txt, **cdk_kw)  # DO THE DECODE HERE!

            # Remove BOM if present
            if len(unitxt) &gt; 0 and unitxt[0] == &#34;\uFEFF&#34;:
                bom = cdk.encode(unitxt[0])[0]
                unitxt = unitxt[1:]
            elif len(unitxt) &gt; 0 and unitxt[0] == &#34;\uFFFE&#34;:  # Reversed BOM
                raise UnicodeDecodeError(
                    cdk.name, txt, 0, 0, &#34;Wrong byte order, found reversed BOM U+FFFE&#34;
                )
            else:
                bom = None

            res = _namedtuple(&#34;DecodedString&#34;, [&#34;string&#34;, &#34;codec&#34;, &#34;bom&#34;])(
                unitxt, cdk, bom
            )
        return res

    @staticmethod
    def surrogate_pair_as_unicode(c1, c2):
        &#34;&#34;&#34;Takes a pair of unicode surrogates and returns the equivalent unicode character.

        The input pair must be a surrogate pair, with c1 in the range
        U+D800 to U+DBFF and c2 in the range U+DC00 to U+DFFF.

        &#34;&#34;&#34;
        n1, n2 = ord(c1), ord(c2)
        if n1 &lt; 0xD800 or n1 &gt; 0xDBFF or n2 &lt; 0xDC00 or n2 &gt; 0xDFFF:
            raise JSONDecodeError(&#34;illegal Unicode surrogate pair&#34;, (c1, c2))
        a = n1 - 0xD800
        b = n2 - 0xDC00
        v = (a &lt;&lt; 10) | b
        v += 0x10000
        return helpers.safe_unichr(v)

    @staticmethod
    def unicode_as_surrogate_pair(c):
        &#34;&#34;&#34;Takes a single unicode character and returns a sequence of surrogate pairs.

        The output of this function is a tuple consisting of one or two unicode
        characters, such that if the input character is outside the BMP range
        then the output is a two-character surrogate pair representing that character.

        If the input character is inside the BMP then the output tuple will have
        just a single character...the same one.

        &#34;&#34;&#34;
        n = ord(c)
        w1, w2 = helpers.make_surrogate_pair(n)
        if w2 is None:
            return (chr(w1),)
        else:
            return (chr(w1), chr(w2))

    @staticmethod
    def make_surrogate_pair(codepoint):
        &#34;&#34;&#34;Given a Unicode codepoint (int) returns a 2-tuple of surrogate codepoints.&#34;&#34;&#34;
        if codepoint &lt; 0x10000:
            return (codepoint, None)  # in BMP, surrogate pair not required
        v = codepoint - 0x10000
        vh = (v &gt;&gt; 10) &amp; 0x3FF  # highest 10 bits
        vl = v &amp; 0x3FF  # lowest 10 bits
        w1 = 0xD800 | vh
        w2 = 0xDC00 | vl
        return (w1, w2)

    @staticmethod
    def isnumbertype(obj):
        &#34;&#34;&#34;Is the object of a Python number type (excluding complex)?&#34;&#34;&#34;
        return (
            isinstance(obj, (int, float))
            and not isinstance(obj, bool)
            or obj is nan
            or obj is inf
            or obj is neginf
            or (decimal and isinstance(obj, decimal.Decimal))
        )

    @staticmethod
    def is_negzero(n):
        &#34;&#34;&#34;Is the number value a negative zero?&#34;&#34;&#34;
        if isinstance(n, float):
            return n == 0.0 and repr(n).startswith(&#34;-&#34;)
        elif decimal and isinstance(n, decimal.Decimal):
            return n.is_zero() and n.is_signed()
        else:
            return False

    @staticmethod
    def is_nan(n):
        &#34;&#34;&#34;Is the number a NaN (not-a-number)?&#34;&#34;&#34;
        if isinstance(n, float):
            return n is nan or n.hex() == &#34;nan&#34; or n != n
        elif decimal and isinstance(n, decimal.Decimal):
            return n.is_nan()
        else:
            return False

    @staticmethod
    def is_infinite(n):
        &#34;&#34;&#34;Is the number infinite?&#34;&#34;&#34;
        if isinstance(n, float):
            return n is inf or n is neginf or n.hex() in (&#34;inf&#34;, &#34;-inf&#34;)
        elif decimal and isinstance(n, decimal.Decimal):
            return n.is_infinite()
        else:
            return False

    @staticmethod
    def isstringtype(obj):
        &#34;&#34;&#34;Is the object of a Python string type?&#34;&#34;&#34;
        if isinstance(obj, str):
            return True
        # Must also check for some other pseudo-string types
        import types, collections

        return isinstance(obj, (str,)) or isinstance(obj, collections.UserString)
        ## or isinstance(obj, UserString.MutableString)

    @staticmethod
    def decode_hex(hexstring):
        &#34;&#34;&#34;Decodes a hexadecimal string into it&#39;s integer value.&#34;&#34;&#34;
        # We don&#39;t use the builtin &#39;hex&#39; codec in python since it can
        # not handle odd numbers of digits, nor raise the same type
        # of exceptions we want to.
        n = 0
        for c in hexstring:
            if &#34;0&#34; &lt;= c &lt;= &#34;9&#34;:
                d = ord(c) - ord(&#34;0&#34;)
            elif &#34;a&#34; &lt;= c &lt;= &#34;f&#34;:
                d = ord(c) - ord(&#34;a&#34;) + 10
            elif &#34;A&#34; &lt;= c &lt;= &#34;F&#34;:
                d = ord(c) - ord(&#34;A&#34;) + 10
            else:
                raise ValueError(&#34;Not a hexadecimal number&#34;, hexstring)
            # Could use ((n &lt;&lt; 4 ) | d), but python 2.3 issues a FutureWarning.
            n = (n * 16) + d
        return n

    @staticmethod
    def decode_octal(octalstring):
        &#34;&#34;&#34;Decodes an octal string into it&#39;s integer value.&#34;&#34;&#34;
        n = 0
        for c in octalstring:
            if &#34;0&#34; &lt;= c &lt;= &#34;7&#34;:
                d = ord(c) - ord(&#34;0&#34;)
            else:
                raise ValueError(&#34;Not an octal number&#34;, octalstring)
            # Could use ((n &lt;&lt; 3 ) | d), but python 2.3 issues a FutureWarning.
            n = (n * 8) + d
        return n

    @staticmethod
    def decode_binary(binarystring):
        &#34;&#34;&#34;Decodes a binary string into it&#39;s integer value.&#34;&#34;&#34;
        n = 0
        for c in binarystring:
            if c == &#34;0&#34;:
                d = 0
            elif c == &#34;1&#34;:
                d = 1
            else:
                raise ValueError(&#34;Not an binary number&#34;, binarystring)
            # Could use ((n &lt;&lt; 3 ) | d), but python 2.3 issues a FutureWarning.
            n = (n * 2) + d
        return n

    @staticmethod
    def format_timedelta_iso(td):
        &#34;&#34;&#34;Encodes a datetime.timedelta into ISO-8601 Time Period format.&#34;&#34;&#34;
        d = td.days
        s = td.seconds
        ms = td.microseconds
        m, s = divmod(s, 60)
        h, m = divmod(m, 60)
        a = [&#34;P&#34;]
        if d:
            a.append(&#34;%dD&#34; % d)
        if h or m or s or ms:
            a.append(&#34;T&#34;)
        if h:
            a.append(&#34;%dH&#34; % h)
        if m:
            a.append(&#34;%dM&#34; % m)
        if s or ms:
            if ms:
                a.append(&#34;%d.%06d&#34; % (s, ms))
            else:
                a.append(&#34;%d&#34; % s)
        if len(a) == 1:
            a.append(&#34;T0S&#34;)
        return &#34;&#34;.join(a)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="demjson3.helpers.always_use_custom_codecs"><code class="name">var <span class="ident">always_use_custom_codecs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.helpers.hexdigits"><code class="name">var <span class="ident">hexdigits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.helpers.javascript_reserved_words"><code class="name">var <span class="ident">javascript_reserved_words</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.helpers.maxunicode"><code class="name">var <span class="ident">maxunicode</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.helpers.octaldigits"><code class="name">var <span class="ident">octaldigits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.helpers.sys"><code class="name">var <span class="ident">sys</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.helpers.unsafe_string_chars"><code class="name">var <span class="ident">unsafe_string_chars</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="demjson3.helpers.auto_detect_encoding"><code class="name flex">
<span>def <span class="ident">auto_detect_encoding</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a string (or byte array) and tries to determine the Unicode encoding it is in.</p>
<p>Returns the encoding name, as a string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def auto_detect_encoding(s):
    &#34;&#34;&#34;Takes a string (or byte array) and tries to determine the Unicode encoding it is in.

    Returns the encoding name, as a string.

    &#34;&#34;&#34;
    if not s or len(s) == 0:
        return &#34;utf-8&#34;

    # Get the byte values of up to the first 4 bytes
    ords = []
    for i in range(0, min(len(s), 4)):
        x = s[i]
        if isinstance(x, str):
            x = ord(x)
        ords.append(x)

    # Look for BOM marker
    import sys, codecs

    bom2, bom3, bom4 = None, None, None
    if len(s) &gt;= 2:
        bom2 = s[:2]
    if len(s) &gt;= 3:
        bom3 = s[:3]
    if len(s) &gt;= 4:
        bom4 = s[:4]

    # Assign values of first four bytes to: a, b, c, d; and last byte to: z
    a, b, c, d, z = None, None, None, None, None
    if len(s) &gt;= 1:
        a = ords[0]
    if len(s) &gt;= 2:
        b = ords[1]
    if len(s) &gt;= 3:
        c = ords[2]
    if len(s) &gt;= 4:
        d = ords[3]

    z = s[-1]
    if isinstance(z, str):
        z = ord(z)

    if bom4 and (
        (hasattr(codecs, &#34;BOM_UTF32_LE&#34;) and bom4 == codecs.BOM_UTF32_LE)
        or (bom4 == utf32.BOM_UTF32_LE)
    ):
        encoding = &#34;utf-32le&#34;
        s = s[4:]
    elif bom4 and (
        (hasattr(codecs, &#34;BOM_UTF32_BE&#34;) and bom4 == codecs.BOM_UTF32_BE)
        or (bom4 == utf32.BOM_UTF32_BE)
    ):
        encoding = &#34;utf-32be&#34;
        s = s[4:]
    elif bom2 and bom2 == codecs.BOM_UTF16_LE:
        encoding = &#34;utf-16le&#34;
        s = s[2:]
    elif bom2 and bom2 == codecs.BOM_UTF16_BE:
        encoding = &#34;utf-16be&#34;
        s = s[2:]
    elif bom3 and bom3 == codecs.BOM_UTF8:
        encoding = &#34;utf-8&#34;
        s = s[3:]

    # No BOM, so autodetect encoding used by looking at first four
    # bytes according to RFC 4627 section 3.  The first and last bytes
    # in a JSON document will be ASCII.  The second byte will be ASCII
    # unless the first byte was a quotation mark.

    elif (
        len(s) &gt;= 4 and a == 0 and b == 0 and c == 0 and d != 0
    ):  # UTF-32BE  (0 0 0 x)
        encoding = &#34;utf-32be&#34;
    elif (
        len(s) &gt;= 4 and a != 0 and b == 0 and c == 0 and d == 0 and z == 0
    ):  # UTF-32LE  (x 0 0 0 [... 0])
        encoding = &#34;utf-32le&#34;
    elif len(s) &gt;= 2 and a == 0 and b != 0:  # UTF-16BE  (0 x)
        encoding = &#34;utf-16be&#34;
    elif len(s) &gt;= 2 and a != 0 and b == 0 and z == 0:  # UTF-16LE  (x 0 [... 0])
        encoding = &#34;utf-16le&#34;
    elif ord(&#34;\t&#34;) &lt;= a &lt;= 127:
        # First byte appears to be ASCII, so guess UTF-8.
        encoding = &#34;utf8&#34;
    else:
        raise ValueError(&#34;Can not determine the Unicode encoding for byte stream&#34;)

    return encoding</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.char_is_identifier_leader"><code class="name flex">
<span>def <span class="ident">char_is_identifier_leader</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the character may be the first character of a
JavaScript identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def char_is_identifier_leader(c):
    &#34;&#34;&#34;Determines if the character may be the first character of a
    JavaScript identifier.
    &#34;&#34;&#34;
    return c.isalpha() or c in &#34;_$&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.char_is_identifier_tail"><code class="name flex">
<span>def <span class="ident">char_is_identifier_tail</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the character may be part of a JavaScript
identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def char_is_identifier_tail(c):
    &#34;&#34;&#34;Determines if the character may be part of a JavaScript
    identifier.
    &#34;&#34;&#34;
    return c.isalnum() or c in &#34;_$\u200c\u200d&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.char_is_json_eol"><code class="name flex">
<span>def <span class="ident">char_is_json_eol</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is a JSON line separator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def char_is_json_eol(c):
    &#34;&#34;&#34;Determines if the given character is a JSON line separator&#34;&#34;&#34;
    return c in &#34;\n\r&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.char_is_json_ws"><code class="name flex">
<span>def <span class="ident">char_is_json_ws</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is a JSON white-space character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def char_is_json_ws(c):
    &#34;&#34;&#34;Determines if the given character is a JSON white-space character&#34;&#34;&#34;
    return c in &#34; \t\n\r&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.char_is_unicode_eol"><code class="name flex">
<span>def <span class="ident">char_is_unicode_eol</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is a Unicode line or
paragraph separator. These correspond to CR and LF as well as
Unicode characters in the Zl or Zp categories.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def char_is_unicode_eol(c):
    &#34;&#34;&#34;Determines if the given character is a Unicode line or
    paragraph separator. These correspond to CR and LF as well as
    Unicode characters in the Zl or Zp categories.

    &#34;&#34;&#34;
    return c in &#34;\r\n\u2028\u2029&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.char_is_unicode_ws"><code class="name flex">
<span>def <span class="ident">char_is_unicode_ws</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is a Unicode space character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def char_is_unicode_ws(c):
    &#34;&#34;&#34;Determines if the given character is a Unicode space character&#34;&#34;&#34;
    if not isinstance(c, str):
        c = str(c)
    if c in &#34; \t\n\r\f\v&#34;:
        return True
    import unicodedata

    return unicodedata.category(c) == &#34;Zs&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.decode_binary"><code class="name flex">
<span>def <span class="ident">decode_binary</span></span>(<span>binarystring)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a binary string into it's integer value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode_binary(binarystring):
    &#34;&#34;&#34;Decodes a binary string into it&#39;s integer value.&#34;&#34;&#34;
    n = 0
    for c in binarystring:
        if c == &#34;0&#34;:
            d = 0
        elif c == &#34;1&#34;:
            d = 1
        else:
            raise ValueError(&#34;Not an binary number&#34;, binarystring)
        # Could use ((n &lt;&lt; 3 ) | d), but python 2.3 issues a FutureWarning.
        n = (n * 2) + d
    return n</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.decode_hex"><code class="name flex">
<span>def <span class="ident">decode_hex</span></span>(<span>hexstring)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a hexadecimal string into it's integer value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode_hex(hexstring):
    &#34;&#34;&#34;Decodes a hexadecimal string into it&#39;s integer value.&#34;&#34;&#34;
    # We don&#39;t use the builtin &#39;hex&#39; codec in python since it can
    # not handle odd numbers of digits, nor raise the same type
    # of exceptions we want to.
    n = 0
    for c in hexstring:
        if &#34;0&#34; &lt;= c &lt;= &#34;9&#34;:
            d = ord(c) - ord(&#34;0&#34;)
        elif &#34;a&#34; &lt;= c &lt;= &#34;f&#34;:
            d = ord(c) - ord(&#34;a&#34;) + 10
        elif &#34;A&#34; &lt;= c &lt;= &#34;F&#34;:
            d = ord(c) - ord(&#34;A&#34;) + 10
        else:
            raise ValueError(&#34;Not a hexadecimal number&#34;, hexstring)
        # Could use ((n &lt;&lt; 4 ) | d), but python 2.3 issues a FutureWarning.
        n = (n * 16) + d
    return n</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.decode_octal"><code class="name flex">
<span>def <span class="ident">decode_octal</span></span>(<span>octalstring)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes an octal string into it's integer value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode_octal(octalstring):
    &#34;&#34;&#34;Decodes an octal string into it&#39;s integer value.&#34;&#34;&#34;
    n = 0
    for c in octalstring:
        if &#34;0&#34; &lt;= c &lt;= &#34;7&#34;:
            d = ord(c) - ord(&#34;0&#34;)
        else:
            raise ValueError(&#34;Not an octal number&#34;, octalstring)
        # Could use ((n &lt;&lt; 3 ) | d), but python 2.3 issues a FutureWarning.
        n = (n * 8) + d
    return n</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.extend_and_flatten_list_with_sep"><code class="name flex">
<span>def <span class="ident">extend_and_flatten_list_with_sep</span></span>(<span>orig_seq, extension_seq, separator='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def extend_and_flatten_list_with_sep(orig_seq, extension_seq, separator=&#34;&#34;):
    for i, part in enumerate(extension_seq):
        if i &gt; 0 and separator:
            orig_seq.append(separator)
        orig_seq.extend(part)</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.format_timedelta_iso"><code class="name flex">
<span>def <span class="ident">format_timedelta_iso</span></span>(<span>td)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a datetime.timedelta into ISO-8601 Time Period format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_timedelta_iso(td):
    &#34;&#34;&#34;Encodes a datetime.timedelta into ISO-8601 Time Period format.&#34;&#34;&#34;
    d = td.days
    s = td.seconds
    ms = td.microseconds
    m, s = divmod(s, 60)
    h, m = divmod(m, 60)
    a = [&#34;P&#34;]
    if d:
        a.append(&#34;%dD&#34; % d)
    if h or m or s or ms:
        a.append(&#34;T&#34;)
    if h:
        a.append(&#34;%dH&#34; % h)
    if m:
        a.append(&#34;%dM&#34; % m)
    if s or ms:
        if ms:
            a.append(&#34;%d.%06d&#34; % (s, ms))
        else:
            a.append(&#34;%d&#34; % s)
    if len(a) == 1:
        a.append(&#34;T0S&#34;)
    return &#34;&#34;.join(a)</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.is_binary_digit"><code class="name flex">
<span>def <span class="ident">is_binary_digit</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is a valid binary digit (0 or 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_binary_digit(c):
    &#34;&#34;&#34;Determines if the given character is a valid binary digit (0 or 1).&#34;&#34;&#34;
    return c == &#34;0&#34; or c == &#34;1&#34;</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.is_hex_digit"><code class="name flex">
<span>def <span class="ident">is_hex_digit</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is a valid hexadecimal digit (0-9, a-f, A-F).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_hex_digit(c):
    &#34;&#34;&#34;Determines if the given character is a valid hexadecimal digit (0-9, a-f, A-F).&#34;&#34;&#34;
    return c in helpers.hexdigits</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.is_infinite"><code class="name flex">
<span>def <span class="ident">is_infinite</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the number infinite?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_infinite(n):
    &#34;&#34;&#34;Is the number infinite?&#34;&#34;&#34;
    if isinstance(n, float):
        return n is inf or n is neginf or n.hex() in (&#34;inf&#34;, &#34;-inf&#34;)
    elif decimal and isinstance(n, decimal.Decimal):
        return n.is_infinite()
    else:
        return False</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.is_nan"><code class="name flex">
<span>def <span class="ident">is_nan</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the number a NaN (not-a-number)?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_nan(n):
    &#34;&#34;&#34;Is the number a NaN (not-a-number)?&#34;&#34;&#34;
    if isinstance(n, float):
        return n is nan or n.hex() == &#34;nan&#34; or n != n
    elif decimal and isinstance(n, decimal.Decimal):
        return n.is_nan()
    else:
        return False</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.is_negzero"><code class="name flex">
<span>def <span class="ident">is_negzero</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the number value a negative zero?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_negzero(n):
    &#34;&#34;&#34;Is the number value a negative zero?&#34;&#34;&#34;
    if isinstance(n, float):
        return n == 0.0 and repr(n).startswith(&#34;-&#34;)
    elif decimal and isinstance(n, decimal.Decimal):
        return n.is_zero() and n.is_signed()
    else:
        return False</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.is_octal_digit"><code class="name flex">
<span>def <span class="ident">is_octal_digit</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if the given character is a valid octal digit (0-7).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_octal_digit(c):
    &#34;&#34;&#34;Determines if the given character is a valid octal digit (0-7).&#34;&#34;&#34;
    return c in helpers.octaldigits</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.isnumbertype"><code class="name flex">
<span>def <span class="ident">isnumbertype</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the object of a Python number type (excluding complex)?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isnumbertype(obj):
    &#34;&#34;&#34;Is the object of a Python number type (excluding complex)?&#34;&#34;&#34;
    return (
        isinstance(obj, (int, float))
        and not isinstance(obj, bool)
        or obj is nan
        or obj is inf
        or obj is neginf
        or (decimal and isinstance(obj, decimal.Decimal))
    )</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.isstringtype"><code class="name flex">
<span>def <span class="ident">isstringtype</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the object of a Python string type?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstringtype(obj):
    &#34;&#34;&#34;Is the object of a Python string type?&#34;&#34;&#34;
    if isinstance(obj, str):
        return True
    # Must also check for some other pseudo-string types
    import types, collections

    return isinstance(obj, (str,)) or isinstance(obj, collections.UserString)
    ## or isinstance(obj, UserString.MutableString)</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.lookup_codec"><code class="name flex">
<span>def <span class="ident">lookup_codec</span></span>(<span>encoding)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper around codecs.lookup().</p>
<p>Returns None if codec not found, rather than raising a LookupError.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def lookup_codec(encoding):
    &#34;&#34;&#34;Wrapper around codecs.lookup().

    Returns None if codec not found, rather than raising a LookupError.
    &#34;&#34;&#34;
    import codecs

    if isinstance(encoding, codecs.CodecInfo):
        return encoding
    encoding = encoding.lower()
    import codecs

    if helpers.always_use_custom_codecs:
        # Try custom utf32 first, then standard python codecs
        cdk = utf32.lookup(encoding)
        if not cdk:
            try:
                cdk = codecs.lookup(encoding)
            except LookupError:
                cdk = None
    else:
        # Try standard python codecs first, then custom utf32
        try:
            cdk = codecs.lookup(encoding)
        except LookupError:
            cdk = utf32.lookup(encoding)
    return cdk</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.make_raw_bytes"><code class="name flex">
<span>def <span class="ident">make_raw_bytes</span></span>(<span>byte_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructs a byte array (bytes in Python 3, str in Python 2) from a list of byte values (0-255).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_raw_bytes(byte_list):
    &#34;&#34;&#34;Constructs a byte array (bytes in Python 3, str in Python 2) from a list of byte values (0-255).&#34;&#34;&#34;
    return _make_raw_bytes(byte_list)</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.make_surrogate_pair"><code class="name flex">
<span>def <span class="ident">make_surrogate_pair</span></span>(<span>codepoint)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a Unicode codepoint (int) returns a 2-tuple of surrogate codepoints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def make_surrogate_pair(codepoint):
    &#34;&#34;&#34;Given a Unicode codepoint (int) returns a 2-tuple of surrogate codepoints.&#34;&#34;&#34;
    if codepoint &lt; 0x10000:
        return (codepoint, None)  # in BMP, surrogate pair not required
    v = codepoint - 0x10000
    vh = (v &gt;&gt; 10) &amp; 0x3FF  # highest 10 bits
    vl = v &amp; 0x3FF  # lowest 10 bits
    w1 = 0xD800 | vh
    w2 = 0xDC00 | vl
    return (w1, w2)</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.safe_unichr"><code class="name flex">
<span>def <span class="ident">safe_unichr</span></span>(<span>codepoint)</span>
</code></dt>
<dd>
<div class="desc"><p>Just like Python's unichr() but works in narrow-Unicode Pythons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def safe_unichr(codepoint):
    &#34;&#34;&#34;Just like Python&#39;s unichr() but works in narrow-Unicode Pythons.&#34;&#34;&#34;
    if codepoint &gt;= 0x10000 and codepoint &gt; helpers.maxunicode:
        # Narrow-Unicode python, construct a UTF-16 surrogate pair.
        w1, w2 = helpers.make_surrogate_pair(codepoint)
        if w2 is None:
            c = chr(w1)
        else:
            c = chr(w1) + chr(w2)
    else:
        c = chr(codepoint)
    return c</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.strip_format_control_chars"><code class="name flex">
<span>def <span class="ident">strip_format_control_chars</span></span>(<span>txt)</span>
</code></dt>
<dd>
<div class="desc"><p>Filters out all Unicode format control characters from the string.</p>
<p>ECMAScript permits any Unicode "format control characters" to
appear at any place in the source code.
They are to be
ignored as if they are not there before any other lexical
tokenization occurs.
Note that JSON does not allow them,
except within string literals.</p>
<ul>
<li>Ref. ECMAScript section 7.1.</li>
<li><a href="http://en.wikipedia.org/wiki/Unicode_control_characters">http://en.wikipedia.org/wiki/Unicode_control_characters</a></li>
</ul>
<p>There are dozens of Format Control Characters, for example:
U+00AD
SOFT HYPHEN
U+200B
ZERO WIDTH SPACE
U+2060
WORD JOINER</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def strip_format_control_chars(txt):
    &#34;&#34;&#34;Filters out all Unicode format control characters from the string.

    ECMAScript permits any Unicode &#34;format control characters&#34; to
    appear at any place in the source code.  They are to be
    ignored as if they are not there before any other lexical
    tokenization occurs.  Note that JSON does not allow them,
    except within string literals.

    * Ref. ECMAScript section 7.1.
    * http://en.wikipedia.org/wiki/Unicode_control_characters

    There are dozens of Format Control Characters, for example:
        U+00AD   SOFT HYPHEN
        U+200B   ZERO WIDTH SPACE
        U+2060   WORD JOINER

    &#34;&#34;&#34;
    import unicodedata

    txt2 = [c for c in txt if unicodedata.category(str(c)) != &#34;Cf&#34;]

    # 2to3 NOTE: The following is needed to work around a broken
    # Python3 conversion in which filter() will be transformed
    # into a list rather than a string.
    if not isinstance(txt2, str):
        txt2 = &#34;&#34;.join(txt2)
    return txt2</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.surrogate_pair_as_unicode"><code class="name flex">
<span>def <span class="ident">surrogate_pair_as_unicode</span></span>(<span>c1, c2)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a pair of unicode surrogates and returns the equivalent unicode character.</p>
<p>The input pair must be a surrogate pair, with c1 in the range
U+D800 to U+DBFF and c2 in the range U+DC00 to U+DFFF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def surrogate_pair_as_unicode(c1, c2):
    &#34;&#34;&#34;Takes a pair of unicode surrogates and returns the equivalent unicode character.

    The input pair must be a surrogate pair, with c1 in the range
    U+D800 to U+DBFF and c2 in the range U+DC00 to U+DFFF.

    &#34;&#34;&#34;
    n1, n2 = ord(c1), ord(c2)
    if n1 &lt; 0xD800 or n1 &gt; 0xDBFF or n2 &lt; 0xDC00 or n2 &gt; 0xDFFF:
        raise JSONDecodeError(&#34;illegal Unicode surrogate pair&#34;, (c1, c2))
    a = n1 - 0xD800
    b = n2 - 0xDC00
    v = (a &lt;&lt; 10) | b
    v += 0x10000
    return helpers.safe_unichr(v)</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.unicode_as_surrogate_pair"><code class="name flex">
<span>def <span class="ident">unicode_as_surrogate_pair</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a single unicode character and returns a sequence of surrogate pairs.</p>
<p>The output of this function is a tuple consisting of one or two unicode
characters, such that if the input character is outside the BMP range
then the output is a two-character surrogate pair representing that character.</p>
<p>If the input character is inside the BMP then the output tuple will have
just a single character&hellip;the same one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unicode_as_surrogate_pair(c):
    &#34;&#34;&#34;Takes a single unicode character and returns a sequence of surrogate pairs.

    The output of this function is a tuple consisting of one or two unicode
    characters, such that if the input character is outside the BMP range
    then the output is a two-character surrogate pair representing that character.

    If the input character is inside the BMP then the output tuple will have
    just a single character...the same one.

    &#34;&#34;&#34;
    n = ord(c)
    w1, w2 = helpers.make_surrogate_pair(n)
    if w2 is None:
        return (chr(w1),)
    else:
        return (chr(w1), chr(w2))</code></pre>
</details>
</dd>
<dt id="demjson3.helpers.unicode_decode"><code class="name flex">
<span>def <span class="ident">unicode_decode</span></span>(<span>txt, encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a string (or byte array) and tries to convert it to a Unicode string.</p>
<p>Returns a named tuple:
(string, codec, bom)</p>
<p>The 'encoding' argument, if supplied, should either the name of
a character encoding, or an instance of codecs.CodecInfo.
If
the encoding argument is None or "auto" then the encoding is
automatically determined, if possible.</p>
<p>Any BOM (Byte Order Mark) that is found at the beginning of the
input will be stripped off and placed in the 'bom' portion of
the returned value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unicode_decode(txt, encoding=None):
    &#34;&#34;&#34;Takes a string (or byte array) and tries to convert it to a Unicode string.

    Returns a named tuple:  (string, codec, bom)

    The &#39;encoding&#39; argument, if supplied, should either the name of
    a character encoding, or an instance of codecs.CodecInfo.  If
    the encoding argument is None or &#34;auto&#34; then the encoding is
    automatically determined, if possible.

    Any BOM (Byte Order Mark) that is found at the beginning of the
    input will be stripped off and placed in the &#39;bom&#39; portion of
    the returned value.

    &#34;&#34;&#34;
    if isinstance(txt, str):
        res = _namedtuple(&#34;DecodedString&#34;, [&#34;string&#34;, &#34;codec&#34;, &#34;bom&#34;])(
            txt, None, None
        )
    else:
        if encoding is None or encoding == &#34;auto&#34;:
            encoding = helpers.auto_detect_encoding(txt)

        cdk = helpers.lookup_codec(encoding)
        if not cdk:
            raise LookupError(&#34;Can not find codec for encoding %r&#34; % encoding)

        try:
            # Determine if codec takes arguments; try a decode of nothing
            cdk.decode(helpers.make_raw_bytes([]), errors=&#34;strict&#34;)
        except TypeError:
            cdk_kw = {}  # This coded doesn&#39;t like the errors argument
        else:
            cdk_kw = {&#34;errors&#34;: &#34;strict&#34;}

        unitxt, numbytes = cdk.decode(txt, **cdk_kw)  # DO THE DECODE HERE!

        # Remove BOM if present
        if len(unitxt) &gt; 0 and unitxt[0] == &#34;\uFEFF&#34;:
            bom = cdk.encode(unitxt[0])[0]
            unitxt = unitxt[1:]
        elif len(unitxt) &gt; 0 and unitxt[0] == &#34;\uFFFE&#34;:  # Reversed BOM
            raise UnicodeDecodeError(
                cdk.name, txt, 0, 0, &#34;Wrong byte order, found reversed BOM U+FFFE&#34;
            )
        else:
            bom = None

        res = _namedtuple(&#34;DecodedString&#34;, [&#34;string&#34;, &#34;codec&#34;, &#34;bom&#34;])(
            unitxt, cdk, bom
        )
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.json_int"><code class="flex name class">
<span>class <span class="ident">json_int</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of the Python int/long that remembers its format (hex,octal,etc).</p>
<p>Initialize it the same as an int, but also accepts an additional keyword
argument 'number_format' which should be one of the NUMBER_FORMAT_* values.</p>
<pre><code>n = json_int( x[, base, number_format=NUMBER_FORMAT_DECIMAL] )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class json_int(int):  # Have to specify base this way to satisfy 2to3
    &#34;&#34;&#34;A subclass of the Python int/long that remembers its format (hex,octal,etc).

    Initialize it the same as an int, but also accepts an additional keyword
    argument &#39;number_format&#39; which should be one of the NUMBER_FORMAT_* values.

        n = json_int( x[, base, number_format=NUMBER_FORMAT_DECIMAL] )

    &#34;&#34;&#34;

    def __new__(cls, *args, **kwargs):
        if &#34;number_format&#34; in kwargs:
            number_format = kwargs[&#34;number_format&#34;]
            del kwargs[&#34;number_format&#34;]
            if number_format not in (
                NUMBER_FORMAT_DECIMAL,
                NUMBER_FORMAT_HEX,
                NUMBER_FORMAT_OCTAL,
                NUMBER_FORMAT_LEGACYOCTAL,
                NUMBER_FORMAT_BINARY,
            ):
                raise TypeError(&#34;json_int(): Invalid value for number_format argument&#34;)
        else:
            number_format = NUMBER_FORMAT_DECIMAL
        obj = super(json_int, cls).__new__(cls, *args, **kwargs)
        obj._jsonfmt = number_format
        return obj

    @property
    def number_format(self):
        &#34;&#34;&#34;The original radix format of the number&#34;&#34;&#34;
        return self._jsonfmt

    def json_format(self):
        &#34;&#34;&#34;Returns the integer value formatted as a JSON literal&#34;&#34;&#34;
        fmt = self._jsonfmt
        if fmt == NUMBER_FORMAT_HEX:
            return format(self, &#34;#x&#34;)
        elif fmt == NUMBER_FORMAT_OCTAL:
            return format(self, &#34;#o&#34;)
        elif fmt == NUMBER_FORMAT_BINARY:
            return format(self, &#34;#b&#34;)
        elif fmt == NUMBER_FORMAT_LEGACYOCTAL:
            if self == 0:
                return &#34;0&#34;  # For some reason Python&#39;s int doesn&#39;t do &#39;00&#39;
            elif self &lt; 0:
                return &#34;-0%o&#34; % (-self)
            else:
                return &#34;0%o&#34; % self
        else:
            return str(self)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.int</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.json_int.number_format"><code class="name">var <span class="ident">number_format</span></code></dt>
<dd>
<div class="desc"><p>The original radix format of the number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_format(self):
    &#34;&#34;&#34;The original radix format of the number&#34;&#34;&#34;
    return self._jsonfmt</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.json_int.json_format"><code class="name flex">
<span>def <span class="ident">json_format</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the integer value formatted as a JSON literal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_format(self):
    &#34;&#34;&#34;Returns the integer value formatted as a JSON literal&#34;&#34;&#34;
    fmt = self._jsonfmt
    if fmt == NUMBER_FORMAT_HEX:
        return format(self, &#34;#x&#34;)
    elif fmt == NUMBER_FORMAT_OCTAL:
        return format(self, &#34;#o&#34;)
    elif fmt == NUMBER_FORMAT_BINARY:
        return format(self, &#34;#b&#34;)
    elif fmt == NUMBER_FORMAT_LEGACYOCTAL:
        if self == 0:
            return &#34;0&#34;  # For some reason Python&#39;s int doesn&#39;t do &#39;00&#39;
        elif self &lt; 0:
            return &#34;-0%o&#34; % (-self)
        else:
            return &#34;0%o&#34; % self
    else:
        return str(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.json_options"><code class="flex name class">
<span>class <span class="ident">json_options</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Options to determine how strict the decoder or encoder should be.</p>
<p>Set JSON encoding and decoding options.</p>
<p>If 'strict' is set to True, then only strictly-conforming JSON
output will be produced.
Note that this means that some types
of values may not be convertable and will result in a
JSONEncodeError exception.</p>
<p>If 'compactly' is set to True, then the resulting string will
have all extraneous white space removed; if False then the
string will be "pretty printed" with whitespace and indentation
added to make it more readable.</p>
<p>If 'escape_unicode' is set to True, then all non-ASCII characters
will be represented as a unicode escape sequence; if False then
the actual real unicode character will be inserted if possible.</p>
<p>The 'escape_unicode' can also be a function, which when called
with a single argument of a unicode character will return True
if the character should be escaped or False if it should not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class json_options(object, metaclass=_behaviors_metaclass):
    &#34;&#34;&#34;Options to determine how strict the decoder or encoder should be.&#34;&#34;&#34;

    _behavior_values = (ALLOW, WARN, FORBID)
    _behaviors = (
        (
            &#34;all_numeric_signs&#34;,
            &#34;Numbers may be prefixed by any &#39;+&#39; and &#39;-&#39;, e.g., +4, -+-+77&#34;,
        ),
        (
            &#34;any_type_at_start&#34;,
            &#34;A JSON document may start with any type, not just arrays or objects&#34;,
        ),
        (&#34;comments&#34;, &#34;JavaScript comments, both /*...*/ and //... styles&#34;),
        (
            &#34;control_char_in_string&#34;,
            &#34;Strings may contain raw control characters without \\u-escaping&#34;,
        ),
        (&#34;hex_numbers&#34;, &#34;Hexadecimal numbers, e.g., 0x1f&#34;),
        (&#34;binary_numbers&#34;, &#34;Binary numbers, e.g., 0b1001&#34;),
        (
            &#34;octal_numbers&#34;,
            &#34;New-style octal numbers, e.g., 0o731  (see leading-zeros for legacy octals)&#34;,
        ),
        (
            &#34;initial_decimal_point&#34;,
            &#34;Floating-point numbers may start with a decimal point (no units digit)&#34;,
        ),
        (
            &#34;extended_unicode_escapes&#34;,
            &#34;Extended Unicode escape sequence \\u{..} for non-BMP characters&#34;,
        ),
        (
            &#34;js_string_escapes&#34;,
            &#34;All JavaScript character \\-escape sequences may be in strings&#34;,
        ),
        (
            &#34;leading_zeros&#34;,
            &#34;Numbers may have extra leading zeros (see --leading-zero-radix option)&#34;,
        ),
        (&#34;non_numbers&#34;, &#34;Non-numbers may be used, such as NaN or Infinity&#34;),
        (
            &#34;nonescape_characters&#34;,
            &#34;Unknown character \\-escape sequences stand for that character (\\Q -&gt; &#39;Q&#39;)&#34;,
        ),
        (
            &#34;identifier_keys&#34;,
            &#34;JavaScript identifiers are converted to strings when used as object keys&#34;,
        ),
        (
            &#34;nonstring_keys&#34;,
            &#34;Value types other than strings (or identifiers) may be used as object keys&#34;,
        ),
        (
            &#34;omitted_array_elements&#34;,
            &#34;Arrays may have omitted/elided elements, e.g., [1,,3] == [1,undefined,3]&#34;,
        ),
        (
            &#34;single_quoted_strings&#34;,
            &#34;Strings may be delimited with both double (\&#34;) and single (&#39;) quotation marks&#34;,
        ),
        (&#34;trailing_comma&#34;, &#34;A final comma may end the list of array or object members&#34;),
        (
            &#34;trailing_decimal_point&#34;,
            &#34;Floating-point number may end with a decimal point and no following fractional digits&#34;,
        ),
        (&#34;undefined_values&#34;, &#34;The JavaScript &#39;undefined&#39; value may be used&#34;),
        (
            &#34;format_control_chars&#34;,
            &#39;Unicode &#34;format control characters&#34; may appear in the input&#39;,
        ),
        (
            &#34;unicode_whitespace&#34;,
            &#34;Treat any Unicode whitespace character as valid whitespace&#34;,
        ),
        # Never legal
        (&#34;leading_zeros&#34;, &#34;Numbers may have leading zeros&#34;),
        # Normally warnings
        (&#34;duplicate_keys&#34;, &#34;Objects may have repeated keys&#34;),
        (
            &#34;zero_byte&#34;,
            &#34;Strings may contain U+0000, which may not be safe for C-based programs&#34;,
        ),
        (&#34;bom&#34;, &#34;A JSON document may start with a Unicode BOM (Byte Order Mark)&#34;),
        (
            &#34;non_portable&#34;,
            &#34;Anything technically valid but likely to cause data portablibity issues&#34;,
        ),
    )  # end behavior list

    def reset_to_defaults(self):
        # Plain attrs (other than above behaviors) are simply copied
        # by value, either during initialization (via keyword
        # arguments) or via the copy() method.
        self._plain_attrs = [
            &#34;leading_zero_radix&#34;,
            &#34;encode_namedtuple_as_object&#34;,
            &#34;encode_enum_as&#34;,
            &#34;encode_compactly&#34;,
            &#34;escape_unicode&#34;,
            &#34;always_escape_chars&#34;,
            &#34;warn_string_length&#34;,
            &#34;warn_max_depth&#34;,
            &#34;int_as_float&#34;,
            &#34;decimal_context&#34;,
            &#34;float_type&#34;,
            &#34;keep_format&#34;,
            &#34;date_format&#34;,
            &#34;datetime_format&#34;,
            &#34;time_format&#34;,
            &#34;timedelta_format&#34;,
            &#34;sort_keys&#34;,
            &#34;indent_amount&#34;,
            &#34;indent_tab_width&#34;,
            &#34;indent_limit&#34;,
            &#34;max_items_per_line&#34;,
            &#34;py2str_encoding&#34;,
        ]

        self.strictness = STRICTNESS_WARN
        self._leading_zero_radix = 8  # via property: leading_zero_radix
        self._sort_keys = SORT_SMART  # via property: sort_keys

        self.int_as_float = False
        self.float_type = NUMBER_AUTO
        self.decimal_context = decimal.DefaultContext if decimal else None
        self.keep_format = False  # keep track of when numbers are hex, octal, etc.

        self.encode_namedtuple_as_object = True
        self._encode_enum_as = &#34;name&#34;  # via property
        self.encode_compactly = True
        self.escape_unicode = False
        self.always_escape_chars = (
            None  # None, or a set of Unicode characters to always escape
        )

        self.warn_string_length = 0xFFFD  # with 16-bit length prefix
        self.warn_max_depth = 64

        self.date_format = &#34;iso&#34;  # or strftime format
        self.datetime_format = &#34;iso&#34;  # or strftime format
        self.time_format = &#34;iso&#34;  # or strftime format
        self.timedelta_format = &#34;iso&#34;  # or &#39;hms&#39;

        self.sort_keys = SORT_ALPHA
        self.indent_amount = 2
        self.indent_tab_width = 0  # 0, or number of equivalent spaces
        self.indent_limit = None
        self.max_items_per_line = 1  # When encoding how many items per array/object
        # before breaking into multiple lines
        # For interpreting Python 2 &#39;str&#39; types:
        self.py2str_encoding = None

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Set JSON encoding and decoding options.

        If &#39;strict&#39; is set to True, then only strictly-conforming JSON
        output will be produced.  Note that this means that some types
        of values may not be convertable and will result in a
        JSONEncodeError exception.

        If &#39;compactly&#39; is set to True, then the resulting string will
        have all extraneous white space removed; if False then the
        string will be &#34;pretty printed&#34; with whitespace and indentation
        added to make it more readable.

        If &#39;escape_unicode&#39; is set to True, then all non-ASCII characters
        will be represented as a unicode escape sequence; if False then
        the actual real unicode character will be inserted if possible.

        The &#39;escape_unicode&#39; can also be a function, which when called
        with a single argument of a unicode character will return True
        if the character should be escaped or False if it should not.

        &#34;&#34;&#34;
        self.reset_to_defaults()

        if &#34;strict&#34; in kwargs:
            # Do this keyword first, so other keywords may override specific behaviors
            self.strictness = kwargs[&#34;strict&#34;]

        for kw, val in list(kwargs.items()):
            if kw == &#34;compactly&#34;:  # alias for &#39;encode_compactly&#39;
                self.encode_compactly = val
            elif kw == &#34;strict&#34;:
                pass  # Already handled
            elif kw == &#34;warnings&#34;:
                if val:
                    self.suppress_warnings()
            elif kw == &#34;html_safe&#34; or kw == &#34;xml_safe&#34;:
                if bool(val):
                    if self.always_escape_chars is None:
                        self.always_escape_chars = set(&#34;&lt;&gt;/&amp;&#34;)
                    else:
                        self.always_escape_chars.update(set(&#34;&lt;&gt;/&amp;&#34;))
            elif kw == &#34;always_escape&#34;:
                if val:
                    if self.always_escape_chars is None:
                        self.always_escape_chars = set(val)
                    else:
                        self.always_escape_chars.update(set(val))
            elif kw == &#34;int_as_float&#34;:
                self.int_as_float = bool(val)
            elif kw == &#34;keep_format&#34;:
                self.keep_format = bool(val)
            elif kw == &#34;float_type&#34;:
                if val in (NUMBER_AUTO, NUMBER_FLOAT, NUMBER_DECIMAL):
                    self.float_type = val
                else:
                    raise ValueError(
                        &#34;Unknown option %r for argument %r to initialize %s&#34;
                        % (val, kw, self.__class__.__name__)
                    )
            elif kw == &#34;decimal&#34; or kw == &#34;decimal_context&#34;:
                if decimal:
                    if not val or val == &#34;default&#34;:
                        self.decimal_context = decimal.DefaultContext
                    elif val == &#34;basic&#34;:
                        self.decimal_context = decimal.BasicContext
                    elif val == &#34;extended&#34;:
                        self.decimal_context = decimal.ExtendedContext
                    elif isinstance(val, decimal.Context):
                        self.decimal_context = val
                    elif isinstance(val, int) or val[0].isdigit:
                        prec = int(val)
                        self.decimal_context = decimal.Context(prec=prec)
                    else:
                        raise ValueError(
                            &#34;Option for %r should be a decimal.Context, a number of significant digits, or one of &#39;default&#39;,&#39;basic&#39;, or &#39;extended&#39;.&#34;
                            % (kw,)
                        )
            elif kw in (&#34;allow&#34;, &#34;warn&#34;, &#34;forbid&#34;, &#34;prevent&#34;, &#34;deny&#34;):
                action = {
                    &#34;allow&#34;: ALLOW,
                    &#34;warn&#34;: WARN,
                    &#34;forbid&#34;: FORBID,
                    &#34;prevent&#34;: FORBID,
                    &#34;deny&#34;: FORBID,
                }[kw]
                if isinstance(val, str):
                    val = [b.replace(&#34;-&#34;, &#34;_&#34;) for b in val.replace(&#34;,&#34;, &#34; &#34;).split()]
                for behavior in val:
                    self.set_behavior(behavior, action)
            elif (
                kw.startswith(&#34;allow_&#34;)
                or kw.startswith(&#34;forbid_&#34;)
                or kw.startswith(&#34;prevent_&#34;)
                or kw.startswith(&#34;deny_&#34;)
                or kw.startswith(&#34;warn_&#34;)
            ):
                action, behavior = kw.split(&#34;_&#34;, 1)
                if action == &#34;allow&#34;:
                    if val:
                        self.set_behavior(behavior, ALLOW)
                    else:
                        self.set_behavior(behavior, FORBID)
                elif action in (&#34;forbid&#34;, &#34;prevent&#34;, &#34;deny&#34;):
                    if val:
                        self.set_behavior(behavior, FORBID)
                    else:
                        self.set_behavior(behavior, ALLOW)
                elif action == &#34;warn&#34;:
                    if val:
                        self.set_behavior(behavior, WARN)
                    else:
                        self.set_behavior(behavior, ALLOW)
            elif kw in self._plain_attrs:
                setattr(self, kw, val)
            else:
                raise ValueError(
                    &#34;Unknown keyword argument %r to initialize %s&#34;
                    % (kw, self.__class__.__name__)
                )

    def copy(self):
        other = self.__class__()
        other.copy_from(self)
        return other

    def copy_from(self, other):
        if self is other:
            return  # Myself!

        self.strictness = other.strictness  # sets behaviors in bulk

        for name in self.all_behaviors:
            self.set_behavior(name, other.get_behavior(name))

        for name in self._plain_attrs:
            val = getattr(other, name)
            if isinstance(val, set):
                val = val.copy()
            elif decimal and isinstance(val, decimal.Decimal):
                val = decimal.Decimal(val)

            setattr(self, name, val)

    def spaces_to_next_indent_level(self, min_spaces=1, subtract=0):
        n = self.indent_amount - subtract
        if n &lt; 0:
            n = 0
        n = max(min_spaces, n)
        return &#34; &#34; * n

    def indentation_for_level(self, level=0):
        &#34;&#34;&#34;Returns a whitespace string used for indenting.&#34;&#34;&#34;
        if self.indent_limit is not None and level &gt; self.indent_limit:
            n = self.indent_limit
        else:
            n = level
        n *= self.indent_amount
        if self.indent_tab_width:
            tw, sw = divmod(n, self.indent_tab_width)
            return &#34;\t&#34; * tw + &#34; &#34; * sw
        else:
            return &#34; &#34; * n

    def set_indent(self, num_spaces, tab_width=0, limit=None):
        &#34;&#34;&#34;Changes the indentation properties when outputting JSON in non-compact mode.

        &#39;num_spaces&#39; is the number of spaces to insert for each level
        of indentation, which defaults to 2.

        &#39;tab_width&#39;, if not 0, is the number of spaces which is equivalent
        to one tab character.  Tabs will be output where possible rather
        than runs of spaces.

        &#39;limit&#39;, if not None, is the maximum indentation level after
        which no further indentation will be output.

        &#34;&#34;&#34;
        n = int(num_spaces)
        if n &lt; 0:
            raise ValueError(&#34;indentation amount can not be negative&#34;, n)
        self.indent_amount = n
        self.indent_tab_width = tab_width
        self.indent_limit = limit

    @property
    def sort_keys(self):
        &#34;&#34;&#34;The method used to sort dictionary keys when encoding JSON&#34;&#34;&#34;
        return self._sort_keys

    @sort_keys.setter
    def sort_keys(self, method):
        if not method:
            self._sort_keys = SORT_NONE
        elif callable(method):
            self._sort_keys = method
        elif method in sorting_methods:
            self._sort_keys = method
        elif method in sorting_method_aliases:  # alias
            self._sort_keys = sorting_method_aliases[method]
        elif method:
            self._sort_keys = SORT_ALPHA
        else:
            raise ValueError(&#34;Not a valid sorting method: %r&#34; % method)

    @property
    def encode_enum_as(self):
        &#34;&#34;&#34;The strategy for encoding Python Enum values.&#34;&#34;&#34;
        return self._encode_enum_as

    @encode_enum_as.setter
    def encode_enum_as(self, val):
        if val not in (&#34;name&#34;, &#34;qname&#34;, &#34;value&#34;):
            raise ValueError(&#34;encode_enum_as must be one of &#39;name&#39;,&#39;qname&#39;, or &#39;value&#39;&#34;)
        self._encode_enum_as = val

    @property
    def zero_float(self):
        &#34;&#34;&#34;The numeric value 0.0, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;0.0&#34;)
        else:
            return 0.0

    @property
    def negzero_float(self):
        &#34;&#34;&#34;The numeric value -0.0, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;-0.0&#34;)
        else:
            return -0.0

    @property
    def nan(self):
        &#34;&#34;&#34;The numeric value NaN, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;NaN&#34;)
        else:
            return nan

    @property
    def inf(self):
        &#34;&#34;&#34;The numeric value Infinity, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;Infinity&#34;)
        else:
            return inf

    @property
    def neginf(self):
        &#34;&#34;&#34;The numeric value -Infinity, either a float or a decimal.&#34;&#34;&#34;
        if self.float_type == NUMBER_DECIMAL:
            return self.decimal_context.create_decimal(&#34;-Infinity&#34;)
        else:
            return neginf

    def make_int(self, s, sign=None, number_format=NUMBER_FORMAT_DECIMAL):
        &#34;&#34;&#34;Makes an integer value according to the current options.

        First argument should be a string representation of the number,
        or an integer.

        Returns a number value, which could be an int, float, or decimal.

        &#34;&#34;&#34;
        if isinstance(sign, int):
            if sign &lt; 0:
                sign = &#34;-&#34;
            else:
                sign = &#34;+&#34;
        if isinstance(s, str):
            if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
                sign = s[0]
                s = s[1:]

        if self.int_as_float:
            # Making a float/decimal
            if isinstance(s, int):
                if self.float_type == NUMBER_DECIMAL:
                    n = self.decimal_context.create_decimal(s)
                    if sign == &#34;-&#34;:
                        n = n.copy_negate()
                elif s == 0 and sign == &#34;-&#34;:
                    n = self.negzero_float
                elif -999999999999999 &lt;= s &lt;= 999999999999999:
                    n = float(s)
                    if sign == &#34;-&#34;:
                        n *= -1
                else:
                    n = float(s)
                    if (n == inf or int(n) != s) and self.float_type != NUMBER_FLOAT:
                        n = self.decimal_context.create_decimal(s)
                        if sign == &#34;-&#34;:
                            n = n.copy_negate()
                    elif sign == &#34;-&#34;:
                        n *= -1
            else:  # not already an int
                n = self.make_float(s, sign)
                n2 = self.make_float(s[:-1] + (&#34;9&#34; if s[-1] &lt;= &#34;5&#34; else &#34;0&#34;), sign)
                if (n == inf or n == n2) and self.float_type != NUMBER_FLOAT:
                    n = self.make_decimal(s, sign)
        elif isinstance(s, int):
            # already an integer
            n = s
            if sign == &#34;-&#34;:
                if n == 0:
                    n = self.negzero_float
                else:
                    n *= -1
        else:
            # Making an actual integer
            try:
                n = int(s)
            except ValueError:
                n = self.nan
            else:
                if sign == &#34;-&#34;:
                    if n == 0:
                        n = self.negzero_float
                    else:
                        n *= -1
        if isinstance(n, int) and self.keep_format:
            n = json_int(n, number_format=number_format)
        return n

    def make_decimal(self, s, sign=&#34;+&#34;):
        &#34;&#34;&#34;Converts a string into a decimal or float value.&#34;&#34;&#34;
        if self.float_type == NUMBER_FLOAT:
            return self.make_float(s, sign)

        if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
            sign = s[0]
            s = s[1:]
        elif isinstance(sign, int):
            if sign &lt; 0:
                sign = &#34;-&#34;
            else:
                sign = &#34;+&#34;

        try:
            f = self.decimal_context.create_decimal(s)
        except decimal.InvalidOperation:
            f = self.decimal_context.create_decimal(&#34;NaN&#34;)
        except decimal.Overflow:
            if sign == &#34;-&#34;:
                f = self.decimal_context.create_decimal(&#34;-Infinity&#34;)
            else:
                f = self.decimal_context.create_decimal(&#34;Infinity&#34;)
        else:
            if sign == &#34;-&#34;:
                f = f.copy_negate()
        return f

    def make_float(self, s, sign=&#34;+&#34;):
        &#34;&#34;&#34;Converts a string into a float or decimal value.&#34;&#34;&#34;
        if decimal and self.float_type == NUMBER_DECIMAL:
            return self.make_decimal(s, sign)

        if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
            sign = s[0]
            s = s[1:]
        elif isinstance(sign, int):
            if sign &lt; 0:
                sign = &#34;-&#34;
            else:
                sign = &#34;+&#34;

        try:
            f = float(s)
        except ValueError:
            f = nan
        else:
            if sign == &#34;-&#34;:
                f *= -1
        return f

    @property
    def leading_zero_radix(self):
        &#34;&#34;&#34;The radix to be used for numbers with leading zeros.  8 or 10&#34;&#34;&#34;
        return self._leading_zero_radix

    @leading_zero_radix.setter
    def leading_zero_radix(self, radix):
        if isinstance(radix, str):
            try:
                radix = int(radix)
            except ValueError:
                radix = radix.lower()
                if radix == &#34;octal&#34; or radix == &#34;oct&#34; or radix == &#34;8&#34;:
                    radix = 8
                elif radix == &#34;decimal&#34; or radix == &#34;dec&#34;:
                    radix = 10
        if radix not in (8, 10):
            raise ValueError(&#34;Radix must either be 8 (octal) or 10 (decimal)&#34;)
        self._leading_zero_radix = radix

    @property
    def leading_zero_radix_as_word(self):
        return {8: &#34;octal&#34;, 10: &#34;decimal&#34;}[self._leading_zero_radix]

    def suppress_warnings(self):
        for name in self.warn_behaviors:
            self.set_behavior(name, &#34;allow&#34;)

    @property
    def allow_or_warn_behaviors(self):
        &#34;&#34;&#34;Returns the set of all behaviors that are not forbidden (i.e., are allowed or warned).&#34;&#34;&#34;
        return self.allow_behaviors.union(self.warn_behaviors)

    @property
    def strictness(self):
        return self._strictness

    @strictness.setter
    def strictness(self, strict):
        &#34;&#34;&#34;Changes whether the options should be re-configured for strict JSON conformance.&#34;&#34;&#34;
        if strict == STRICTNESS_WARN:
            self._strictness = STRICTNESS_WARN
            self.set_all_warn()
        elif strict == STRICTNESS_STRICT or strict is True:
            self._strictness = STRICTNESS_STRICT
            self.keep_format = False
            self.set_all_forbid()
            self.warn_duplicate_keys()
            self.warn_zero_byte()
            self.warn_bom()
            self.warn_non_portable()
        elif strict == STRICTNESS_TOLERANT or strict is False:
            self._strictness = STRICTNESS_TOLERANT
            self.set_all_allow()
            self.warn_duplicate_keys()
            self.warn_zero_byte()
            self.warn_leading_zeros()
            self.leading_zero_radix = 8
            self.warn_bom()
            self.allow_non_portable()
        else:
            raise ValueError(&#34;Unknown strictness options %r&#34; % strict)
        self.allow_any_type_at_start()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.json_options.all_behaviors"><code class="name">var <span class="ident">all_behaviors</span></code></dt>
<dd>
<div class="desc"><p>Returns the names of all known behaviors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def all_behaviors(self):
    &#34;&#34;&#34;Returns the names of all known behaviors.&#34;&#34;&#34;
    return set([t[0] for t in self._behaviors])</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.all_numeric_signs"><code class="name">var <span class="ident">all_numeric_signs</span></code></dt>
<dd>
<div class="desc"><p>Numbers may be prefixed by any '+' and '-', e.g., +4, -+-+77</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_behaviors"><code class="name">var <span class="ident">allow_behaviors</span></code></dt>
<dd>
<div class="desc"><p>Return the set of behaviors with the value allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getbehaviorsfor(self, value=v):
    return set(
        [
            name
            for name in self.all_behaviors
            if getattr(self, name) == value
        ]
    )</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_or_warn_behaviors"><code class="name">var <span class="ident">allow_or_warn_behaviors</span></code></dt>
<dd>
<div class="desc"><p>Returns the set of all behaviors that are not forbidden (i.e., are allowed or warned).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def allow_or_warn_behaviors(self):
    &#34;&#34;&#34;Returns the set of all behaviors that are not forbidden (i.e., are allowed or warned).&#34;&#34;&#34;
    return self.allow_behaviors.union(self.warn_behaviors)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.any_type_at_start"><code class="name">var <span class="ident">any_type_at_start</span></code></dt>
<dd>
<div class="desc"><p>A JSON document may start with any type, not just arrays or objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.binary_numbers"><code class="name">var <span class="ident">binary_numbers</span></code></dt>
<dd>
<div class="desc"><p>Binary numbers, e.g., 0b1001</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.bom"><code class="name">var <span class="ident">bom</span></code></dt>
<dd>
<div class="desc"><p>A JSON document may start with a Unicode BOM (Byte Order Mark)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.comments"><code class="name">var <span class="ident">comments</span></code></dt>
<dd>
<div class="desc"><p>JavaScript comments, both /<em>&hellip;</em>/ and //&hellip; styles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.control_char_in_string"><code class="name">var <span class="ident">control_char_in_string</span></code></dt>
<dd>
<div class="desc"><p>Strings may contain raw control characters without \u-escaping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.duplicate_keys"><code class="name">var <span class="ident">duplicate_keys</span></code></dt>
<dd>
<div class="desc"><p>Objects may have repeated keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.encode_enum_as"><code class="name">var <span class="ident">encode_enum_as</span></code></dt>
<dd>
<div class="desc"><p>The strategy for encoding Python Enum values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def encode_enum_as(self):
    &#34;&#34;&#34;The strategy for encoding Python Enum values.&#34;&#34;&#34;
    return self._encode_enum_as</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.extended_unicode_escapes"><code class="name">var <span class="ident">extended_unicode_escapes</span></code></dt>
<dd>
<div class="desc"><p>Extended Unicode escape sequence \u{..} for non-BMP characters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_behaviors"><code class="name">var <span class="ident">forbid_behaviors</span></code></dt>
<dd>
<div class="desc"><p>Return the set of behaviors with the value forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getbehaviorsfor(self, value=v):
    return set(
        [
            name
            for name in self.all_behaviors
            if getattr(self, name) == value
        ]
    )</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.format_control_chars"><code class="name">var <span class="ident">format_control_chars</span></code></dt>
<dd>
<div class="desc"><p>Unicode "format control characters" may appear in the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.hex_numbers"><code class="name">var <span class="ident">hex_numbers</span></code></dt>
<dd>
<div class="desc"><p>Hexadecimal numbers, e.g., 0x1f</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.identifier_keys"><code class="name">var <span class="ident">identifier_keys</span></code></dt>
<dd>
<div class="desc"><p>JavaScript identifiers are converted to strings when used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.inf"><code class="name">var <span class="ident">inf</span></code></dt>
<dd>
<div class="desc"><p>The numeric value Infinity, either a float or a decimal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inf(self):
    &#34;&#34;&#34;The numeric value Infinity, either a float or a decimal.&#34;&#34;&#34;
    if self.float_type == NUMBER_DECIMAL:
        return self.decimal_context.create_decimal(&#34;Infinity&#34;)
    else:
        return inf</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.initial_decimal_point"><code class="name">var <span class="ident">initial_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Floating-point numbers may start with a decimal point (no units digit)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_all_allow"><code class="name">var <span class="ident">is_all_allow</span></code></dt>
<dd>
<div class="desc"><p>Determines if all the behaviors have the value allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">lambda self, v=v: is_all(self, v),</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_all_forbid"><code class="name">var <span class="ident">is_all_forbid</span></code></dt>
<dd>
<div class="desc"><p>Determines if all the behaviors have the value forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">lambda self, v=v: is_all(self, v),</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_all_warn"><code class="name">var <span class="ident">is_all_warn</span></code></dt>
<dd>
<div class="desc"><p>Determines if all the behaviors have the value warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">lambda self, v=v: is_all(self, v),</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_all_numeric_signs"><code class="name">var <span class="ident">is_allow_all_numeric_signs</span></code></dt>
<dd>
<div class="desc"><p>Allow Numbers may be prefixed by any '+' and '-', e.g., +4, -+-+77</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_any_type_at_start"><code class="name">var <span class="ident">is_allow_any_type_at_start</span></code></dt>
<dd>
<div class="desc"><p>Allow A JSON document may start with any type, not just arrays or objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_binary_numbers"><code class="name">var <span class="ident">is_allow_binary_numbers</span></code></dt>
<dd>
<div class="desc"><p>Allow Binary numbers, e.g., 0b1001</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_bom"><code class="name">var <span class="ident">is_allow_bom</span></code></dt>
<dd>
<div class="desc"><p>Allow A JSON document may start with a Unicode BOM (Byte Order Mark)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_comments"><code class="name">var <span class="ident">is_allow_comments</span></code></dt>
<dd>
<div class="desc"><p>Allow JavaScript comments, both /<em>&hellip;</em>/ and //&hellip; styles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_control_char_in_string"><code class="name">var <span class="ident">is_allow_control_char_in_string</span></code></dt>
<dd>
<div class="desc"><p>Allow Strings may contain raw control characters without \u-escaping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_duplicate_keys"><code class="name">var <span class="ident">is_allow_duplicate_keys</span></code></dt>
<dd>
<div class="desc"><p>Allow Objects may have repeated keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_extended_unicode_escapes"><code class="name">var <span class="ident">is_allow_extended_unicode_escapes</span></code></dt>
<dd>
<div class="desc"><p>Allow Extended Unicode escape sequence \u{..} for non-BMP characters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_format_control_chars"><code class="name">var <span class="ident">is_allow_format_control_chars</span></code></dt>
<dd>
<div class="desc"><p>Allow Unicode "format control characters" may appear in the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_hex_numbers"><code class="name">var <span class="ident">is_allow_hex_numbers</span></code></dt>
<dd>
<div class="desc"><p>Allow Hexadecimal numbers, e.g., 0x1f</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_identifier_keys"><code class="name">var <span class="ident">is_allow_identifier_keys</span></code></dt>
<dd>
<div class="desc"><p>Allow JavaScript identifiers are converted to strings when used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_initial_decimal_point"><code class="name">var <span class="ident">is_allow_initial_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Allow Floating-point numbers may start with a decimal point (no units digit)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_js_string_escapes"><code class="name">var <span class="ident">is_allow_js_string_escapes</span></code></dt>
<dd>
<div class="desc"><p>Allow All JavaScript character -escape sequences may be in strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_leading_zeros"><code class="name">var <span class="ident">is_allow_leading_zeros</span></code></dt>
<dd>
<div class="desc"><p>Allow Numbers may have leading zeros</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_non_numbers"><code class="name">var <span class="ident">is_allow_non_numbers</span></code></dt>
<dd>
<div class="desc"><p>Allow Non-numbers may be used, such as NaN or Infinity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_non_portable"><code class="name">var <span class="ident">is_allow_non_portable</span></code></dt>
<dd>
<div class="desc"><p>Allow Anything technically valid but likely to cause data portablibity issues</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_nonescape_characters"><code class="name">var <span class="ident">is_allow_nonescape_characters</span></code></dt>
<dd>
<div class="desc"><p>Allow Unknown character -escape sequences stand for that character (\Q -&gt; 'Q')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_nonstring_keys"><code class="name">var <span class="ident">is_allow_nonstring_keys</span></code></dt>
<dd>
<div class="desc"><p>Allow Value types other than strings (or identifiers) may be used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_octal_numbers"><code class="name">var <span class="ident">is_allow_octal_numbers</span></code></dt>
<dd>
<div class="desc"><p>Allow New-style octal numbers, e.g., 0o731
(see leading-zeros for legacy octals)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_omitted_array_elements"><code class="name">var <span class="ident">is_allow_omitted_array_elements</span></code></dt>
<dd>
<div class="desc"><p>Allow Arrays may have omitted/elided elements, e.g., [1,,3] == [1,undefined,3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_single_quoted_strings"><code class="name">var <span class="ident">is_allow_single_quoted_strings</span></code></dt>
<dd>
<div class="desc"><p>Allow Strings may be delimited with both double (") and single (') quotation marks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_trailing_comma"><code class="name">var <span class="ident">is_allow_trailing_comma</span></code></dt>
<dd>
<div class="desc"><p>Allow A final comma may end the list of array or object members</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_trailing_decimal_point"><code class="name">var <span class="ident">is_allow_trailing_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Allow Floating-point number may end with a decimal point and no following fractional digits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_undefined_values"><code class="name">var <span class="ident">is_allow_undefined_values</span></code></dt>
<dd>
<div class="desc"><p>Allow The JavaScript 'undefined' value may be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_unicode_whitespace"><code class="name">var <span class="ident">is_allow_unicode_whitespace</span></code></dt>
<dd>
<div class="desc"><p>Allow Treat any Unicode whitespace character as valid whitespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_allow_zero_byte"><code class="name">var <span class="ident">is_allow_zero_byte</span></code></dt>
<dd>
<div class="desc"><p>Allow Strings may contain U+0000, which may not be safe for C-based programs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_all_numeric_signs"><code class="name">var <span class="ident">is_forbid_all_numeric_signs</span></code></dt>
<dd>
<div class="desc"><p>Forbid Numbers may be prefixed by any '+' and '-', e.g., +4, -+-+77</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_any_type_at_start"><code class="name">var <span class="ident">is_forbid_any_type_at_start</span></code></dt>
<dd>
<div class="desc"><p>Forbid A JSON document may start with any type, not just arrays or objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_binary_numbers"><code class="name">var <span class="ident">is_forbid_binary_numbers</span></code></dt>
<dd>
<div class="desc"><p>Forbid Binary numbers, e.g., 0b1001</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_bom"><code class="name">var <span class="ident">is_forbid_bom</span></code></dt>
<dd>
<div class="desc"><p>Forbid A JSON document may start with a Unicode BOM (Byte Order Mark)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_comments"><code class="name">var <span class="ident">is_forbid_comments</span></code></dt>
<dd>
<div class="desc"><p>Forbid JavaScript comments, both /<em>&hellip;</em>/ and //&hellip; styles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_control_char_in_string"><code class="name">var <span class="ident">is_forbid_control_char_in_string</span></code></dt>
<dd>
<div class="desc"><p>Forbid Strings may contain raw control characters without \u-escaping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_duplicate_keys"><code class="name">var <span class="ident">is_forbid_duplicate_keys</span></code></dt>
<dd>
<div class="desc"><p>Forbid Objects may have repeated keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_extended_unicode_escapes"><code class="name">var <span class="ident">is_forbid_extended_unicode_escapes</span></code></dt>
<dd>
<div class="desc"><p>Forbid Extended Unicode escape sequence \u{..} for non-BMP characters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_format_control_chars"><code class="name">var <span class="ident">is_forbid_format_control_chars</span></code></dt>
<dd>
<div class="desc"><p>Forbid Unicode "format control characters" may appear in the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_hex_numbers"><code class="name">var <span class="ident">is_forbid_hex_numbers</span></code></dt>
<dd>
<div class="desc"><p>Forbid Hexadecimal numbers, e.g., 0x1f</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_identifier_keys"><code class="name">var <span class="ident">is_forbid_identifier_keys</span></code></dt>
<dd>
<div class="desc"><p>Forbid JavaScript identifiers are converted to strings when used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_initial_decimal_point"><code class="name">var <span class="ident">is_forbid_initial_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Forbid Floating-point numbers may start with a decimal point (no units digit)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_js_string_escapes"><code class="name">var <span class="ident">is_forbid_js_string_escapes</span></code></dt>
<dd>
<div class="desc"><p>Forbid All JavaScript character -escape sequences may be in strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_leading_zeros"><code class="name">var <span class="ident">is_forbid_leading_zeros</span></code></dt>
<dd>
<div class="desc"><p>Forbid Numbers may have leading zeros</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_non_numbers"><code class="name">var <span class="ident">is_forbid_non_numbers</span></code></dt>
<dd>
<div class="desc"><p>Forbid Non-numbers may be used, such as NaN or Infinity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_non_portable"><code class="name">var <span class="ident">is_forbid_non_portable</span></code></dt>
<dd>
<div class="desc"><p>Forbid Anything technically valid but likely to cause data portablibity issues</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_nonescape_characters"><code class="name">var <span class="ident">is_forbid_nonescape_characters</span></code></dt>
<dd>
<div class="desc"><p>Forbid Unknown character -escape sequences stand for that character (\Q -&gt; 'Q')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_nonstring_keys"><code class="name">var <span class="ident">is_forbid_nonstring_keys</span></code></dt>
<dd>
<div class="desc"><p>Forbid Value types other than strings (or identifiers) may be used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_octal_numbers"><code class="name">var <span class="ident">is_forbid_octal_numbers</span></code></dt>
<dd>
<div class="desc"><p>Forbid New-style octal numbers, e.g., 0o731
(see leading-zeros for legacy octals)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_omitted_array_elements"><code class="name">var <span class="ident">is_forbid_omitted_array_elements</span></code></dt>
<dd>
<div class="desc"><p>Forbid Arrays may have omitted/elided elements, e.g., [1,,3] == [1,undefined,3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_single_quoted_strings"><code class="name">var <span class="ident">is_forbid_single_quoted_strings</span></code></dt>
<dd>
<div class="desc"><p>Forbid Strings may be delimited with both double (") and single (') quotation marks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_trailing_comma"><code class="name">var <span class="ident">is_forbid_trailing_comma</span></code></dt>
<dd>
<div class="desc"><p>Forbid A final comma may end the list of array or object members</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_trailing_decimal_point"><code class="name">var <span class="ident">is_forbid_trailing_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Forbid Floating-point number may end with a decimal point and no following fractional digits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_undefined_values"><code class="name">var <span class="ident">is_forbid_undefined_values</span></code></dt>
<dd>
<div class="desc"><p>Forbid The JavaScript 'undefined' value may be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_unicode_whitespace"><code class="name">var <span class="ident">is_forbid_unicode_whitespace</span></code></dt>
<dd>
<div class="desc"><p>Forbid Treat any Unicode whitespace character as valid whitespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_forbid_zero_byte"><code class="name">var <span class="ident">is_forbid_zero_byte</span></code></dt>
<dd>
<div class="desc"><p>Forbid Strings may contain U+0000, which may not be safe for C-based programs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_all_numeric_signs"><code class="name">var <span class="ident">is_warn_all_numeric_signs</span></code></dt>
<dd>
<div class="desc"><p>Warn Numbers may be prefixed by any '+' and '-', e.g., +4, -+-+77</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_any_type_at_start"><code class="name">var <span class="ident">is_warn_any_type_at_start</span></code></dt>
<dd>
<div class="desc"><p>Warn A JSON document may start with any type, not just arrays or objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_binary_numbers"><code class="name">var <span class="ident">is_warn_binary_numbers</span></code></dt>
<dd>
<div class="desc"><p>Warn Binary numbers, e.g., 0b1001</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_bom"><code class="name">var <span class="ident">is_warn_bom</span></code></dt>
<dd>
<div class="desc"><p>Warn A JSON document may start with a Unicode BOM (Byte Order Mark)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_comments"><code class="name">var <span class="ident">is_warn_comments</span></code></dt>
<dd>
<div class="desc"><p>Warn JavaScript comments, both /<em>&hellip;</em>/ and //&hellip; styles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_control_char_in_string"><code class="name">var <span class="ident">is_warn_control_char_in_string</span></code></dt>
<dd>
<div class="desc"><p>Warn Strings may contain raw control characters without \u-escaping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_duplicate_keys"><code class="name">var <span class="ident">is_warn_duplicate_keys</span></code></dt>
<dd>
<div class="desc"><p>Warn Objects may have repeated keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_extended_unicode_escapes"><code class="name">var <span class="ident">is_warn_extended_unicode_escapes</span></code></dt>
<dd>
<div class="desc"><p>Warn Extended Unicode escape sequence \u{..} for non-BMP characters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_format_control_chars"><code class="name">var <span class="ident">is_warn_format_control_chars</span></code></dt>
<dd>
<div class="desc"><p>Warn Unicode "format control characters" may appear in the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_hex_numbers"><code class="name">var <span class="ident">is_warn_hex_numbers</span></code></dt>
<dd>
<div class="desc"><p>Warn Hexadecimal numbers, e.g., 0x1f</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_identifier_keys"><code class="name">var <span class="ident">is_warn_identifier_keys</span></code></dt>
<dd>
<div class="desc"><p>Warn JavaScript identifiers are converted to strings when used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_initial_decimal_point"><code class="name">var <span class="ident">is_warn_initial_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Warn Floating-point numbers may start with a decimal point (no units digit)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_js_string_escapes"><code class="name">var <span class="ident">is_warn_js_string_escapes</span></code></dt>
<dd>
<div class="desc"><p>Warn All JavaScript character -escape sequences may be in strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_leading_zeros"><code class="name">var <span class="ident">is_warn_leading_zeros</span></code></dt>
<dd>
<div class="desc"><p>Warn Numbers may have leading zeros</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_non_numbers"><code class="name">var <span class="ident">is_warn_non_numbers</span></code></dt>
<dd>
<div class="desc"><p>Warn Non-numbers may be used, such as NaN or Infinity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_non_portable"><code class="name">var <span class="ident">is_warn_non_portable</span></code></dt>
<dd>
<div class="desc"><p>Warn Anything technically valid but likely to cause data portablibity issues</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_nonescape_characters"><code class="name">var <span class="ident">is_warn_nonescape_characters</span></code></dt>
<dd>
<div class="desc"><p>Warn Unknown character -escape sequences stand for that character (\Q -&gt; 'Q')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_nonstring_keys"><code class="name">var <span class="ident">is_warn_nonstring_keys</span></code></dt>
<dd>
<div class="desc"><p>Warn Value types other than strings (or identifiers) may be used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_octal_numbers"><code class="name">var <span class="ident">is_warn_octal_numbers</span></code></dt>
<dd>
<div class="desc"><p>Warn New-style octal numbers, e.g., 0o731
(see leading-zeros for legacy octals)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_omitted_array_elements"><code class="name">var <span class="ident">is_warn_omitted_array_elements</span></code></dt>
<dd>
<div class="desc"><p>Warn Arrays may have omitted/elided elements, e.g., [1,,3] == [1,undefined,3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_single_quoted_strings"><code class="name">var <span class="ident">is_warn_single_quoted_strings</span></code></dt>
<dd>
<div class="desc"><p>Warn Strings may be delimited with both double (") and single (') quotation marks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_trailing_comma"><code class="name">var <span class="ident">is_warn_trailing_comma</span></code></dt>
<dd>
<div class="desc"><p>Warn A final comma may end the list of array or object members</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_trailing_decimal_point"><code class="name">var <span class="ident">is_warn_trailing_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Warn Floating-point number may end with a decimal point and no following fractional digits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_undefined_values"><code class="name">var <span class="ident">is_warn_undefined_values</span></code></dt>
<dd>
<div class="desc"><p>Warn The JavaScript 'undefined' value may be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_unicode_whitespace"><code class="name">var <span class="ident">is_warn_unicode_whitespace</span></code></dt>
<dd>
<div class="desc"><p>Warn Treat any Unicode whitespace character as valid whitespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_warn_zero_byte"><code class="name">var <span class="ident">is_warn_zero_byte</span></code></dt>
<dd>
<div class="desc"><p>Warn Strings may contain U+0000, which may not be safe for C-based programs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getx(self, name=name, forval=v):
    return self.get_behavior(name) == forval</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.js_string_escapes"><code class="name">var <span class="ident">js_string_escapes</span></code></dt>
<dd>
<div class="desc"><p>All JavaScript character -escape sequences may be in strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.leading_zero_radix"><code class="name">var <span class="ident">leading_zero_radix</span></code></dt>
<dd>
<div class="desc"><p>The radix to be used for numbers with leading zeros.
8 or 10</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def leading_zero_radix(self):
    &#34;&#34;&#34;The radix to be used for numbers with leading zeros.  8 or 10&#34;&#34;&#34;
    return self._leading_zero_radix</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.leading_zero_radix_as_word"><code class="name">var <span class="ident">leading_zero_radix_as_word</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def leading_zero_radix_as_word(self):
    return {8: &#34;octal&#34;, 10: &#34;decimal&#34;}[self._leading_zero_radix]</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.leading_zeros"><code class="name">var <span class="ident">leading_zeros</span></code></dt>
<dd>
<div class="desc"><p>Numbers may have leading zeros</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.nan"><code class="name">var <span class="ident">nan</span></code></dt>
<dd>
<div class="desc"><p>The numeric value NaN, either a float or a decimal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nan(self):
    &#34;&#34;&#34;The numeric value NaN, either a float or a decimal.&#34;&#34;&#34;
    if self.float_type == NUMBER_DECIMAL:
        return self.decimal_context.create_decimal(&#34;NaN&#34;)
    else:
        return nan</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.neginf"><code class="name">var <span class="ident">neginf</span></code></dt>
<dd>
<div class="desc"><p>The numeric value -Infinity, either a float or a decimal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def neginf(self):
    &#34;&#34;&#34;The numeric value -Infinity, either a float or a decimal.&#34;&#34;&#34;
    if self.float_type == NUMBER_DECIMAL:
        return self.decimal_context.create_decimal(&#34;-Infinity&#34;)
    else:
        return neginf</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.negzero_float"><code class="name">var <span class="ident">negzero_float</span></code></dt>
<dd>
<div class="desc"><p>The numeric value -0.0, either a float or a decimal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def negzero_float(self):
    &#34;&#34;&#34;The numeric value -0.0, either a float or a decimal.&#34;&#34;&#34;
    if self.float_type == NUMBER_DECIMAL:
        return self.decimal_context.create_decimal(&#34;-0.0&#34;)
    else:
        return -0.0</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.non_numbers"><code class="name">var <span class="ident">non_numbers</span></code></dt>
<dd>
<div class="desc"><p>Non-numbers may be used, such as NaN or Infinity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.non_portable"><code class="name">var <span class="ident">non_portable</span></code></dt>
<dd>
<div class="desc"><p>Anything technically valid but likely to cause data portablibity issues</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.nonescape_characters"><code class="name">var <span class="ident">nonescape_characters</span></code></dt>
<dd>
<div class="desc"><p>Unknown character -escape sequences stand for that character (\Q -&gt; 'Q')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.nonstring_keys"><code class="name">var <span class="ident">nonstring_keys</span></code></dt>
<dd>
<div class="desc"><p>Value types other than strings (or identifiers) may be used as object keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.octal_numbers"><code class="name">var <span class="ident">octal_numbers</span></code></dt>
<dd>
<div class="desc"><p>New-style octal numbers, e.g., 0o731
(see leading-zeros for legacy octals)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.omitted_array_elements"><code class="name">var <span class="ident">omitted_array_elements</span></code></dt>
<dd>
<div class="desc"><p>Arrays may have omitted/elided elements, e.g., [1,,3] == [1,undefined,3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.single_quoted_strings"><code class="name">var <span class="ident">single_quoted_strings</span></code></dt>
<dd>
<div class="desc"><p>Strings may be delimited with both double (") and single (') quotation marks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.sort_keys"><code class="name">var <span class="ident">sort_keys</span></code></dt>
<dd>
<div class="desc"><p>The method used to sort dictionary keys when encoding JSON</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sort_keys(self):
    &#34;&#34;&#34;The method used to sort dictionary keys when encoding JSON&#34;&#34;&#34;
    return self._sort_keys</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.strictness"><code class="name">var <span class="ident">strictness</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def strictness(self):
    return self._strictness</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.trailing_comma"><code class="name">var <span class="ident">trailing_comma</span></code></dt>
<dd>
<div class="desc"><p>A final comma may end the list of array or object members</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.trailing_decimal_point"><code class="name">var <span class="ident">trailing_decimal_point</span></code></dt>
<dd>
<div class="desc"><p>Floating-point number may end with a decimal point and no following fractional digits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.undefined_values"><code class="name">var <span class="ident">undefined_values</span></code></dt>
<dd>
<div class="desc"><p>The JavaScript 'undefined' value may be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.unicode_whitespace"><code class="name">var <span class="ident">unicode_whitespace</span></code></dt>
<dd>
<div class="desc"><p>Treat any Unicode whitespace character as valid whitespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Set of possible behavior values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">lambda self: set(self._behavior_values),</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_behaviors"><code class="name">var <span class="ident">warn_behaviors</span></code></dt>
<dd>
<div class="desc"><p>Return the set of behaviors with the value warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getbehaviorsfor(self, value=v):
    return set(
        [
            name
            for name in self.all_behaviors
            if getattr(self, name) == value
        ]
    )</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.zero_byte"><code class="name">var <span class="ident">zero_byte</span></code></dt>
<dd>
<div class="desc"><p>Strings may contain U+0000, which may not be safe for C-based programs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_for_behavior(self, name=name):
    return self.get_behavior(name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.zero_float"><code class="name">var <span class="ident">zero_float</span></code></dt>
<dd>
<div class="desc"><p>The numeric value 0.0, either a float or a decimal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zero_float(self):
    &#34;&#34;&#34;The numeric value 0.0, either a float or a decimal.&#34;&#34;&#34;
    if self.float_type == NUMBER_DECIMAL:
        return self.decimal_context.create_decimal(&#34;0.0&#34;)
    else:
        return 0.0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.json_options.allow_all_numeric_signs"><code class="name flex">
<span>def <span class="ident">allow_all_numeric_signs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior all_numeric_signs to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_any_type_at_start"><code class="name flex">
<span>def <span class="ident">allow_any_type_at_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior any_type_at_start to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_binary_numbers"><code class="name flex">
<span>def <span class="ident">allow_binary_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior binary_numbers to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_bom"><code class="name flex">
<span>def <span class="ident">allow_bom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior bom to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_comments"><code class="name flex">
<span>def <span class="ident">allow_comments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior comments to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_control_char_in_string"><code class="name flex">
<span>def <span class="ident">allow_control_char_in_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior control_char_in_string to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_duplicate_keys"><code class="name flex">
<span>def <span class="ident">allow_duplicate_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior duplicate_keys to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_extended_unicode_escapes"><code class="name flex">
<span>def <span class="ident">allow_extended_unicode_escapes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior extended_unicode_escapes to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_format_control_chars"><code class="name flex">
<span>def <span class="ident">allow_format_control_chars</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior format_control_chars to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_hex_numbers"><code class="name flex">
<span>def <span class="ident">allow_hex_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior hex_numbers to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_identifier_keys"><code class="name flex">
<span>def <span class="ident">allow_identifier_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior identifier_keys to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_initial_decimal_point"><code class="name flex">
<span>def <span class="ident">allow_initial_decimal_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior initial_decimal_point to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_js_string_escapes"><code class="name flex">
<span>def <span class="ident">allow_js_string_escapes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior js_string_escapes to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_leading_zeros"><code class="name flex">
<span>def <span class="ident">allow_leading_zeros</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior leading_zeros to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_non_numbers"><code class="name flex">
<span>def <span class="ident">allow_non_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior non_numbers to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_non_portable"><code class="name flex">
<span>def <span class="ident">allow_non_portable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior non_portable to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_nonescape_characters"><code class="name flex">
<span>def <span class="ident">allow_nonescape_characters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior nonescape_characters to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_nonstring_keys"><code class="name flex">
<span>def <span class="ident">allow_nonstring_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior nonstring_keys to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_octal_numbers"><code class="name flex">
<span>def <span class="ident">allow_octal_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior octal_numbers to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_omitted_array_elements"><code class="name flex">
<span>def <span class="ident">allow_omitted_array_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior omitted_array_elements to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_single_quoted_strings"><code class="name flex">
<span>def <span class="ident">allow_single_quoted_strings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior single_quoted_strings to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_trailing_comma"><code class="name flex">
<span>def <span class="ident">allow_trailing_comma</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior trailing_comma to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_trailing_decimal_point"><code class="name flex">
<span>def <span class="ident">allow_trailing_decimal_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior trailing_decimal_point to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_undefined_values"><code class="name flex">
<span>def <span class="ident">allow_undefined_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior undefined_values to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_unicode_whitespace"><code class="name flex">
<span>def <span class="ident">allow_unicode_whitespace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior unicode_whitespace to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.allow_zero_byte"><code class="name flex">
<span>def <span class="ident">allow_zero_byte</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior zero_byte to allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    other = self.__class__()
    other.copy_from(self)
    return other</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.copy_from"><code class="name flex">
<span>def <span class="ident">copy_from</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_from(self, other):
    if self is other:
        return  # Myself!

    self.strictness = other.strictness  # sets behaviors in bulk

    for name in self.all_behaviors:
        self.set_behavior(name, other.get_behavior(name))

    for name in self._plain_attrs:
        val = getattr(other, name)
        if isinstance(val, set):
            val = val.copy()
        elif decimal and isinstance(val, decimal.Decimal):
            val = decimal.Decimal(val)

        setattr(self, name, val)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.describe_behavior"><code class="name flex">
<span>def <span class="ident">describe_behavior</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns documentation about a given behavior.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_behavior(self, name):
    &#34;&#34;&#34;Returns documentation about a given behavior.&#34;&#34;&#34;
    for n, doc in self._behaviors:
        if n == name:
            return doc
    else:
        raise AttributeError(&#34;No such behavior&#34;, name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_all_numeric_signs"><code class="name flex">
<span>def <span class="ident">forbid_all_numeric_signs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior all_numeric_signs to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_any_type_at_start"><code class="name flex">
<span>def <span class="ident">forbid_any_type_at_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior any_type_at_start to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_binary_numbers"><code class="name flex">
<span>def <span class="ident">forbid_binary_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior binary_numbers to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_bom"><code class="name flex">
<span>def <span class="ident">forbid_bom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior bom to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_comments"><code class="name flex">
<span>def <span class="ident">forbid_comments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior comments to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_control_char_in_string"><code class="name flex">
<span>def <span class="ident">forbid_control_char_in_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior control_char_in_string to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_duplicate_keys"><code class="name flex">
<span>def <span class="ident">forbid_duplicate_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior duplicate_keys to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_extended_unicode_escapes"><code class="name flex">
<span>def <span class="ident">forbid_extended_unicode_escapes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior extended_unicode_escapes to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_format_control_chars"><code class="name flex">
<span>def <span class="ident">forbid_format_control_chars</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior format_control_chars to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_hex_numbers"><code class="name flex">
<span>def <span class="ident">forbid_hex_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior hex_numbers to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_identifier_keys"><code class="name flex">
<span>def <span class="ident">forbid_identifier_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior identifier_keys to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_initial_decimal_point"><code class="name flex">
<span>def <span class="ident">forbid_initial_decimal_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior initial_decimal_point to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_js_string_escapes"><code class="name flex">
<span>def <span class="ident">forbid_js_string_escapes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior js_string_escapes to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_leading_zeros"><code class="name flex">
<span>def <span class="ident">forbid_leading_zeros</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior leading_zeros to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_non_numbers"><code class="name flex">
<span>def <span class="ident">forbid_non_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior non_numbers to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_non_portable"><code class="name flex">
<span>def <span class="ident">forbid_non_portable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior non_portable to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_nonescape_characters"><code class="name flex">
<span>def <span class="ident">forbid_nonescape_characters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior nonescape_characters to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_nonstring_keys"><code class="name flex">
<span>def <span class="ident">forbid_nonstring_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior nonstring_keys to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_octal_numbers"><code class="name flex">
<span>def <span class="ident">forbid_octal_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior octal_numbers to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_omitted_array_elements"><code class="name flex">
<span>def <span class="ident">forbid_omitted_array_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior omitted_array_elements to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_single_quoted_strings"><code class="name flex">
<span>def <span class="ident">forbid_single_quoted_strings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior single_quoted_strings to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_trailing_comma"><code class="name flex">
<span>def <span class="ident">forbid_trailing_comma</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior trailing_comma to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_trailing_decimal_point"><code class="name flex">
<span>def <span class="ident">forbid_trailing_decimal_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior trailing_decimal_point to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_undefined_values"><code class="name flex">
<span>def <span class="ident">forbid_undefined_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior undefined_values to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_unicode_whitespace"><code class="name flex">
<span>def <span class="ident">forbid_unicode_whitespace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior unicode_whitespace to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.forbid_zero_byte"><code class="name flex">
<span>def <span class="ident">forbid_zero_byte</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior zero_byte to forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.get_behavior"><code class="name flex">
<span>def <span class="ident">get_behavior</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the value for a given behavior</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_behavior(self, name):
    &#34;&#34;&#34;Returns the value for a given behavior&#34;&#34;&#34;
    try:
        return getattr(self, &#34;_behavior_&#34; + name)
    except AttributeError:
        raise ValueError(&#34;Unknown behavior&#34;, name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.indentation_for_level"><code class="name flex">
<span>def <span class="ident">indentation_for_level</span></span>(<span>self, level=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a whitespace string used for indenting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indentation_for_level(self, level=0):
    &#34;&#34;&#34;Returns a whitespace string used for indenting.&#34;&#34;&#34;
    if self.indent_limit is not None and level &gt; self.indent_limit:
        n = self.indent_limit
    else:
        n = level
    n *= self.indent_amount
    if self.indent_tab_width:
        tw, sw = divmod(n, self.indent_tab_width)
        return &#34;\t&#34; * tw + &#34; &#34; * sw
    else:
        return &#34; &#34; * n</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.is_all"><code class="name flex">
<span>def <span class="ident">is_all</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if all the behaviors have the given value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_all(self, value):
    &#34;&#34;&#34;Determines if all the behaviors have the given value.&#34;&#34;&#34;
    if value not in self._behavior_values:
        raise ValueError(&#34;Unknown behavior&#34;, value)
    for name in self.all_behaviors:
        if getattr(self, &#34;_behavior_&#34; + name) != value:
            return False
    return True</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.make_decimal"><code class="name flex">
<span>def <span class="ident">make_decimal</span></span>(<span>self, s, sign='+')</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a string into a decimal or float value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_decimal(self, s, sign=&#34;+&#34;):
    &#34;&#34;&#34;Converts a string into a decimal or float value.&#34;&#34;&#34;
    if self.float_type == NUMBER_FLOAT:
        return self.make_float(s, sign)

    if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
        sign = s[0]
        s = s[1:]
    elif isinstance(sign, int):
        if sign &lt; 0:
            sign = &#34;-&#34;
        else:
            sign = &#34;+&#34;

    try:
        f = self.decimal_context.create_decimal(s)
    except decimal.InvalidOperation:
        f = self.decimal_context.create_decimal(&#34;NaN&#34;)
    except decimal.Overflow:
        if sign == &#34;-&#34;:
            f = self.decimal_context.create_decimal(&#34;-Infinity&#34;)
        else:
            f = self.decimal_context.create_decimal(&#34;Infinity&#34;)
    else:
        if sign == &#34;-&#34;:
            f = f.copy_negate()
    return f</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.make_float"><code class="name flex">
<span>def <span class="ident">make_float</span></span>(<span>self, s, sign='+')</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a string into a float or decimal value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_float(self, s, sign=&#34;+&#34;):
    &#34;&#34;&#34;Converts a string into a float or decimal value.&#34;&#34;&#34;
    if decimal and self.float_type == NUMBER_DECIMAL:
        return self.make_decimal(s, sign)

    if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
        sign = s[0]
        s = s[1:]
    elif isinstance(sign, int):
        if sign &lt; 0:
            sign = &#34;-&#34;
        else:
            sign = &#34;+&#34;

    try:
        f = float(s)
    except ValueError:
        f = nan
    else:
        if sign == &#34;-&#34;:
            f *= -1
    return f</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.make_int"><code class="name flex">
<span>def <span class="ident">make_int</span></span>(<span>self, s, sign=None, number_format='decimal')</span>
</code></dt>
<dd>
<div class="desc"><p>Makes an integer value according to the current options.</p>
<p>First argument should be a string representation of the number,
or an integer.</p>
<p>Returns a number value, which could be an int, float, or decimal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_int(self, s, sign=None, number_format=NUMBER_FORMAT_DECIMAL):
    &#34;&#34;&#34;Makes an integer value according to the current options.

    First argument should be a string representation of the number,
    or an integer.

    Returns a number value, which could be an int, float, or decimal.

    &#34;&#34;&#34;
    if isinstance(sign, int):
        if sign &lt; 0:
            sign = &#34;-&#34;
        else:
            sign = &#34;+&#34;
    if isinstance(s, str):
        if s.startswith(&#34;-&#34;) or s.startswith(&#34;+&#34;):
            sign = s[0]
            s = s[1:]

    if self.int_as_float:
        # Making a float/decimal
        if isinstance(s, int):
            if self.float_type == NUMBER_DECIMAL:
                n = self.decimal_context.create_decimal(s)
                if sign == &#34;-&#34;:
                    n = n.copy_negate()
            elif s == 0 and sign == &#34;-&#34;:
                n = self.negzero_float
            elif -999999999999999 &lt;= s &lt;= 999999999999999:
                n = float(s)
                if sign == &#34;-&#34;:
                    n *= -1
            else:
                n = float(s)
                if (n == inf or int(n) != s) and self.float_type != NUMBER_FLOAT:
                    n = self.decimal_context.create_decimal(s)
                    if sign == &#34;-&#34;:
                        n = n.copy_negate()
                elif sign == &#34;-&#34;:
                    n *= -1
        else:  # not already an int
            n = self.make_float(s, sign)
            n2 = self.make_float(s[:-1] + (&#34;9&#34; if s[-1] &lt;= &#34;5&#34; else &#34;0&#34;), sign)
            if (n == inf or n == n2) and self.float_type != NUMBER_FLOAT:
                n = self.make_decimal(s, sign)
    elif isinstance(s, int):
        # already an integer
        n = s
        if sign == &#34;-&#34;:
            if n == 0:
                n = self.negzero_float
            else:
                n *= -1
    else:
        # Making an actual integer
        try:
            n = int(s)
        except ValueError:
            n = self.nan
        else:
            if sign == &#34;-&#34;:
                if n == 0:
                    n = self.negzero_float
                else:
                    n *= -1
    if isinstance(n, int) and self.keep_format:
        n = json_int(n, number_format=number_format)
    return n</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.reset_to_defaults"><code class="name flex">
<span>def <span class="ident">reset_to_defaults</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_to_defaults(self):
    # Plain attrs (other than above behaviors) are simply copied
    # by value, either during initialization (via keyword
    # arguments) or via the copy() method.
    self._plain_attrs = [
        &#34;leading_zero_radix&#34;,
        &#34;encode_namedtuple_as_object&#34;,
        &#34;encode_enum_as&#34;,
        &#34;encode_compactly&#34;,
        &#34;escape_unicode&#34;,
        &#34;always_escape_chars&#34;,
        &#34;warn_string_length&#34;,
        &#34;warn_max_depth&#34;,
        &#34;int_as_float&#34;,
        &#34;decimal_context&#34;,
        &#34;float_type&#34;,
        &#34;keep_format&#34;,
        &#34;date_format&#34;,
        &#34;datetime_format&#34;,
        &#34;time_format&#34;,
        &#34;timedelta_format&#34;,
        &#34;sort_keys&#34;,
        &#34;indent_amount&#34;,
        &#34;indent_tab_width&#34;,
        &#34;indent_limit&#34;,
        &#34;max_items_per_line&#34;,
        &#34;py2str_encoding&#34;,
    ]

    self.strictness = STRICTNESS_WARN
    self._leading_zero_radix = 8  # via property: leading_zero_radix
    self._sort_keys = SORT_SMART  # via property: sort_keys

    self.int_as_float = False
    self.float_type = NUMBER_AUTO
    self.decimal_context = decimal.DefaultContext if decimal else None
    self.keep_format = False  # keep track of when numbers are hex, octal, etc.

    self.encode_namedtuple_as_object = True
    self._encode_enum_as = &#34;name&#34;  # via property
    self.encode_compactly = True
    self.escape_unicode = False
    self.always_escape_chars = (
        None  # None, or a set of Unicode characters to always escape
    )

    self.warn_string_length = 0xFFFD  # with 16-bit length prefix
    self.warn_max_depth = 64

    self.date_format = &#34;iso&#34;  # or strftime format
    self.datetime_format = &#34;iso&#34;  # or strftime format
    self.time_format = &#34;iso&#34;  # or strftime format
    self.timedelta_format = &#34;iso&#34;  # or &#39;hms&#39;

    self.sort_keys = SORT_ALPHA
    self.indent_amount = 2
    self.indent_tab_width = 0  # 0, or number of equivalent spaces
    self.indent_limit = None
    self.max_items_per_line = 1  # When encoding how many items per array/object
    # before breaking into multiple lines
    # For interpreting Python 2 &#39;str&#39; types:
    self.py2str_encoding = None</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.set_all"><code class="name flex">
<span>def <span class="ident">set_all</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes all behaviors to have the given value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_all(self, value):
    &#34;&#34;&#34;Changes all behaviors to have the given value.&#34;&#34;&#34;
    if value not in self._behavior_values:
        raise ValueError(&#34;Unknown behavior&#34;, value)
    for name in self.all_behaviors:
        setattr(self, &#34;_behavior_&#34; + name, value)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.set_all_allow"><code class="name flex">
<span>def <span class="ident">set_all_allow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all behaviors to value allow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setfn = lambda self, _value=v: set_all(self, _value)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.set_all_forbid"><code class="name flex">
<span>def <span class="ident">set_all_forbid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all behaviors to value forbid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setfn = lambda self, _value=v: set_all(self, _value)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.set_all_warn"><code class="name flex">
<span>def <span class="ident">set_all_warn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all behaviors to value warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">setfn = lambda self, _value=v: set_all(self, _value)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.set_behavior"><code class="name flex">
<span>def <span class="ident">set_behavior</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the value for a given behavior</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_behavior(self, name, value):
    &#34;&#34;&#34;Changes the value for a given behavior&#34;&#34;&#34;
    if value not in self._behavior_values:
        raise ValueError(&#34;Unknown value for behavior&#34;, value)
    varname = &#34;_behavior_&#34; + name
    if hasattr(self, varname):
        setattr(self, varname, value)
    else:
        raise ValueError(&#34;Unknown behavior&#34;, name)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.set_indent"><code class="name flex">
<span>def <span class="ident">set_indent</span></span>(<span>self, num_spaces, tab_width=0, limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the indentation properties when outputting JSON in non-compact mode.</p>
<p>'num_spaces' is the number of spaces to insert for each level
of indentation, which defaults to 2.</p>
<p>'tab_width', if not 0, is the number of spaces which is equivalent
to one tab character.
Tabs will be output where possible rather
than runs of spaces.</p>
<p>'limit', if not None, is the maximum indentation level after
which no further indentation will be output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_indent(self, num_spaces, tab_width=0, limit=None):
    &#34;&#34;&#34;Changes the indentation properties when outputting JSON in non-compact mode.

    &#39;num_spaces&#39; is the number of spaces to insert for each level
    of indentation, which defaults to 2.

    &#39;tab_width&#39;, if not 0, is the number of spaces which is equivalent
    to one tab character.  Tabs will be output where possible rather
    than runs of spaces.

    &#39;limit&#39;, if not None, is the maximum indentation level after
    which no further indentation will be output.

    &#34;&#34;&#34;
    n = int(num_spaces)
    if n &lt; 0:
        raise ValueError(&#34;indentation amount can not be negative&#34;, n)
    self.indent_amount = n
    self.indent_tab_width = tab_width
    self.indent_limit = limit</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.spaces_to_next_indent_level"><code class="name flex">
<span>def <span class="ident">spaces_to_next_indent_level</span></span>(<span>self, min_spaces=1, subtract=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spaces_to_next_indent_level(self, min_spaces=1, subtract=0):
    n = self.indent_amount - subtract
    if n &lt; 0:
        n = 0
    n = max(min_spaces, n)
    return &#34; &#34; * n</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.suppress_warnings"><code class="name flex">
<span>def <span class="ident">suppress_warnings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suppress_warnings(self):
    for name in self.warn_behaviors:
        self.set_behavior(name, &#34;allow&#34;)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_all_numeric_signs"><code class="name flex">
<span>def <span class="ident">warn_all_numeric_signs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior all_numeric_signs to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_any_type_at_start"><code class="name flex">
<span>def <span class="ident">warn_any_type_at_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior any_type_at_start to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_binary_numbers"><code class="name flex">
<span>def <span class="ident">warn_binary_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior binary_numbers to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_bom"><code class="name flex">
<span>def <span class="ident">warn_bom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior bom to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_comments"><code class="name flex">
<span>def <span class="ident">warn_comments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior comments to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_control_char_in_string"><code class="name flex">
<span>def <span class="ident">warn_control_char_in_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior control_char_in_string to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_duplicate_keys"><code class="name flex">
<span>def <span class="ident">warn_duplicate_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior duplicate_keys to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_extended_unicode_escapes"><code class="name flex">
<span>def <span class="ident">warn_extended_unicode_escapes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior extended_unicode_escapes to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_format_control_chars"><code class="name flex">
<span>def <span class="ident">warn_format_control_chars</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior format_control_chars to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_hex_numbers"><code class="name flex">
<span>def <span class="ident">warn_hex_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior hex_numbers to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_identifier_keys"><code class="name flex">
<span>def <span class="ident">warn_identifier_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior identifier_keys to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_initial_decimal_point"><code class="name flex">
<span>def <span class="ident">warn_initial_decimal_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior initial_decimal_point to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_js_string_escapes"><code class="name flex">
<span>def <span class="ident">warn_js_string_escapes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior js_string_escapes to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_leading_zeros"><code class="name flex">
<span>def <span class="ident">warn_leading_zeros</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior leading_zeros to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_non_numbers"><code class="name flex">
<span>def <span class="ident">warn_non_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior non_numbers to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_non_portable"><code class="name flex">
<span>def <span class="ident">warn_non_portable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior non_portable to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_nonescape_characters"><code class="name flex">
<span>def <span class="ident">warn_nonescape_characters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior nonescape_characters to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_nonstring_keys"><code class="name flex">
<span>def <span class="ident">warn_nonstring_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior nonstring_keys to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_octal_numbers"><code class="name flex">
<span>def <span class="ident">warn_octal_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior octal_numbers to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_omitted_array_elements"><code class="name flex">
<span>def <span class="ident">warn_omitted_array_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior omitted_array_elements to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_single_quoted_strings"><code class="name flex">
<span>def <span class="ident">warn_single_quoted_strings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior single_quoted_strings to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_trailing_comma"><code class="name flex">
<span>def <span class="ident">warn_trailing_comma</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior trailing_comma to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_trailing_decimal_point"><code class="name flex">
<span>def <span class="ident">warn_trailing_decimal_point</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior trailing_decimal_point to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_undefined_values"><code class="name flex">
<span>def <span class="ident">warn_undefined_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior undefined_values to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_unicode_whitespace"><code class="name flex">
<span>def <span class="ident">warn_unicode_whitespace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior unicode_whitespace to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
<dt id="demjson3.json_options.warn_zero_byte"><code class="name flex">
<span>def <span class="ident">warn_zero_byte</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set behavior zero_byte to warn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">fnset = lambda self, _name=name, _value=v: self.set_behavior(
    _name, _value
)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.jsonlint"><code class="flex name class">
<span>class <span class="ident">jsonlint</span></span>
<span>(</span><span>program_name='jsonlint', stdin=None, stdout=None, stderr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class contains most of the logic for the "jsonlint" command.</p>
<p>You generally create an instance of this class, to defined the
program's environment, and then call the main() method.
A simple
wrapper to turn this into a script might be:</p>
<pre><code>import sys, demjson
if __name__ == '__main__':
    lint = demjson.jsonlint( sys.argv[0] )
    return lint.main( sys.argv[1:] )
</code></pre>
<p>Create an instance of a "jsonlint" program.</p>
<p>You can optionally pass options to define the program's environment:</p>
<ul>
<li>program_name
- the name of the program, usually sys.argv[0]</li>
<li>stdin
- the file object to use for input, default sys.stdin</li>
<li>stdout
- the file object to use for outut, default sys.stdout</li>
<li>stderr
- the file object to use for error output, default sys.stderr</li>
</ul>
<p>After creating an instance, you typically call the main() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class jsonlint(object):
    &#34;&#34;&#34;This class contains most of the logic for the &#34;jsonlint&#34; command.

    You generally create an instance of this class, to defined the
    program&#39;s environment, and then call the main() method.  A simple
    wrapper to turn this into a script might be:

        import sys, demjson
        if __name__ == &#39;__main__&#39;:
            lint = demjson.jsonlint( sys.argv[0] )
            return lint.main( sys.argv[1:] )

    &#34;&#34;&#34;

    _jsonlint_usage = r&#34;&#34;&#34;Usage: %(program_name)s [&lt;options&gt; ...] [--] inputfile.json ...

With no input filename, or &#34;-&#34;, it will read from standard input.

The return status will be 0 if the file is conforming JSON (per the
RFC 7159 specification), or non-zero otherwise.

GENERAL OPTIONS:

 -v | --verbose    Show details of lint checking
 -q | --quiet      Don&#39;t show any output (except for reformatting)

STRICTNESS OPTIONS (WARNINGS AND ERRORS):

 -W | --tolerant   Be tolerant, but warn about non-conformance (default)
 -s | --strict     Be strict in what is considered conforming JSON
 -S | --nonstrict  Be tolerant in what is considered conforming JSON

 --allow=...      -\
 --warn=...         |-- These options let you pick specific behaviors.
 --forbid=...     -/      Use --help-behaviors for more

STATISTICS OPTIONS:

 --stats       Show statistics about JSON document

REFORMATTING OPTIONS:

 -f | --format     Reformat the JSON text (if conforming) to stdout
 -F | --format-compactly
        Reformat the JSON simlar to -f, but do so compactly by
        removing all unnecessary whitespace

 -o filename | --output filename
        The filename to which reformatted JSON is to be written.
        Without this option the standard output is used.

 --[no-]keep-format   Try to preserve numeric radix, e.g., hex, octal, etc.
 --html-safe          Escape characters that are not safe to embed in HTML/XML.

 --sort &lt;kind&gt;     How to sort object/dictionary keys, &lt;kind&gt; is one of:
%(sort_options_help)s

 --indent tabs | &lt;nnn&gt;   Number of spaces to use per indentation level,
                         or use tab characters if &#34;tabs&#34; given.

UNICODE OPTIONS:

 -e codec | --encoding=codec     Set both input and output encodings
 --input-encoding=codec          Set the input encoding
 --output-encoding=codec         Set the output encoding

    These options set the character encoding codec (e.g., &#34;ascii&#34;,
    &#34;utf-8&#34;, &#34;utf-16&#34;).  The -e will set both the input and output
    encodings to the same thing.  The output encoding is used when
    reformatting with the -f or -F options.

    Unless set, the input encoding is guessed and the output
    encoding will be &#34;utf-8&#34;.

OTHER OPTIONS:

 --recursion-limit=nnn     Set the Python recursion limit to number
 --leading-zero-radix=8|10 The radix to use for numbers with leading
                           zeros. 8=octal, 10=decimal.

REFORMATTING / PRETTY-PRINTING:

    When reformatting JSON with -f or -F, output is only produced if
    the input passed validation.  By default the reformatted JSON will
    be written to standard output, unless the -o option was given.

    The default output codec is UTF-8, unless an encoding option is
    provided.  Any Unicode characters will be output as literal
    characters if the encoding permits, otherwise they will be
    \u-escaped.  You can use &#34;--output-encoding ascii&#34; to force all
    Unicode characters to be escaped.

MORE INFORMATION:

    Use &#39;%(program_name)s --version [-v]&#39; to see versioning information.
    Use &#39;%(program_name)s --copyright&#39; to see author and copyright details.
    Use &#39;%(program_name)s [-W|-s|-S] --help-behaviors&#39; for help on specific checks.

    %(program_name)s is distributed as part of the &#34;demjson&#34; Python module.
    See %(homepage)s
&#34;&#34;&#34;
    SUCCESS_FAIL = &#34;E&#34;
    SUCCESS_WARNING = &#34;W&#34;
    SUCCESS_OK = &#34;OK&#34;

    def __init__(self, program_name=&#34;jsonlint&#34;, stdin=None, stdout=None, stderr=None):
        &#34;&#34;&#34;Create an instance of a &#34;jsonlint&#34; program.

        You can optionally pass options to define the program&#39;s environment:

          * program_name  - the name of the program, usually sys.argv[0]
          * stdin   - the file object to use for input, default sys.stdin
          * stdout  - the file object to use for outut, default sys.stdout
          * stderr  - the file object to use for error output, default sys.stderr

        After creating an instance, you typically call the main() method.

        &#34;&#34;&#34;
        import os, sys

        self.program_path = program_name
        self.program_name = os.path.basename(program_name)
        if stdin:
            self.stdin = stdin
        else:
            self.stdin = sys.stdin

        if stdout:
            self.stdout = stdout
        else:
            self.stdout = sys.stdout

        if stderr:
            self.stderr = stderr
        else:
            self.stderr = sys.stderr

    @property
    def usage(self):
        &#34;&#34;&#34;A multi-line string containing the program usage instructions.&#34;&#34;&#34;
        sorthelp = &#34;\n&#34;.join(
            [
                &#34;          %12s - %s&#34; % (sm, sd)
                for sm, sd in sorted(sorting_methods.items())
                if sm != SORT_NONE
            ]
        )
        return self._jsonlint_usage % {
            &#34;program_name&#34;: self.program_name,
            &#34;homepage&#34;: __homepage__,
            &#34;sort_options_help&#34;: sorthelp,
        }

    def _lintcheck_data(
        self,
        jsondata,
        verbose_fp=None,
        reformat=False,
        show_stats=False,
        input_encoding=None,
        output_encoding=None,
        escape_unicode=True,
        pfx=&#34;&#34;,
        jsonopts=None,
    ):
        global decode, encode
        success = self.SUCCESS_FAIL
        reformatted = None
        if show_stats:
            stats_fp = verbose_fp
        else:
            stats_fp = None
        try:
            results = decode(
                jsondata,
                encoding=input_encoding,
                return_errors=True,
                return_stats=True,
                write_errors=verbose_fp,
                write_stats=stats_fp,
                filename_for_errors=pfx,
                json_options=jsonopts,
            )
        except JSONError as err:
            success = self.SUCCESS_FAIL
            if verbose_fp:
                verbose_fp.write(&#34;%s%s\n&#34; % (pfx, err.pretty_description()))
        except Exception as err:
            success = self.SUCCESS_FAIL
            if verbose_fp:
                verbose_fp.write(&#34;%s%s\n&#34; % (pfx, str(err)))
        else:
            errors = [
                err for err in results.errors if err.severity in (&#34;fatal&#34;, &#34;error&#34;)
            ]
            warnings = [err for err in results.errors if err.severity in (&#34;warning&#34;,)]
            if errors:
                success = self.SUCCESS_FAIL
            elif warnings:
                success = self.SUCCESS_WARNING
            else:
                success = self.SUCCESS_OK

            if reformat:
                encopts = jsonopts.copy()
                encopts.strictness = STRICTNESS_TOLERANT
                if reformat == &#34;compactly&#34;:
                    encopts.encode_compactly = True
                else:
                    encopts.encode_compactly = False

                reformatted = encode(
                    results.object, encoding=output_encoding, json_options=encopts
                )

        return (success, reformatted)

    def _lintcheck(
        self,
        filename,
        output_filename,
        verbose=False,
        reformat=False,
        show_stats=False,
        input_encoding=None,
        output_encoding=None,
        escape_unicode=True,
        jsonopts=None,
    ):
        import sys

        verbose_fp = None

        if not filename or filename == &#34;-&#34;:
            pfx = &#34;&lt;stdin&gt;: &#34;
            jsondata = self.stdin.read()
            if verbose:
                verbose_fp = self.stderr
        else:
            pfx = &#34;%s: &#34; % filename
            try:
                fp = open(filename, &#34;rb&#34;)
                jsondata = fp.read()
                fp.close()
            except IOError as err:
                self.stderr.write(&#34;%s: %s\n&#34; % (pfx, str(err)))
                return self.SUCCESS_FAIL
            if verbose:
                verbose_fp = self.stdout

        success, reformatted = self._lintcheck_data(
            jsondata,
            verbose_fp=verbose_fp,
            reformat=reformat,
            show_stats=show_stats,
            input_encoding=input_encoding,
            output_encoding=output_encoding,
            pfx=pfx,
            jsonopts=jsonopts,
        )

        if success != self.SUCCESS_FAIL and reformat:
            if output_filename:
                try:
                    fp = open(output_filename, &#34;wb&#34;)
                    fp.write(reformatted)
                except IOError as err:
                    self.stderr.write(&#34;%s: %s\n&#34; % (pfx, str(err)))
                    success = False
            else:
                if hasattr(
                    sys.stdout, &#34;buffer&#34;
                ):  # To write binary data rather than strings
                    self.stdout.buffer.write(reformatted)
                else:
                    self.stdout.write(reformatted)
        elif success == self.SUCCESS_OK and verbose_fp:
            verbose_fp.write(&#34;%sok\n&#34; % pfx)
        elif success == self.SUCCESS_WARNING and verbose_fp:
            verbose_fp.write(&#34;%sok, with warnings\n&#34; % pfx)
        elif verbose_fp:
            verbose_fp.write(&#34;%shas errors\n&#34; % pfx)

        return success

    def main(self, argv):
        &#34;&#34;&#34;The main routine for program &#34;jsonlint&#34;.

        Should be called with sys.argv[1:] as its sole argument.

        Note sys.argv[0] which normally contains the program name
        should not be passed to main(); instead this class itself
        is initialized with sys.argv[0].

        Use &#34;--help&#34; for usage syntax, or consult the &#39;usage&#39; member.

        &#34;&#34;&#34;
        import sys, os, getopt, unicodedata

        recursion_limit = None
        success = True
        verbose = &#34;auto&#34;  # one of &#39;auto&#39;, True, or False
        reformat = False
        show_stats = False
        output_filename = None
        input_encoding = None
        output_encoding = &#34;utf-8&#34;

        kwoptions = {  # Will be used to initialize json_options
            &#34;sort_keys&#34;: SORT_SMART,
            &#34;strict&#34;: STRICTNESS_WARN,
            &#34;keep_format&#34;: True,
            &#34;decimal_context&#34;: 100,
        }

        try:
            opts, args = getopt.getopt(
                argv,
                &#34;vqfFe:o:sSW&#34;,
                [
                    &#34;verbose&#34;,
                    &#34;quiet&#34;,
                    &#34;format&#34;,
                    &#34;format-compactly&#34;,
                    &#34;stats&#34;,
                    &#34;output&#34;,
                    &#34;strict&#34;,
                    &#34;nonstrict&#34;,
                    &#34;warn&#34;,
                    &#34;html-safe&#34;,
                    &#34;xml-safe&#34;,
                    &#34;encoding=&#34;,
                    &#34;input-encoding=&#34;,
                    &#34;output-encoding=&#34;,
                    &#34;sort=&#34;,
                    &#34;recursion-limit=&#34;,
                    &#34;leading-zero-radix=&#34;,
                    &#34;keep-format&#34;,
                    &#34;no-keep-format&#34;,
                    &#34;indent=&#34;,
                    &#34;indent-amount=&#34;,
                    &#34;indent-limit=&#34;,
                    &#34;indent-tab-width=&#34;,
                    &#34;max-items-per-line=&#34;,
                    &#34;allow=&#34;,
                    &#34;warn=&#34;,
                    &#34;forbid=&#34;,
                    &#34;deny=&#34;,
                    &#34;help&#34;,
                    &#34;help-behaviors&#34;,
                    &#34;version&#34;,
                    &#34;copyright&#34;,
                ],
            )
        except getopt.GetoptError as err:
            self.stderr.write(
                &#39;Error: %s.  Use &#34;%s --help&#34; for usage information.\n&#39;
                % (err.msg, self.program_name)
            )
            return 1

        # Set verbose before looking at any other options
        for opt, val in opts:
            if opt in (&#34;-v&#34;, &#34;--verbose&#34;):
                verbose = True

        # Process all options
        for opt, val in opts:
            if opt in (&#34;-h&#34;, &#34;--help&#34;):
                self.stdout.write(self.usage)
                return 0
            elif opt == &#34;--help-behaviors&#34;:
                self.stdout.write(
                    &#34;&#34;&#34;
BEHAVIOR OPTIONS:

These set of options let you control which checks are to be performed.
They may be turned on or off by listing them as arguments to one of
the options --allow, --warn, or --forbid ; for example:

    %(program_name)s --allow comments,hex-numbers --forbid duplicate-keys

&#34;&#34;&#34;
                    % {&#34;program_name&#34;: self.program_name}
                )
                self.stdout.write(
                    &#34;The default shown is for %s mode\n\n&#34; % kwoptions[&#34;strict&#34;]
                )
                self.stdout.write(
                    &#34;%-7s %-25s %s\n&#34; % (&#34;Default&#34;, &#34;Behavior_name&#34;, &#34;Description&#34;)
                )
                self.stdout.write(&#34;-&#34; * 7 + &#34; &#34; + &#34;-&#34; * 25 + &#34; &#34; + &#34;-&#34; * 50 + &#34;\n&#34;)
                j = json_options(**kwoptions)
                for behavior in sorted(j.all_behaviors):
                    v = j.get_behavior(behavior)
                    desc = j.describe_behavior(behavior)
                    self.stdout.write(
                        &#34;%-7s %-25s %s\n&#34;
                        % (v.lower(), behavior.replace(&#34;_&#34;, &#34;-&#34;), desc)
                    )
                return 0
            elif opt == &#34;--version&#34;:
                self.stdout.write(
                    &#34;%s (%s) version %s (%s)\n&#34;
                    % (self.program_name, __name__, __version__, __date__)
                )
                if verbose == True:
                    self.stdout.write(&#34;demjson from %r\n&#34; % (__file__,))
                if verbose == True:
                    self.stdout.write(
                        &#34;Python version: %s\n&#34; % (sys.version.replace(&#34;\n&#34;, &#34; &#34;),)
                    )
                    self.stdout.write(&#34;This python implementation supports:\n&#34;)
                    self.stdout.write(&#34;  * Max unicode: U+%X\n&#34; % (sys.maxunicode,))
                    self.stdout.write(
                        &#34;  * Unicode version: %s\n&#34; % (unicodedata.unidata_version,)
                    )
                    self.stdout.write(
                        &#34;  * Floating-point significant digits: %d\n&#34;
                        % (float_sigdigits,)
                    )
                    self.stdout.write(
                        &#34;  * Floating-point max 10^exponent: %d\n&#34; % (float_maxexp,)
                    )
                    if str(0.0) == str(-0.0):
                        szero = &#34;No&#34;
                    else:
                        szero = &#34;Yes&#34;
                    self.stdout.write(
                        &#34;  * Floating-point has signed-zeros: %s\n&#34; % (szero,)
                    )
                    if decimal:
                        has_dec = &#34;Yes&#34;
                    else:
                        has_dec = &#34;No&#34;
                    self.stdout.write(
                        &#34;  * Decimal (bigfloat) support: %s\n&#34; % (has_dec,)
                    )
                return 0
            elif opt == &#34;--copyright&#34;:
                self.stdout.write(
                    &#39;%s is distributed as part of the &#34;demjson&#34; python package.\n&#39;
                    % (self.program_name,)
                )
                self.stdout.write(&#34;See %s\n\n\n&#34; % (__homepage__,))
                self.stdout.write(__credits__)
                return 0
            elif opt in (&#34;-v&#34;, &#34;--verbose&#34;):
                verbose = True
            elif opt in (&#34;-q&#34;, &#34;--quiet&#34;):
                verbose = False
            elif opt in (&#34;-s&#34;, &#34;--strict&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_STRICT
                kwoptions[&#34;keep_format&#34;] = False
            elif opt in (&#34;-S&#34;, &#34;--nonstrict&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_TOLERANT
            elif opt in (&#34;-W&#34;, &#34;--tolerant&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_WARN
            elif opt in (&#34;-f&#34;, &#34;--format&#34;):
                reformat = True
                kwoptions[&#34;encode_compactly&#34;] = False
            elif opt in (&#34;-F&#34;, &#34;--format-compactly&#34;):
                kwoptions[&#34;encode_compactly&#34;] = True
                reformat = &#34;compactly&#34;
            elif opt in (&#34;--stats&#34;,):
                show_stats = True
            elif opt in (&#34;-o&#34;, &#34;--output&#34;):
                output_filename = val
            elif opt in (&#34;-e&#34;, &#34;--encoding&#34;):
                input_encoding = val
                output_encoding = val
                escape_unicode = False
            elif opt in (&#34;--output-encoding&#34;):
                output_encoding = val
                escape_unicode = False
            elif opt in (&#34;--input-encoding&#34;):
                input_encoding = val
            elif opt in (&#34;--html-safe&#34;, &#34;--xml-safe&#34;):
                kwoptions[&#34;html_safe&#34;] = True
            elif opt in (&#34;--allow&#34;, &#34;--warn&#34;, &#34;--forbid&#34;):
                action = opt[2:]
                if action in kwoptions:
                    kwoptions[action] += &#34;,&#34; + val
                else:
                    kwoptions[action] = val
            elif opt in (&#34;--keep-format&#34;,):
                kwoptions[&#34;keep_format&#34;] = True
            elif opt in (&#34;--no-keep-format&#34;,):
                kwoptions[&#34;keep_format&#34;] = False
            elif opt == &#34;--leading-zero-radix&#34;:
                kwoptions[&#34;leading_zero_radix&#34;] = val
            elif opt in (&#34;--indent&#34;, &#34;--indent-amount&#34;):
                if val in (&#34;tab&#34;, &#34;tabs&#34;):
                    kwoptions[&#34;indent_amount&#34;] = 8
                    kwoptions[&#34;indent_tab_width&#34;] = 8
                else:
                    try:
                        kwoptions[&#34;indent_amount&#34;] = int(val)
                    except ValueError:
                        self.stderr.write(&#34;Indentation amount must be a number\n&#34;)
                        return 1
            elif opt == &#34;indent-tab-width&#34;:
                try:
                    kwoptions[&#34;indent_tab_width&#34;] = int(val)
                except ValueError:
                    self.stderr.write(&#34;Indentation tab width must be a number\n&#34;)
                    return 1
            elif opt == &#34;--max-items-per-line&#34;:
                try:
                    kwoptions[&#34;max_items_per_line&#34;] = int(val)
                except ValueError:
                    self.stderr.write(&#34;Max items per line must be a number\n&#34;)
                    return 1
            elif opt == &#34;--sort&#34;:
                val = val.lower()
                if val == &#34;alpha&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_ALPHA
                elif val == &#34;alpha_ci&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_ALPHA_CI
                elif val == &#34;preserve&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_PRESERVE
                else:
                    kwoptions[&#34;sort_keys&#34;] = SORT_SMART
            elif opt == &#34;--recursion-limit&#34;:
                try:
                    recursion_limit = int(val)
                except ValueError:
                    self.stderr.write(&#34;Recursion limit must be a number: %r\n&#34; % val)
                    return 1
                else:
                    max_limit = 100000
                    old_limit = sys.getrecursionlimit()
                    if recursion_limit &gt; max_limit:
                        self.stderr.write(
                            &#34;Recursion limit must be a number between %d and %d\n&#34;
                            % (old_limit, max_limit)
                        )
                        return 1
                    elif recursion_limit &gt; old_limit:
                        sys.setrecursionlimit(recursion_limit)
            else:
                self.stderr.write(&#34;Unknown option %r\n&#34; % opt)
                return 1

        # Make the JSON options
        kwoptions[&#34;decimal_context&#34;] = 100
        jsonopts = json_options(**kwoptions)

        # Now decode each file...
        if not args:
            args = [None]

        for fn in args:
            try:
                rc = self._lintcheck(
                    fn,
                    output_filename=output_filename,
                    verbose=verbose,
                    reformat=reformat,
                    show_stats=show_stats,
                    input_encoding=input_encoding,
                    output_encoding=output_encoding,
                    jsonopts=jsonopts,
                )
                if rc != self.SUCCESS_OK:
                    # Warnings or errors should result in failure.  If
                    # checking multiple files, do not change a
                    # previous error back to ok.
                    success = False
            except KeyboardInterrupt as err:
                sys.stderr.write(&#34;\njsonlint interrupted!\n&#34;)
                sys.exit(1)

        if not success:
            return 1
        return 0</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="demjson3.jsonlint.SUCCESS_FAIL"><code class="name">var <span class="ident">SUCCESS_FAIL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.jsonlint.SUCCESS_OK"><code class="name">var <span class="ident">SUCCESS_OK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.jsonlint.SUCCESS_WARNING"><code class="name">var <span class="ident">SUCCESS_WARNING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.jsonlint.usage"><code class="name">var <span class="ident">usage</span></code></dt>
<dd>
<div class="desc"><p>A multi-line string containing the program usage instructions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def usage(self):
    &#34;&#34;&#34;A multi-line string containing the program usage instructions.&#34;&#34;&#34;
    sorthelp = &#34;\n&#34;.join(
        [
            &#34;          %12s - %s&#34; % (sm, sd)
            for sm, sd in sorted(sorting_methods.items())
            if sm != SORT_NONE
        ]
    )
    return self._jsonlint_usage % {
        &#34;program_name&#34;: self.program_name,
        &#34;homepage&#34;: __homepage__,
        &#34;sort_options_help&#34;: sorthelp,
    }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.jsonlint.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, argv)</span>
</code></dt>
<dd>
<div class="desc"><p>The main routine for program "jsonlint".</p>
<p>Should be called with sys.argv[1:] as its sole argument.</p>
<p>Note sys.argv[0] which normally contains the program name
should not be passed to main(); instead this class itself
is initialized with sys.argv[0].</p>
<p>Use "&ndash;help" for usage syntax, or consult the 'usage' member.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def main(self, argv):
        &#34;&#34;&#34;The main routine for program &#34;jsonlint&#34;.

        Should be called with sys.argv[1:] as its sole argument.

        Note sys.argv[0] which normally contains the program name
        should not be passed to main(); instead this class itself
        is initialized with sys.argv[0].

        Use &#34;--help&#34; for usage syntax, or consult the &#39;usage&#39; member.

        &#34;&#34;&#34;
        import sys, os, getopt, unicodedata

        recursion_limit = None
        success = True
        verbose = &#34;auto&#34;  # one of &#39;auto&#39;, True, or False
        reformat = False
        show_stats = False
        output_filename = None
        input_encoding = None
        output_encoding = &#34;utf-8&#34;

        kwoptions = {  # Will be used to initialize json_options
            &#34;sort_keys&#34;: SORT_SMART,
            &#34;strict&#34;: STRICTNESS_WARN,
            &#34;keep_format&#34;: True,
            &#34;decimal_context&#34;: 100,
        }

        try:
            opts, args = getopt.getopt(
                argv,
                &#34;vqfFe:o:sSW&#34;,
                [
                    &#34;verbose&#34;,
                    &#34;quiet&#34;,
                    &#34;format&#34;,
                    &#34;format-compactly&#34;,
                    &#34;stats&#34;,
                    &#34;output&#34;,
                    &#34;strict&#34;,
                    &#34;nonstrict&#34;,
                    &#34;warn&#34;,
                    &#34;html-safe&#34;,
                    &#34;xml-safe&#34;,
                    &#34;encoding=&#34;,
                    &#34;input-encoding=&#34;,
                    &#34;output-encoding=&#34;,
                    &#34;sort=&#34;,
                    &#34;recursion-limit=&#34;,
                    &#34;leading-zero-radix=&#34;,
                    &#34;keep-format&#34;,
                    &#34;no-keep-format&#34;,
                    &#34;indent=&#34;,
                    &#34;indent-amount=&#34;,
                    &#34;indent-limit=&#34;,
                    &#34;indent-tab-width=&#34;,
                    &#34;max-items-per-line=&#34;,
                    &#34;allow=&#34;,
                    &#34;warn=&#34;,
                    &#34;forbid=&#34;,
                    &#34;deny=&#34;,
                    &#34;help&#34;,
                    &#34;help-behaviors&#34;,
                    &#34;version&#34;,
                    &#34;copyright&#34;,
                ],
            )
        except getopt.GetoptError as err:
            self.stderr.write(
                &#39;Error: %s.  Use &#34;%s --help&#34; for usage information.\n&#39;
                % (err.msg, self.program_name)
            )
            return 1

        # Set verbose before looking at any other options
        for opt, val in opts:
            if opt in (&#34;-v&#34;, &#34;--verbose&#34;):
                verbose = True

        # Process all options
        for opt, val in opts:
            if opt in (&#34;-h&#34;, &#34;--help&#34;):
                self.stdout.write(self.usage)
                return 0
            elif opt == &#34;--help-behaviors&#34;:
                self.stdout.write(
                    &#34;&#34;&#34;
BEHAVIOR OPTIONS:

These set of options let you control which checks are to be performed.
They may be turned on or off by listing them as arguments to one of
the options --allow, --warn, or --forbid ; for example:

    %(program_name)s --allow comments,hex-numbers --forbid duplicate-keys

&#34;&#34;&#34;
                    % {&#34;program_name&#34;: self.program_name}
                )
                self.stdout.write(
                    &#34;The default shown is for %s mode\n\n&#34; % kwoptions[&#34;strict&#34;]
                )
                self.stdout.write(
                    &#34;%-7s %-25s %s\n&#34; % (&#34;Default&#34;, &#34;Behavior_name&#34;, &#34;Description&#34;)
                )
                self.stdout.write(&#34;-&#34; * 7 + &#34; &#34; + &#34;-&#34; * 25 + &#34; &#34; + &#34;-&#34; * 50 + &#34;\n&#34;)
                j = json_options(**kwoptions)
                for behavior in sorted(j.all_behaviors):
                    v = j.get_behavior(behavior)
                    desc = j.describe_behavior(behavior)
                    self.stdout.write(
                        &#34;%-7s %-25s %s\n&#34;
                        % (v.lower(), behavior.replace(&#34;_&#34;, &#34;-&#34;), desc)
                    )
                return 0
            elif opt == &#34;--version&#34;:
                self.stdout.write(
                    &#34;%s (%s) version %s (%s)\n&#34;
                    % (self.program_name, __name__, __version__, __date__)
                )
                if verbose == True:
                    self.stdout.write(&#34;demjson from %r\n&#34; % (__file__,))
                if verbose == True:
                    self.stdout.write(
                        &#34;Python version: %s\n&#34; % (sys.version.replace(&#34;\n&#34;, &#34; &#34;),)
                    )
                    self.stdout.write(&#34;This python implementation supports:\n&#34;)
                    self.stdout.write(&#34;  * Max unicode: U+%X\n&#34; % (sys.maxunicode,))
                    self.stdout.write(
                        &#34;  * Unicode version: %s\n&#34; % (unicodedata.unidata_version,)
                    )
                    self.stdout.write(
                        &#34;  * Floating-point significant digits: %d\n&#34;
                        % (float_sigdigits,)
                    )
                    self.stdout.write(
                        &#34;  * Floating-point max 10^exponent: %d\n&#34; % (float_maxexp,)
                    )
                    if str(0.0) == str(-0.0):
                        szero = &#34;No&#34;
                    else:
                        szero = &#34;Yes&#34;
                    self.stdout.write(
                        &#34;  * Floating-point has signed-zeros: %s\n&#34; % (szero,)
                    )
                    if decimal:
                        has_dec = &#34;Yes&#34;
                    else:
                        has_dec = &#34;No&#34;
                    self.stdout.write(
                        &#34;  * Decimal (bigfloat) support: %s\n&#34; % (has_dec,)
                    )
                return 0
            elif opt == &#34;--copyright&#34;:
                self.stdout.write(
                    &#39;%s is distributed as part of the &#34;demjson&#34; python package.\n&#39;
                    % (self.program_name,)
                )
                self.stdout.write(&#34;See %s\n\n\n&#34; % (__homepage__,))
                self.stdout.write(__credits__)
                return 0
            elif opt in (&#34;-v&#34;, &#34;--verbose&#34;):
                verbose = True
            elif opt in (&#34;-q&#34;, &#34;--quiet&#34;):
                verbose = False
            elif opt in (&#34;-s&#34;, &#34;--strict&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_STRICT
                kwoptions[&#34;keep_format&#34;] = False
            elif opt in (&#34;-S&#34;, &#34;--nonstrict&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_TOLERANT
            elif opt in (&#34;-W&#34;, &#34;--tolerant&#34;):
                kwoptions[&#34;strict&#34;] = STRICTNESS_WARN
            elif opt in (&#34;-f&#34;, &#34;--format&#34;):
                reformat = True
                kwoptions[&#34;encode_compactly&#34;] = False
            elif opt in (&#34;-F&#34;, &#34;--format-compactly&#34;):
                kwoptions[&#34;encode_compactly&#34;] = True
                reformat = &#34;compactly&#34;
            elif opt in (&#34;--stats&#34;,):
                show_stats = True
            elif opt in (&#34;-o&#34;, &#34;--output&#34;):
                output_filename = val
            elif opt in (&#34;-e&#34;, &#34;--encoding&#34;):
                input_encoding = val
                output_encoding = val
                escape_unicode = False
            elif opt in (&#34;--output-encoding&#34;):
                output_encoding = val
                escape_unicode = False
            elif opt in (&#34;--input-encoding&#34;):
                input_encoding = val
            elif opt in (&#34;--html-safe&#34;, &#34;--xml-safe&#34;):
                kwoptions[&#34;html_safe&#34;] = True
            elif opt in (&#34;--allow&#34;, &#34;--warn&#34;, &#34;--forbid&#34;):
                action = opt[2:]
                if action in kwoptions:
                    kwoptions[action] += &#34;,&#34; + val
                else:
                    kwoptions[action] = val
            elif opt in (&#34;--keep-format&#34;,):
                kwoptions[&#34;keep_format&#34;] = True
            elif opt in (&#34;--no-keep-format&#34;,):
                kwoptions[&#34;keep_format&#34;] = False
            elif opt == &#34;--leading-zero-radix&#34;:
                kwoptions[&#34;leading_zero_radix&#34;] = val
            elif opt in (&#34;--indent&#34;, &#34;--indent-amount&#34;):
                if val in (&#34;tab&#34;, &#34;tabs&#34;):
                    kwoptions[&#34;indent_amount&#34;] = 8
                    kwoptions[&#34;indent_tab_width&#34;] = 8
                else:
                    try:
                        kwoptions[&#34;indent_amount&#34;] = int(val)
                    except ValueError:
                        self.stderr.write(&#34;Indentation amount must be a number\n&#34;)
                        return 1
            elif opt == &#34;indent-tab-width&#34;:
                try:
                    kwoptions[&#34;indent_tab_width&#34;] = int(val)
                except ValueError:
                    self.stderr.write(&#34;Indentation tab width must be a number\n&#34;)
                    return 1
            elif opt == &#34;--max-items-per-line&#34;:
                try:
                    kwoptions[&#34;max_items_per_line&#34;] = int(val)
                except ValueError:
                    self.stderr.write(&#34;Max items per line must be a number\n&#34;)
                    return 1
            elif opt == &#34;--sort&#34;:
                val = val.lower()
                if val == &#34;alpha&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_ALPHA
                elif val == &#34;alpha_ci&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_ALPHA_CI
                elif val == &#34;preserve&#34;:
                    kwoptions[&#34;sort_keys&#34;] = SORT_PRESERVE
                else:
                    kwoptions[&#34;sort_keys&#34;] = SORT_SMART
            elif opt == &#34;--recursion-limit&#34;:
                try:
                    recursion_limit = int(val)
                except ValueError:
                    self.stderr.write(&#34;Recursion limit must be a number: %r\n&#34; % val)
                    return 1
                else:
                    max_limit = 100000
                    old_limit = sys.getrecursionlimit()
                    if recursion_limit &gt; max_limit:
                        self.stderr.write(
                            &#34;Recursion limit must be a number between %d and %d\n&#34;
                            % (old_limit, max_limit)
                        )
                        return 1
                    elif recursion_limit &gt; old_limit:
                        sys.setrecursionlimit(recursion_limit)
            else:
                self.stderr.write(&#34;Unknown option %r\n&#34; % opt)
                return 1

        # Make the JSON options
        kwoptions[&#34;decimal_context&#34;] = 100
        jsonopts = json_options(**kwoptions)

        # Now decode each file...
        if not args:
            args = [None]

        for fn in args:
            try:
                rc = self._lintcheck(
                    fn,
                    output_filename=output_filename,
                    verbose=verbose,
                    reformat=reformat,
                    show_stats=show_stats,
                    input_encoding=input_encoding,
                    output_encoding=output_encoding,
                    jsonopts=jsonopts,
                )
                if rc != self.SUCCESS_OK:
                    # Warnings or errors should result in failure.  If
                    # checking multiple files, do not change a
                    # previous error back to ok.
                    success = False
            except KeyboardInterrupt as err:
                sys.stderr.write(&#34;\njsonlint interrupted!\n&#34;)
                sys.exit(1)

        if not success:
            return 1
        return 0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.position_marker"><code class="flex name class">
<span>class <span class="ident">position_marker</span></span>
<span>(</span><span>offset=0, line=1, column=0, text_after=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A position marks a specific place in a text document.
It consists of the following attributes:</p>
<pre><code>* line - The line number, starting at 1
* column - The column on the line, starting at 0
* char_position - The number of characters from the start of
                  the document, starting at 0
* text_after - (optional) a short excerpt of the text of
               document starting at the current position
</code></pre>
<p>Lines are separated by any Unicode line separator character. As an
exception a CR+LF character pair is treated as being a single line
separator demarcation.</p>
<p>Columns are simply a measure of the number of characters after the
start of a new line, starting at 0.
Visual effects caused by
Unicode characters such as combining characters, bidirectional
text, zero-width characters and so on do not affect the
computation of the column regardless of visual appearance.</p>
<p>The char_position is a count of the number of characters since the
beginning of the document, starting at 0. As used within the
buffered_stream class, if the document starts with a Unicode Byte
Order Mark (BOM), the BOM prefix is NOT INCLUDED in the count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class position_marker(object):
    &#34;&#34;&#34;A position marks a specific place in a text document.
    It consists of the following attributes:

        * line - The line number, starting at 1
        * column - The column on the line, starting at 0
        * char_position - The number of characters from the start of
                          the document, starting at 0
        * text_after - (optional) a short excerpt of the text of
                       document starting at the current position

    Lines are separated by any Unicode line separator character. As an
    exception a CR+LF character pair is treated as being a single line
    separator demarcation.

    Columns are simply a measure of the number of characters after the
    start of a new line, starting at 0.  Visual effects caused by
    Unicode characters such as combining characters, bidirectional
    text, zero-width characters and so on do not affect the
    computation of the column regardless of visual appearance.

    The char_position is a count of the number of characters since the
    beginning of the document, starting at 0. As used within the
    buffered_stream class, if the document starts with a Unicode Byte
    Order Mark (BOM), the BOM prefix is NOT INCLUDED in the count.

    &#34;&#34;&#34;

    def __init__(self, offset=0, line=1, column=0, text_after=None):
        self.__char_position = offset
        self.__line = line
        self.__column = column
        self.__text_after = text_after
        self.__at_end = False
        self.__last_was_cr = False

    @property
    def line(self):
        &#34;&#34;&#34;The current line within the document, starts at 1.&#34;&#34;&#34;
        return self.__line

    @property
    def column(self):
        &#34;&#34;&#34;The current character column from the beginning of the
        document, starts at 0.
        &#34;&#34;&#34;
        return self.__column

    @property
    def char_position(self):
        &#34;&#34;&#34;The current character offset from the beginning of the
        document, starts at 0.
        &#34;&#34;&#34;
        return self.__char_position

    @property
    def at_start(self):
        &#34;&#34;&#34;Returns True if the position is at the start of the document.&#34;&#34;&#34;
        return self.char_position == 0

    @property
    def at_end(self):
        &#34;&#34;&#34;Returns True if the position is at the end of the document.

        This property must be set by the user.
        &#34;&#34;&#34;
        return self.__at_end

    @at_end.setter
    def at_end(self, b):
        &#34;&#34;&#34;Sets the at_end property to True or False.&#34;&#34;&#34;
        self.__at_end = bool(b)

    @property
    def text_after(self):
        &#34;&#34;&#34;Returns a textual excerpt starting at the current position.

        This property must be set by the user.
        &#34;&#34;&#34;
        return self.__at_end

    @text_after.setter
    def text_after(self, value):
        &#34;&#34;&#34;Sets the text_after property to a given string.&#34;&#34;&#34;
        self.__text_after = value

    def __repr__(self):
        s = &#34;%s(offset=%r,line=%r,column=%r&#34; % (
            self.__class__.__name__,
            self.__char_position,
            self.__line,
            self.__column,
        )
        if self.text_after:
            s += &#34;,text_after=%r&#34; % (self.text_after,)
        s += &#34;)&#34;
        return s

    def describe(self, show_text=True):
        &#34;&#34;&#34;Returns a human-readable description of the position, in English.&#34;&#34;&#34;
        s = &#34;line %d, column %d, offset %d&#34; % (
            self.__line,
            self.__column,
            self.__char_position,
        )
        if self.at_start:
            s += &#34; (AT-START)&#34;
        elif self.at_end:
            s += &#34; (AT-END)&#34;
        if show_text and self.text_after:
            s += &#34;, text %r&#34; % (self.text_after)
        return s

    def __str__(self):
        &#34;&#34;&#34;Same as the describe() function.&#34;&#34;&#34;
        return self.describe(show_text=True)

    def copy(self):
        &#34;&#34;&#34;Create a copy of the position object.&#34;&#34;&#34;
        p = self.__class__()
        p.__char_position = self.__char_position
        p.__line = self.__line
        p.__column = self.__column
        p.text_after = self.__text_after
        p.at_end = self.at_end
        p.__last_was_cr = self.__last_was_cr
        return p

    def rewind(self):
        &#34;&#34;&#34;Set the position to the start of the document.&#34;&#34;&#34;
        if not self.at_start:
            self.text_after = None
            self.at_end = False
        self.__char_position = 0
        self.__line = 1
        self.__column = 0
        self.__last_was_cr = False

    def advance(self, s):
        &#34;&#34;&#34;Advance the position from its current place according to
        the given string of characters.

        &#34;&#34;&#34;
        if s:
            self.text_after = None
        for c in s:
            self.__char_position += 1
            if c == &#34;\n&#34; and self.__last_was_cr:
                self.__last_was_cr = False
            elif helpers.char_is_unicode_eol(c):
                self.__line += 1
                self.__column = 0
                self.__last_was_cr = c == &#34;\r&#34;
            else:
                self.__column += 1
                self.__last_was_cr = False</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="demjson3.position_marker.at_end"><code class="name">var <span class="ident">at_end</span></code></dt>
<dd>
<div class="desc"><p>Returns True if the position is at the end of the document.</p>
<p>This property must be set by the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def at_end(self):
    &#34;&#34;&#34;Returns True if the position is at the end of the document.

    This property must be set by the user.
    &#34;&#34;&#34;
    return self.__at_end</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.at_start"><code class="name">var <span class="ident">at_start</span></code></dt>
<dd>
<div class="desc"><p>Returns True if the position is at the start of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def at_start(self):
    &#34;&#34;&#34;Returns True if the position is at the start of the document.&#34;&#34;&#34;
    return self.char_position == 0</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.char_position"><code class="name">var <span class="ident">char_position</span></code></dt>
<dd>
<div class="desc"><p>The current character offset from the beginning of the
document, starts at 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def char_position(self):
    &#34;&#34;&#34;The current character offset from the beginning of the
    document, starts at 0.
    &#34;&#34;&#34;
    return self.__char_position</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.column"><code class="name">var <span class="ident">column</span></code></dt>
<dd>
<div class="desc"><p>The current character column from the beginning of the
document, starts at 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def column(self):
    &#34;&#34;&#34;The current character column from the beginning of the
    document, starts at 0.
    &#34;&#34;&#34;
    return self.__column</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.line"><code class="name">var <span class="ident">line</span></code></dt>
<dd>
<div class="desc"><p>The current line within the document, starts at 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def line(self):
    &#34;&#34;&#34;The current line within the document, starts at 1.&#34;&#34;&#34;
    return self.__line</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.text_after"><code class="name">var <span class="ident">text_after</span></code></dt>
<dd>
<div class="desc"><p>Returns a textual excerpt starting at the current position.</p>
<p>This property must be set by the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text_after(self):
    &#34;&#34;&#34;Returns a textual excerpt starting at the current position.

    This property must be set by the user.
    &#34;&#34;&#34;
    return self.__at_end</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="demjson3.position_marker.advance"><code class="name flex">
<span>def <span class="ident">advance</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Advance the position from its current place according to
the given string of characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advance(self, s):
    &#34;&#34;&#34;Advance the position from its current place according to
    the given string of characters.

    &#34;&#34;&#34;
    if s:
        self.text_after = None
    for c in s:
        self.__char_position += 1
        if c == &#34;\n&#34; and self.__last_was_cr:
            self.__last_was_cr = False
        elif helpers.char_is_unicode_eol(c):
            self.__line += 1
            self.__column = 0
            self.__last_was_cr = c == &#34;\r&#34;
        else:
            self.__column += 1
            self.__last_was_cr = False</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of the position object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Create a copy of the position object.&#34;&#34;&#34;
    p = self.__class__()
    p.__char_position = self.__char_position
    p.__line = self.__line
    p.__column = self.__column
    p.text_after = self.__text_after
    p.at_end = self.at_end
    p.__last_was_cr = self.__last_was_cr
    return p</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.describe"><code class="name flex">
<span>def <span class="ident">describe</span></span>(<span>self, show_text=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a human-readable description of the position, in English.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe(self, show_text=True):
    &#34;&#34;&#34;Returns a human-readable description of the position, in English.&#34;&#34;&#34;
    s = &#34;line %d, column %d, offset %d&#34; % (
        self.__line,
        self.__column,
        self.__char_position,
    )
    if self.at_start:
        s += &#34; (AT-START)&#34;
    elif self.at_end:
        s += &#34; (AT-END)&#34;
    if show_text and self.text_after:
        s += &#34;, text %r&#34; % (self.text_after)
    return s</code></pre>
</details>
</dd>
<dt id="demjson3.position_marker.rewind"><code class="name flex">
<span>def <span class="ident">rewind</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the position to the start of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewind(self):
    &#34;&#34;&#34;Set the position to the start of the document.&#34;&#34;&#34;
    if not self.at_start:
        self.text_after = None
        self.at_end = False
    self.__char_position = 0
    self.__line = 1
    self.__column = 0
    self.__last_was_cr = False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="demjson3.utf32"><code class="flex name class">
<span>class <span class="ident">utf32</span></span>
<span>(</span><span>encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unicode UTF-32 and UCS4 encoding/decoding support.</p>
<p>This is for older Pythons whch did not have UTF-32 codecs.</p>
<p>JSON requires that all JSON implementations must support the
UTF-32 encoding (as well as UTF-8 and UTF-16).
But earlier
versions of Python did not provide a UTF-32 codec, so we must
implement UTF-32 ourselves in case we need it.</p>
<p>See <a href="http://en.wikipedia.org/wiki/UTF-32">http://en.wikipedia.org/wiki/UTF-32</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class utf32(codecs.CodecInfo):
    &#34;&#34;&#34;Unicode UTF-32 and UCS4 encoding/decoding support.

    This is for older Pythons whch did not have UTF-32 codecs.

    JSON requires that all JSON implementations must support the
    UTF-32 encoding (as well as UTF-8 and UTF-16).  But earlier
    versions of Python did not provide a UTF-32 codec, so we must
    implement UTF-32 ourselves in case we need it.

    See http://en.wikipedia.org/wiki/UTF-32

    &#34;&#34;&#34;

    BOM_UTF32_BE = _make_raw_bytes([0, 0, 0xFE, 0xFF])  #&#39;\x00\x00\xfe\xff&#39;
    BOM_UTF32_LE = _make_raw_bytes([0xFF, 0xFE, 0, 0])  #&#39;\xff\xfe\x00\x00&#39;

    @staticmethod
    def lookup(name):
        &#34;&#34;&#34;A standard Python codec lookup function for UCS4/UTF32.

        If if recognizes an encoding name it returns a CodecInfo
        structure which contains the various encode and decoder
        functions to use.

        &#34;&#34;&#34;
        ci = None
        name = name.upper()
        if name in (
            &#34;UCS4BE&#34;,
            &#34;UCS-4BE&#34;,
            &#34;UCS-4-BE&#34;,
            &#34;UTF32BE&#34;,
            &#34;UTF-32BE&#34;,
            &#34;UTF-32-BE&#34;,
        ):
            ci = codecs.CodecInfo(
                utf32.utf32be_encode, utf32.utf32be_decode, name=&#34;utf-32be&#34;
            )
        elif name in (
            &#34;UCS4LE&#34;,
            &#34;UCS-4LE&#34;,
            &#34;UCS-4-LE&#34;,
            &#34;UTF32LE&#34;,
            &#34;UTF-32LE&#34;,
            &#34;UTF-32-LE&#34;,
        ):
            ci = codecs.CodecInfo(
                utf32.utf32le_encode, utf32.utf32le_decode, name=&#34;utf-32le&#34;
            )
        elif name in (&#34;UCS4&#34;, &#34;UCS-4&#34;, &#34;UTF32&#34;, &#34;UTF-32&#34;):
            ci = codecs.CodecInfo(utf32.encode, utf32.decode, name=&#34;utf-32&#34;)
        return ci

    @staticmethod
    def encode(obj, errors=&#34;strict&#34;, endianness=None, include_bom=True):
        &#34;&#34;&#34;Encodes a Unicode string into a UTF-32 encoded byte string.

        Returns a tuple: (bytearray, num_chars)

        The errors argument should be one of &#39;strict&#39;, &#39;ignore&#39;, or &#39;replace&#39;.

        The endianness should be one of:
            * &#39;B&#39;, &#39;&gt;&#39;, or &#39;big&#39;     -- Big endian
            * &#39;L&#39;, &#39;&lt;&#39;, or &#39;little&#39;  -- Little endien
            * None                   -- Default, from sys.byteorder

        If include_bom is true a Byte-Order Mark will be written to
        the beginning of the string, otherwise it will be omitted.

        &#34;&#34;&#34;
        import sys, struct

        # Make a container that can store bytes
        f = bytearray()
        write = f.extend

        def tobytes():
            return bytes(f)

        if not endianness:
            endianness = sys.byteorder

        if endianness.upper()[0] in (&#34;B&gt;&#34;):
            big_endian = True
        elif endianness.upper()[0] in (&#34;L&lt;&#34;):
            big_endian = False
        else:
            raise ValueError(
                &#34;Invalid endianness %r: expected &#39;big&#39;, &#39;little&#39;, or None&#34; % endianness
            )

        pack = struct.pack
        packspec = &#34;&gt;L&#34; if big_endian else &#34;&lt;L&#34;

        num_chars = 0

        if include_bom:
            if big_endian:
                write(utf32.BOM_UTF32_BE)
            else:
                write(utf32.BOM_UTF32_LE)
            num_chars += 1

        for pos, c in enumerate(obj):
            n = ord(c)
            if 0xD800 &lt;= n &lt;= 0xDFFF:  # surrogate codepoints are prohibited by UTF-32
                if errors == &#34;ignore&#34;:
                    pass
                elif errors == &#34;replace&#34;:
                    n = 0xFFFD
                else:
                    raise UnicodeEncodeError(
                        &#34;utf32&#34;,
                        obj,
                        pos,
                        pos + 1,
                        &#34;surrogate code points from U+D800 to U+DFFF are not allowed&#34;,
                    )
            write(pack(packspec, n))
            num_chars += 1

        return (tobytes(), num_chars)

    @staticmethod
    def utf32le_encode(obj, errors=&#34;strict&#34;, include_bom=False):
        &#34;&#34;&#34;Encodes a Unicode string into a UTF-32LE (little endian) encoded byte string.&#34;&#34;&#34;
        return utf32.encode(obj, errors=errors, endianness=&#34;L&#34;, include_bom=include_bom)

    @staticmethod
    def utf32be_encode(obj, errors=&#34;strict&#34;, include_bom=False):
        &#34;&#34;&#34;Encodes a Unicode string into a UTF-32BE (big endian) encoded byte string.&#34;&#34;&#34;
        return utf32.encode(obj, errors=errors, endianness=&#34;B&#34;, include_bom=include_bom)

    @staticmethod
    def decode(obj, errors=&#34;strict&#34;, endianness=None):
        &#34;&#34;&#34;Decodes a UTF-32 byte string into a Unicode string.

        Returns tuple (bytearray, num_bytes)

        The errors argument shold be one of &#39;strict&#39;, &#39;ignore&#39;,
        &#39;replace&#39;, &#39;backslashreplace&#39;, or &#39;xmlcharrefreplace&#39;.

        The endianness should either be None (for auto-guessing), or a
        word that starts with &#39;B&#39; (big) or &#39;L&#39; (little).

        Will detect a Byte-Order Mark. If a BOM is found and endianness
        is also set, then the two must match.

        If neither a BOM is found nor endianness is set, then big
        endian order is assumed.

        &#34;&#34;&#34;
        import struct, sys

        maxunicode = sys.maxunicode
        unpack = struct.unpack

        # Detect BOM
        if obj.startswith(utf32.BOM_UTF32_BE):
            bom_endianness = &#34;B&#34;
            start = len(utf32.BOM_UTF32_BE)
        elif obj.startswith(utf32.BOM_UTF32_LE):
            bom_endianness = &#34;L&#34;
            start = len(utf32.BOM_UTF32_LE)
        else:
            bom_endianness = None
            start = 0

        num_bytes = start

        if endianness == None:
            if bom_endianness == None:
                endianness = sys.byteorder.upper()[0]  # Assume platform default
            else:
                endianness = bom_endianness
        else:
            endianness = endianness[0].upper()
            if bom_endianness and endianness != bom_endianness:
                raise UnicodeDecodeError(
                    &#34;utf32&#34;, obj, 0, start, &#34;BOM does not match expected byte order&#34;
                )

        # Check for truncated last character
        if ((len(obj) - start) % 4) != 0:
            raise UnicodeDecodeError(
                &#34;utf32&#34;, obj, start, len(obj), &#34;Data length not a multiple of 4 bytes&#34;
            )

        # Start decoding characters
        chars = []
        packspec = &#34;&gt;L&#34; if endianness == &#34;B&#34; else &#34;&lt;L&#34;
        i = 0
        for i in range(start, len(obj), 4):
            seq = obj[i : i + 4]
            n = unpack(packspec, seq)[0]
            num_bytes += 4

            if n &gt; maxunicode or (0xD800 &lt;= n &lt;= 0xDFFF):
                if errors == &#34;strict&#34;:
                    raise UnicodeDecodeError(
                        &#34;utf32&#34;, obj, i, i + 4, &#34;Invalid code point U+%04X&#34; % n
                    )
                elif errors == &#34;replace&#34;:
                    chars.append(chr(0xFFFD))
                elif errors == &#34;backslashreplace&#34;:
                    if n &gt; 0xFFFF:
                        esc = &#34;\\u%04x&#34; % (n,)
                    else:
                        esc = &#34;\\U%08x&#34; % (n,)
                    for esc_c in esc:
                        chars.append(esc_c)
                elif errors == &#34;xmlcharrefreplace&#34;:
                    esc = &#34;&amp;#%d;&#34; % (n,)
                    for esc_c in esc:
                        chars.append(esc_c)
                else:  # ignore
                    pass
            else:
                chars.append(helpers.safe_unichr(n))
        return (&#34;&#34;.join(chars), num_bytes)

    @staticmethod
    def utf32le_decode(obj, errors=&#34;strict&#34;):
        &#34;&#34;&#34;Decodes a UTF-32LE (little endian) byte string into a Unicode string.&#34;&#34;&#34;
        return utf32.decode(obj, errors=errors, endianness=&#34;L&#34;)

    @staticmethod
    def utf32be_decode(obj, errors=&#34;strict&#34;):
        &#34;&#34;&#34;Decodes a UTF-32BE (big endian) byte string into a Unicode string.&#34;&#34;&#34;
        return utf32.decode(obj, errors=errors, endianness=&#34;B&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>codecs.CodecInfo</li>
<li>builtins.tuple</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="demjson3.utf32.BOM_UTF32_BE"><code class="name">var <span class="ident">BOM_UTF32_BE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="demjson3.utf32.BOM_UTF32_LE"><code class="name">var <span class="ident">BOM_UTF32_LE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="demjson3.utf32.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>obj, errors='strict', endianness=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a UTF-32 byte string into a Unicode string.</p>
<p>Returns tuple (bytearray, num_bytes)</p>
<p>The errors argument shold be one of 'strict', 'ignore',
'replace', 'backslashreplace', or 'xmlcharrefreplace'.</p>
<p>The endianness should either be None (for auto-guessing), or a
word that starts with 'B' (big) or 'L' (little).</p>
<p>Will detect a Byte-Order Mark. If a BOM is found and endianness
is also set, then the two must match.</p>
<p>If neither a BOM is found nor endianness is set, then big
endian order is assumed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def decode(obj, errors=&#34;strict&#34;, endianness=None):
    &#34;&#34;&#34;Decodes a UTF-32 byte string into a Unicode string.

    Returns tuple (bytearray, num_bytes)

    The errors argument shold be one of &#39;strict&#39;, &#39;ignore&#39;,
    &#39;replace&#39;, &#39;backslashreplace&#39;, or &#39;xmlcharrefreplace&#39;.

    The endianness should either be None (for auto-guessing), or a
    word that starts with &#39;B&#39; (big) or &#39;L&#39; (little).

    Will detect a Byte-Order Mark. If a BOM is found and endianness
    is also set, then the two must match.

    If neither a BOM is found nor endianness is set, then big
    endian order is assumed.

    &#34;&#34;&#34;
    import struct, sys

    maxunicode = sys.maxunicode
    unpack = struct.unpack

    # Detect BOM
    if obj.startswith(utf32.BOM_UTF32_BE):
        bom_endianness = &#34;B&#34;
        start = len(utf32.BOM_UTF32_BE)
    elif obj.startswith(utf32.BOM_UTF32_LE):
        bom_endianness = &#34;L&#34;
        start = len(utf32.BOM_UTF32_LE)
    else:
        bom_endianness = None
        start = 0

    num_bytes = start

    if endianness == None:
        if bom_endianness == None:
            endianness = sys.byteorder.upper()[0]  # Assume platform default
        else:
            endianness = bom_endianness
    else:
        endianness = endianness[0].upper()
        if bom_endianness and endianness != bom_endianness:
            raise UnicodeDecodeError(
                &#34;utf32&#34;, obj, 0, start, &#34;BOM does not match expected byte order&#34;
            )

    # Check for truncated last character
    if ((len(obj) - start) % 4) != 0:
        raise UnicodeDecodeError(
            &#34;utf32&#34;, obj, start, len(obj), &#34;Data length not a multiple of 4 bytes&#34;
        )

    # Start decoding characters
    chars = []
    packspec = &#34;&gt;L&#34; if endianness == &#34;B&#34; else &#34;&lt;L&#34;
    i = 0
    for i in range(start, len(obj), 4):
        seq = obj[i : i + 4]
        n = unpack(packspec, seq)[0]
        num_bytes += 4

        if n &gt; maxunicode or (0xD800 &lt;= n &lt;= 0xDFFF):
            if errors == &#34;strict&#34;:
                raise UnicodeDecodeError(
                    &#34;utf32&#34;, obj, i, i + 4, &#34;Invalid code point U+%04X&#34; % n
                )
            elif errors == &#34;replace&#34;:
                chars.append(chr(0xFFFD))
            elif errors == &#34;backslashreplace&#34;:
                if n &gt; 0xFFFF:
                    esc = &#34;\\u%04x&#34; % (n,)
                else:
                    esc = &#34;\\U%08x&#34; % (n,)
                for esc_c in esc:
                    chars.append(esc_c)
            elif errors == &#34;xmlcharrefreplace&#34;:
                esc = &#34;&amp;#%d;&#34; % (n,)
                for esc_c in esc:
                    chars.append(esc_c)
            else:  # ignore
                pass
        else:
            chars.append(helpers.safe_unichr(n))
    return (&#34;&#34;.join(chars), num_bytes)</code></pre>
</details>
</dd>
<dt id="demjson3.utf32.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>obj, errors='strict', endianness=None, include_bom=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a Unicode string into a UTF-32 encoded byte string.</p>
<p>Returns a tuple: (bytearray, num_chars)</p>
<p>The errors argument should be one of 'strict', 'ignore', or 'replace'.</p>
<p>The endianness should be one of:
* 'B', '&gt;', or 'big'
&ndash; Big endian
* 'L', '&lt;', or 'little'
&ndash; Little endien
* None
&ndash; Default, from sys.byteorder</p>
<p>If include_bom is true a Byte-Order Mark will be written to
the beginning of the string, otherwise it will be omitted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def encode(obj, errors=&#34;strict&#34;, endianness=None, include_bom=True):
    &#34;&#34;&#34;Encodes a Unicode string into a UTF-32 encoded byte string.

    Returns a tuple: (bytearray, num_chars)

    The errors argument should be one of &#39;strict&#39;, &#39;ignore&#39;, or &#39;replace&#39;.

    The endianness should be one of:
        * &#39;B&#39;, &#39;&gt;&#39;, or &#39;big&#39;     -- Big endian
        * &#39;L&#39;, &#39;&lt;&#39;, or &#39;little&#39;  -- Little endien
        * None                   -- Default, from sys.byteorder

    If include_bom is true a Byte-Order Mark will be written to
    the beginning of the string, otherwise it will be omitted.

    &#34;&#34;&#34;
    import sys, struct

    # Make a container that can store bytes
    f = bytearray()
    write = f.extend

    def tobytes():
        return bytes(f)

    if not endianness:
        endianness = sys.byteorder

    if endianness.upper()[0] in (&#34;B&gt;&#34;):
        big_endian = True
    elif endianness.upper()[0] in (&#34;L&lt;&#34;):
        big_endian = False
    else:
        raise ValueError(
            &#34;Invalid endianness %r: expected &#39;big&#39;, &#39;little&#39;, or None&#34; % endianness
        )

    pack = struct.pack
    packspec = &#34;&gt;L&#34; if big_endian else &#34;&lt;L&#34;

    num_chars = 0

    if include_bom:
        if big_endian:
            write(utf32.BOM_UTF32_BE)
        else:
            write(utf32.BOM_UTF32_LE)
        num_chars += 1

    for pos, c in enumerate(obj):
        n = ord(c)
        if 0xD800 &lt;= n &lt;= 0xDFFF:  # surrogate codepoints are prohibited by UTF-32
            if errors == &#34;ignore&#34;:
                pass
            elif errors == &#34;replace&#34;:
                n = 0xFFFD
            else:
                raise UnicodeEncodeError(
                    &#34;utf32&#34;,
                    obj,
                    pos,
                    pos + 1,
                    &#34;surrogate code points from U+D800 to U+DFFF are not allowed&#34;,
                )
        write(pack(packspec, n))
        num_chars += 1

    return (tobytes(), num_chars)</code></pre>
</details>
</dd>
<dt id="demjson3.utf32.lookup"><code class="name flex">
<span>def <span class="ident">lookup</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>A standard Python codec lookup function for UCS4/UTF32.</p>
<p>If if recognizes an encoding name it returns a CodecInfo
structure which contains the various encode and decoder
functions to use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def lookup(name):
    &#34;&#34;&#34;A standard Python codec lookup function for UCS4/UTF32.

    If if recognizes an encoding name it returns a CodecInfo
    structure which contains the various encode and decoder
    functions to use.

    &#34;&#34;&#34;
    ci = None
    name = name.upper()
    if name in (
        &#34;UCS4BE&#34;,
        &#34;UCS-4BE&#34;,
        &#34;UCS-4-BE&#34;,
        &#34;UTF32BE&#34;,
        &#34;UTF-32BE&#34;,
        &#34;UTF-32-BE&#34;,
    ):
        ci = codecs.CodecInfo(
            utf32.utf32be_encode, utf32.utf32be_decode, name=&#34;utf-32be&#34;
        )
    elif name in (
        &#34;UCS4LE&#34;,
        &#34;UCS-4LE&#34;,
        &#34;UCS-4-LE&#34;,
        &#34;UTF32LE&#34;,
        &#34;UTF-32LE&#34;,
        &#34;UTF-32-LE&#34;,
    ):
        ci = codecs.CodecInfo(
            utf32.utf32le_encode, utf32.utf32le_decode, name=&#34;utf-32le&#34;
        )
    elif name in (&#34;UCS4&#34;, &#34;UCS-4&#34;, &#34;UTF32&#34;, &#34;UTF-32&#34;):
        ci = codecs.CodecInfo(utf32.encode, utf32.decode, name=&#34;utf-32&#34;)
    return ci</code></pre>
</details>
</dd>
<dt id="demjson3.utf32.utf32be_decode"><code class="name flex">
<span>def <span class="ident">utf32be_decode</span></span>(<span>obj, errors='strict')</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a UTF-32BE (big endian) byte string into a Unicode string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def utf32be_decode(obj, errors=&#34;strict&#34;):
    &#34;&#34;&#34;Decodes a UTF-32BE (big endian) byte string into a Unicode string.&#34;&#34;&#34;
    return utf32.decode(obj, errors=errors, endianness=&#34;B&#34;)</code></pre>
</details>
</dd>
<dt id="demjson3.utf32.utf32be_encode"><code class="name flex">
<span>def <span class="ident">utf32be_encode</span></span>(<span>obj, errors='strict', include_bom=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a Unicode string into a UTF-32BE (big endian) encoded byte string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def utf32be_encode(obj, errors=&#34;strict&#34;, include_bom=False):
    &#34;&#34;&#34;Encodes a Unicode string into a UTF-32BE (big endian) encoded byte string.&#34;&#34;&#34;
    return utf32.encode(obj, errors=errors, endianness=&#34;B&#34;, include_bom=include_bom)</code></pre>
</details>
</dd>
<dt id="demjson3.utf32.utf32le_decode"><code class="name flex">
<span>def <span class="ident">utf32le_decode</span></span>(<span>obj, errors='strict')</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes a UTF-32LE (little endian) byte string into a Unicode string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def utf32le_decode(obj, errors=&#34;strict&#34;):
    &#34;&#34;&#34;Decodes a UTF-32LE (little endian) byte string into a Unicode string.&#34;&#34;&#34;
    return utf32.decode(obj, errors=errors, endianness=&#34;L&#34;)</code></pre>
</details>
</dd>
<dt id="demjson3.utf32.utf32le_encode"><code class="name flex">
<span>def <span class="ident">utf32le_encode</span></span>(<span>obj, errors='strict', include_bom=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes a Unicode string into a UTF-32LE (little endian) encoded byte string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def utf32le_encode(obj, errors=&#34;strict&#34;, include_bom=False):
    &#34;&#34;&#34;Encodes a Unicode string into a UTF-32LE (little endian) encoded byte string.&#34;&#34;&#34;
    return utf32.encode(obj, errors=errors, endianness=&#34;L&#34;, include_bom=include_bom)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="demjson3.decode" href="#demjson3.decode">decode</a></code></li>
<li><code><a title="demjson3.decode_file" href="#demjson3.decode_file">decode_file</a></code></li>
<li><code><a title="demjson3.determine_float_limits" href="#demjson3.determine_float_limits">determine_float_limits</a></code></li>
<li><code><a title="demjson3.determine_float_precision" href="#demjson3.determine_float_precision">determine_float_precision</a></code></li>
<li><code><a title="demjson3.encode" href="#demjson3.encode">encode</a></code></li>
<li><code><a title="demjson3.encode_to_file" href="#demjson3.encode_to_file">encode_to_file</a></code></li>
<li><code><a title="demjson3.extend_and_flatten_list_with_sep" href="#demjson3.extend_and_flatten_list_with_sep">extend_and_flatten_list_with_sep</a></code></li>
<li><code><a title="demjson3.extend_list_with_sep" href="#demjson3.extend_list_with_sep">extend_list_with_sep</a></code></li>
<li><code><a title="demjson3.skipstringsafe" href="#demjson3.skipstringsafe">skipstringsafe</a></code></li>
<li><code><a title="demjson3.skipstringsafe_slow" href="#demjson3.skipstringsafe_slow">skipstringsafe_slow</a></code></li>
<li><code><a title="demjson3.smart_sort_transform" href="#demjson3.smart_sort_transform">smart_sort_transform</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="demjson3.JSON" href="#demjson3.JSON">JSON</a></code></h4>
<ul class="">
<li><code><a title="demjson3.JSON.all_hook_names" href="#demjson3.JSON.all_hook_names">all_hook_names</a></code></li>
<li><code><a title="demjson3.JSON.call_hook" href="#demjson3.JSON.call_hook">call_hook</a></code></li>
<li><code><a title="demjson3.JSON.clear_all_hooks" href="#demjson3.JSON.clear_all_hooks">clear_all_hooks</a></code></li>
<li><code><a title="demjson3.JSON.clear_hook" href="#demjson3.JSON.clear_hook">clear_hook</a></code></li>
<li><code><a title="demjson3.JSON.decode" href="#demjson3.JSON.decode">decode</a></code></li>
<li><code><a title="demjson3.JSON.decode_boolean" href="#demjson3.JSON.decode_boolean">decode_boolean</a></code></li>
<li><code><a title="demjson3.JSON.decode_composite" href="#demjson3.JSON.decode_composite">decode_composite</a></code></li>
<li><code><a title="demjson3.JSON.decode_identifier" href="#demjson3.JSON.decode_identifier">decode_identifier</a></code></li>
<li><code><a title="demjson3.JSON.decode_javascript_identifier" href="#demjson3.JSON.decode_javascript_identifier">decode_javascript_identifier</a></code></li>
<li><code><a title="demjson3.JSON.decode_null" href="#demjson3.JSON.decode_null">decode_null</a></code></li>
<li><code><a title="demjson3.JSON.decode_number" href="#demjson3.JSON.decode_number">decode_number</a></code></li>
<li><code><a title="demjson3.JSON.decode_string" href="#demjson3.JSON.decode_string">decode_string</a></code></li>
<li><code><a title="demjson3.JSON.decodeobj" href="#demjson3.JSON.decodeobj">decodeobj</a></code></li>
<li><code><a title="demjson3.JSON.encode" href="#demjson3.JSON.encode">encode</a></code></li>
<li><code><a title="demjson3.JSON.encode_boolean" href="#demjson3.JSON.encode_boolean">encode_boolean</a></code></li>
<li><code><a title="demjson3.JSON.encode_composite" href="#demjson3.JSON.encode_composite">encode_composite</a></code></li>
<li><code><a title="demjson3.JSON.encode_date" href="#demjson3.JSON.encode_date">encode_date</a></code></li>
<li><code><a title="demjson3.JSON.encode_datetime" href="#demjson3.JSON.encode_datetime">encode_datetime</a></code></li>
<li><code><a title="demjson3.JSON.encode_enum" href="#demjson3.JSON.encode_enum">encode_enum</a></code></li>
<li><code><a title="demjson3.JSON.encode_equivalent" href="#demjson3.JSON.encode_equivalent">encode_equivalent</a></code></li>
<li><code><a title="demjson3.JSON.encode_null" href="#demjson3.JSON.encode_null">encode_null</a></code></li>
<li><code><a title="demjson3.JSON.encode_number" href="#demjson3.JSON.encode_number">encode_number</a></code></li>
<li><code><a title="demjson3.JSON.encode_string" href="#demjson3.JSON.encode_string">encode_string</a></code></li>
<li><code><a title="demjson3.JSON.encode_time" href="#demjson3.JSON.encode_time">encode_time</a></code></li>
<li><code><a title="demjson3.JSON.encode_timedelta" href="#demjson3.JSON.encode_timedelta">encode_timedelta</a></code></li>
<li><code><a title="demjson3.JSON.encode_undefined" href="#demjson3.JSON.encode_undefined">encode_undefined</a></code></li>
<li><code><a title="demjson3.JSON.has_hook" href="#demjson3.JSON.has_hook">has_hook</a></code></li>
<li><code><a title="demjson3.JSON.islineterm" href="#demjson3.JSON.islineterm">islineterm</a></code></li>
<li><code><a title="demjson3.JSON.isws" href="#demjson3.JSON.isws">isws</a></code></li>
<li><code><a title="demjson3.JSON.json_syntax_characters" href="#demjson3.JSON.json_syntax_characters">json_syntax_characters</a></code></li>
<li><code><a title="demjson3.JSON.options" href="#demjson3.JSON.options">options</a></code></li>
<li><code><a title="demjson3.JSON.recover_parser" href="#demjson3.JSON.recover_parser">recover_parser</a></code></li>
<li><code><a title="demjson3.JSON.set_hook" href="#demjson3.JSON.set_hook">set_hook</a></code></li>
<li><code><a title="demjson3.JSON.skip_comment" href="#demjson3.JSON.skip_comment">skip_comment</a></code></li>
<li><code><a title="demjson3.JSON.skipws" href="#demjson3.JSON.skipws">skipws</a></code></li>
<li><code><a title="demjson3.JSON.skipws_nocomments" href="#demjson3.JSON.skipws_nocomments">skipws_nocomments</a></code></li>
<li><code><a title="demjson3.JSON.try_encode_default" href="#demjson3.JSON.try_encode_default">try_encode_default</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.JSONAbort" href="#demjson3.JSONAbort">JSONAbort</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.JSONDecodeError" href="#demjson3.JSONDecodeError">JSONDecodeError</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.JSONDecodeHookError" href="#demjson3.JSONDecodeHookError">JSONDecodeHookError</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.JSONEncodeError" href="#demjson3.JSONEncodeError">JSONEncodeError</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.JSONEncodeHookError" href="#demjson3.JSONEncodeHookError">JSONEncodeHookError</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.JSONError" href="#demjson3.JSONError">JSONError</a></code></h4>
<ul class="">
<li><code><a title="demjson3.JSONError.position" href="#demjson3.JSONError.position">position</a></code></li>
<li><code><a title="demjson3.JSONError.pretty_description" href="#demjson3.JSONError.pretty_description">pretty_description</a></code></li>
<li><code><a title="demjson3.JSONError.severities" href="#demjson3.JSONError.severities">severities</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.JSONException" href="#demjson3.JSONException">JSONException</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.JSONSkipHook" href="#demjson3.JSONSkipHook">JSONSkipHook</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.JSONStopProcessing" href="#demjson3.JSONStopProcessing">JSONStopProcessing</a></code></h4>
</li>
<li>
<h4><code><a title="demjson3.buffered_stream" href="#demjson3.buffered_stream">buffered_stream</a></code></h4>
<ul class="">
<li><code><a title="demjson3.buffered_stream.at_end" href="#demjson3.buffered_stream.at_end">at_end</a></code></li>
<li><code><a title="demjson3.buffered_stream.at_eol" href="#demjson3.buffered_stream.at_eol">at_eol</a></code></li>
<li><code><a title="demjson3.buffered_stream.at_start" href="#demjson3.buffered_stream.at_start">at_start</a></code></li>
<li><code><a title="demjson3.buffered_stream.at_ws" href="#demjson3.buffered_stream.at_ws">at_ws</a></code></li>
<li><code><a title="demjson3.buffered_stream.bom" href="#demjson3.buffered_stream.bom">bom</a></code></li>
<li><code><a title="demjson3.buffered_stream.clear_saved_position" href="#demjson3.buffered_stream.clear_saved_position">clear_saved_position</a></code></li>
<li><code><a title="demjson3.buffered_stream.codec" href="#demjson3.buffered_stream.codec">codec</a></code></li>
<li><code><a title="demjson3.buffered_stream.cpos" href="#demjson3.buffered_stream.cpos">cpos</a></code></li>
<li><code><a title="demjson3.buffered_stream.peek" href="#demjson3.buffered_stream.peek">peek</a></code></li>
<li><code><a title="demjson3.buffered_stream.peekstr" href="#demjson3.buffered_stream.peekstr">peekstr</a></code></li>
<li><code><a title="demjson3.buffered_stream.pop" href="#demjson3.buffered_stream.pop">pop</a></code></li>
<li><code><a title="demjson3.buffered_stream.pop_identifier" href="#demjson3.buffered_stream.pop_identifier">pop_identifier</a></code></li>
<li><code><a title="demjson3.buffered_stream.pop_if_startswith" href="#demjson3.buffered_stream.pop_if_startswith">pop_if_startswith</a></code></li>
<li><code><a title="demjson3.buffered_stream.pop_while_in" href="#demjson3.buffered_stream.pop_while_in">pop_while_in</a></code></li>
<li><code><a title="demjson3.buffered_stream.popif" href="#demjson3.buffered_stream.popif">popif</a></code></li>
<li><code><a title="demjson3.buffered_stream.popstr" href="#demjson3.buffered_stream.popstr">popstr</a></code></li>
<li><code><a title="demjson3.buffered_stream.popuntil" href="#demjson3.buffered_stream.popuntil">popuntil</a></code></li>
<li><code><a title="demjson3.buffered_stream.popwhile" href="#demjson3.buffered_stream.popwhile">popwhile</a></code></li>
<li><code><a title="demjson3.buffered_stream.position" href="#demjson3.buffered_stream.position">position</a></code></li>
<li><code><a title="demjson3.buffered_stream.reset" href="#demjson3.buffered_stream.reset">reset</a></code></li>
<li><code><a title="demjson3.buffered_stream.restore_position" href="#demjson3.buffered_stream.restore_position">restore_position</a></code></li>
<li><code><a title="demjson3.buffered_stream.rewind" href="#demjson3.buffered_stream.rewind">rewind</a></code></li>
<li><code><a title="demjson3.buffered_stream.save_position" href="#demjson3.buffered_stream.save_position">save_position</a></code></li>
<li><code><a title="demjson3.buffered_stream.set_text" href="#demjson3.buffered_stream.set_text">set_text</a></code></li>
<li><code><a title="demjson3.buffered_stream.skip" href="#demjson3.buffered_stream.skip">skip</a></code></li>
<li><code><a title="demjson3.buffered_stream.skip_to_next_line" href="#demjson3.buffered_stream.skip_to_next_line">skip_to_next_line</a></code></li>
<li><code><a title="demjson3.buffered_stream.skipuntil" href="#demjson3.buffered_stream.skipuntil">skipuntil</a></code></li>
<li><code><a title="demjson3.buffered_stream.skipwhile" href="#demjson3.buffered_stream.skipwhile">skipwhile</a></code></li>
<li><code><a title="demjson3.buffered_stream.skipws" href="#demjson3.buffered_stream.skipws">skipws</a></code></li>
<li><code><a title="demjson3.buffered_stream.startswith" href="#demjson3.buffered_stream.startswith">startswith</a></code></li>
<li><code><a title="demjson3.buffered_stream.text_context" href="#demjson3.buffered_stream.text_context">text_context</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.decode_state" href="#demjson3.decode_state">decode_state</a></code></h4>
<ul class="">
<li><code><a title="demjson3.decode_state.has_errors" href="#demjson3.decode_state.has_errors">has_errors</a></code></li>
<li><code><a title="demjson3.decode_state.has_fatal" href="#demjson3.decode_state.has_fatal">has_fatal</a></code></li>
<li><code><a title="demjson3.decode_state.push_cond" href="#demjson3.decode_state.push_cond">push_cond</a></code></li>
<li><code><a title="demjson3.decode_state.push_error" href="#demjson3.decode_state.push_error">push_error</a></code></li>
<li><code><a title="demjson3.decode_state.push_exception" href="#demjson3.decode_state.push_exception">push_exception</a></code></li>
<li><code><a title="demjson3.decode_state.push_fatal" href="#demjson3.decode_state.push_fatal">push_fatal</a></code></li>
<li><code><a title="demjson3.decode_state.push_info" href="#demjson3.decode_state.push_info">push_info</a></code></li>
<li><code><a title="demjson3.decode_state.push_warning" href="#demjson3.decode_state.push_warning">push_warning</a></code></li>
<li><code><a title="demjson3.decode_state.reset" href="#demjson3.decode_state.reset">reset</a></code></li>
<li><code><a title="demjson3.decode_state.set_input" href="#demjson3.decode_state.set_input">set_input</a></code></li>
<li><code><a title="demjson3.decode_state.should_stop" href="#demjson3.decode_state.should_stop">should_stop</a></code></li>
<li><code><a title="demjson3.decode_state.update_depth_stats" href="#demjson3.decode_state.update_depth_stats">update_depth_stats</a></code></li>
<li><code><a title="demjson3.decode_state.update_float_stats" href="#demjson3.decode_state.update_float_stats">update_float_stats</a></code></li>
<li><code><a title="demjson3.decode_state.update_integer_stats" href="#demjson3.decode_state.update_integer_stats">update_integer_stats</a></code></li>
<li><code><a title="demjson3.decode_state.update_negzero_float_stats" href="#demjson3.decode_state.update_negzero_float_stats">update_negzero_float_stats</a></code></li>
<li><code><a title="demjson3.decode_state.update_negzero_int_stats" href="#demjson3.decode_state.update_negzero_int_stats">update_negzero_int_stats</a></code></li>
<li><code><a title="demjson3.decode_state.update_string_stats" href="#demjson3.decode_state.update_string_stats">update_string_stats</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.decode_statistics" href="#demjson3.decode_statistics">decode_statistics</a></code></h4>
<ul class="two-column">
<li><code><a title="demjson3.decode_statistics.double_int_max" href="#demjson3.decode_statistics.double_int_max">double_int_max</a></code></li>
<li><code><a title="demjson3.decode_statistics.double_int_min" href="#demjson3.decode_statistics.double_int_min">double_int_min</a></code></li>
<li><code><a title="demjson3.decode_statistics.int16_max" href="#demjson3.decode_statistics.int16_max">int16_max</a></code></li>
<li><code><a title="demjson3.decode_statistics.int16_min" href="#demjson3.decode_statistics.int16_min">int16_min</a></code></li>
<li><code><a title="demjson3.decode_statistics.int32_max" href="#demjson3.decode_statistics.int32_max">int32_max</a></code></li>
<li><code><a title="demjson3.decode_statistics.int32_min" href="#demjson3.decode_statistics.int32_min">int32_min</a></code></li>
<li><code><a title="demjson3.decode_statistics.int64_max" href="#demjson3.decode_statistics.int64_max">int64_max</a></code></li>
<li><code><a title="demjson3.decode_statistics.int64_min" href="#demjson3.decode_statistics.int64_min">int64_min</a></code></li>
<li><code><a title="demjson3.decode_statistics.int8_max" href="#demjson3.decode_statistics.int8_max">int8_max</a></code></li>
<li><code><a title="demjson3.decode_statistics.int8_min" href="#demjson3.decode_statistics.int8_min">int8_min</a></code></li>
<li><code><a title="demjson3.decode_statistics.num_infinites" href="#demjson3.decode_statistics.num_infinites">num_infinites</a></code></li>
<li><code><a title="demjson3.decode_statistics.pretty_description" href="#demjson3.decode_statistics.pretty_description">pretty_description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.encode_state" href="#demjson3.encode_state">encode_state</a></code></h4>
<ul class="">
<li><code><a title="demjson3.encode_state.append" href="#demjson3.encode_state.append">append</a></code></li>
<li><code><a title="demjson3.encode_state.combine" href="#demjson3.encode_state.combine">combine</a></code></li>
<li><code><a title="demjson3.encode_state.join_substate" href="#demjson3.encode_state.join_substate">join_substate</a></code></li>
<li><code><a title="demjson3.encode_state.make_substate" href="#demjson3.encode_state.make_substate">make_substate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.helpers" href="#demjson3.helpers">helpers</a></code></h4>
<ul class="">
<li><code><a title="demjson3.helpers.always_use_custom_codecs" href="#demjson3.helpers.always_use_custom_codecs">always_use_custom_codecs</a></code></li>
<li><code><a title="demjson3.helpers.auto_detect_encoding" href="#demjson3.helpers.auto_detect_encoding">auto_detect_encoding</a></code></li>
<li><code><a title="demjson3.helpers.char_is_identifier_leader" href="#demjson3.helpers.char_is_identifier_leader">char_is_identifier_leader</a></code></li>
<li><code><a title="demjson3.helpers.char_is_identifier_tail" href="#demjson3.helpers.char_is_identifier_tail">char_is_identifier_tail</a></code></li>
<li><code><a title="demjson3.helpers.char_is_json_eol" href="#demjson3.helpers.char_is_json_eol">char_is_json_eol</a></code></li>
<li><code><a title="demjson3.helpers.char_is_json_ws" href="#demjson3.helpers.char_is_json_ws">char_is_json_ws</a></code></li>
<li><code><a title="demjson3.helpers.char_is_unicode_eol" href="#demjson3.helpers.char_is_unicode_eol">char_is_unicode_eol</a></code></li>
<li><code><a title="demjson3.helpers.char_is_unicode_ws" href="#demjson3.helpers.char_is_unicode_ws">char_is_unicode_ws</a></code></li>
<li><code><a title="demjson3.helpers.decode_binary" href="#demjson3.helpers.decode_binary">decode_binary</a></code></li>
<li><code><a title="demjson3.helpers.decode_hex" href="#demjson3.helpers.decode_hex">decode_hex</a></code></li>
<li><code><a title="demjson3.helpers.decode_octal" href="#demjson3.helpers.decode_octal">decode_octal</a></code></li>
<li><code><a title="demjson3.helpers.extend_and_flatten_list_with_sep" href="#demjson3.helpers.extend_and_flatten_list_with_sep">extend_and_flatten_list_with_sep</a></code></li>
<li><code><a title="demjson3.helpers.format_timedelta_iso" href="#demjson3.helpers.format_timedelta_iso">format_timedelta_iso</a></code></li>
<li><code><a title="demjson3.helpers.hexdigits" href="#demjson3.helpers.hexdigits">hexdigits</a></code></li>
<li><code><a title="demjson3.helpers.is_binary_digit" href="#demjson3.helpers.is_binary_digit">is_binary_digit</a></code></li>
<li><code><a title="demjson3.helpers.is_hex_digit" href="#demjson3.helpers.is_hex_digit">is_hex_digit</a></code></li>
<li><code><a title="demjson3.helpers.is_infinite" href="#demjson3.helpers.is_infinite">is_infinite</a></code></li>
<li><code><a title="demjson3.helpers.is_nan" href="#demjson3.helpers.is_nan">is_nan</a></code></li>
<li><code><a title="demjson3.helpers.is_negzero" href="#demjson3.helpers.is_negzero">is_negzero</a></code></li>
<li><code><a title="demjson3.helpers.is_octal_digit" href="#demjson3.helpers.is_octal_digit">is_octal_digit</a></code></li>
<li><code><a title="demjson3.helpers.isnumbertype" href="#demjson3.helpers.isnumbertype">isnumbertype</a></code></li>
<li><code><a title="demjson3.helpers.isstringtype" href="#demjson3.helpers.isstringtype">isstringtype</a></code></li>
<li><code><a title="demjson3.helpers.javascript_reserved_words" href="#demjson3.helpers.javascript_reserved_words">javascript_reserved_words</a></code></li>
<li><code><a title="demjson3.helpers.lookup_codec" href="#demjson3.helpers.lookup_codec">lookup_codec</a></code></li>
<li><code><a title="demjson3.helpers.make_raw_bytes" href="#demjson3.helpers.make_raw_bytes">make_raw_bytes</a></code></li>
<li><code><a title="demjson3.helpers.make_surrogate_pair" href="#demjson3.helpers.make_surrogate_pair">make_surrogate_pair</a></code></li>
<li><code><a title="demjson3.helpers.maxunicode" href="#demjson3.helpers.maxunicode">maxunicode</a></code></li>
<li><code><a title="demjson3.helpers.octaldigits" href="#demjson3.helpers.octaldigits">octaldigits</a></code></li>
<li><code><a title="demjson3.helpers.safe_unichr" href="#demjson3.helpers.safe_unichr">safe_unichr</a></code></li>
<li><code><a title="demjson3.helpers.strip_format_control_chars" href="#demjson3.helpers.strip_format_control_chars">strip_format_control_chars</a></code></li>
<li><code><a title="demjson3.helpers.surrogate_pair_as_unicode" href="#demjson3.helpers.surrogate_pair_as_unicode">surrogate_pair_as_unicode</a></code></li>
<li><code><a title="demjson3.helpers.sys" href="#demjson3.helpers.sys">sys</a></code></li>
<li><code><a title="demjson3.helpers.unicode_as_surrogate_pair" href="#demjson3.helpers.unicode_as_surrogate_pair">unicode_as_surrogate_pair</a></code></li>
<li><code><a title="demjson3.helpers.unicode_decode" href="#demjson3.helpers.unicode_decode">unicode_decode</a></code></li>
<li><code><a title="demjson3.helpers.unsafe_string_chars" href="#demjson3.helpers.unsafe_string_chars">unsafe_string_chars</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.json_int" href="#demjson3.json_int">json_int</a></code></h4>
<ul class="">
<li><code><a title="demjson3.json_int.json_format" href="#demjson3.json_int.json_format">json_format</a></code></li>
<li><code><a title="demjson3.json_int.number_format" href="#demjson3.json_int.number_format">number_format</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.json_options" href="#demjson3.json_options">json_options</a></code></h4>
<ul class="">
<li><code><a title="demjson3.json_options.all_behaviors" href="#demjson3.json_options.all_behaviors">all_behaviors</a></code></li>
<li><code><a title="demjson3.json_options.all_numeric_signs" href="#demjson3.json_options.all_numeric_signs">all_numeric_signs</a></code></li>
<li><code><a title="demjson3.json_options.allow_all_numeric_signs" href="#demjson3.json_options.allow_all_numeric_signs">allow_all_numeric_signs</a></code></li>
<li><code><a title="demjson3.json_options.allow_any_type_at_start" href="#demjson3.json_options.allow_any_type_at_start">allow_any_type_at_start</a></code></li>
<li><code><a title="demjson3.json_options.allow_behaviors" href="#demjson3.json_options.allow_behaviors">allow_behaviors</a></code></li>
<li><code><a title="demjson3.json_options.allow_binary_numbers" href="#demjson3.json_options.allow_binary_numbers">allow_binary_numbers</a></code></li>
<li><code><a title="demjson3.json_options.allow_bom" href="#demjson3.json_options.allow_bom">allow_bom</a></code></li>
<li><code><a title="demjson3.json_options.allow_comments" href="#demjson3.json_options.allow_comments">allow_comments</a></code></li>
<li><code><a title="demjson3.json_options.allow_control_char_in_string" href="#demjson3.json_options.allow_control_char_in_string">allow_control_char_in_string</a></code></li>
<li><code><a title="demjson3.json_options.allow_duplicate_keys" href="#demjson3.json_options.allow_duplicate_keys">allow_duplicate_keys</a></code></li>
<li><code><a title="demjson3.json_options.allow_extended_unicode_escapes" href="#demjson3.json_options.allow_extended_unicode_escapes">allow_extended_unicode_escapes</a></code></li>
<li><code><a title="demjson3.json_options.allow_format_control_chars" href="#demjson3.json_options.allow_format_control_chars">allow_format_control_chars</a></code></li>
<li><code><a title="demjson3.json_options.allow_hex_numbers" href="#demjson3.json_options.allow_hex_numbers">allow_hex_numbers</a></code></li>
<li><code><a title="demjson3.json_options.allow_identifier_keys" href="#demjson3.json_options.allow_identifier_keys">allow_identifier_keys</a></code></li>
<li><code><a title="demjson3.json_options.allow_initial_decimal_point" href="#demjson3.json_options.allow_initial_decimal_point">allow_initial_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.allow_js_string_escapes" href="#demjson3.json_options.allow_js_string_escapes">allow_js_string_escapes</a></code></li>
<li><code><a title="demjson3.json_options.allow_leading_zeros" href="#demjson3.json_options.allow_leading_zeros">allow_leading_zeros</a></code></li>
<li><code><a title="demjson3.json_options.allow_non_numbers" href="#demjson3.json_options.allow_non_numbers">allow_non_numbers</a></code></li>
<li><code><a title="demjson3.json_options.allow_non_portable" href="#demjson3.json_options.allow_non_portable">allow_non_portable</a></code></li>
<li><code><a title="demjson3.json_options.allow_nonescape_characters" href="#demjson3.json_options.allow_nonescape_characters">allow_nonescape_characters</a></code></li>
<li><code><a title="demjson3.json_options.allow_nonstring_keys" href="#demjson3.json_options.allow_nonstring_keys">allow_nonstring_keys</a></code></li>
<li><code><a title="demjson3.json_options.allow_octal_numbers" href="#demjson3.json_options.allow_octal_numbers">allow_octal_numbers</a></code></li>
<li><code><a title="demjson3.json_options.allow_omitted_array_elements" href="#demjson3.json_options.allow_omitted_array_elements">allow_omitted_array_elements</a></code></li>
<li><code><a title="demjson3.json_options.allow_or_warn_behaviors" href="#demjson3.json_options.allow_or_warn_behaviors">allow_or_warn_behaviors</a></code></li>
<li><code><a title="demjson3.json_options.allow_single_quoted_strings" href="#demjson3.json_options.allow_single_quoted_strings">allow_single_quoted_strings</a></code></li>
<li><code><a title="demjson3.json_options.allow_trailing_comma" href="#demjson3.json_options.allow_trailing_comma">allow_trailing_comma</a></code></li>
<li><code><a title="demjson3.json_options.allow_trailing_decimal_point" href="#demjson3.json_options.allow_trailing_decimal_point">allow_trailing_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.allow_undefined_values" href="#demjson3.json_options.allow_undefined_values">allow_undefined_values</a></code></li>
<li><code><a title="demjson3.json_options.allow_unicode_whitespace" href="#demjson3.json_options.allow_unicode_whitespace">allow_unicode_whitespace</a></code></li>
<li><code><a title="demjson3.json_options.allow_zero_byte" href="#demjson3.json_options.allow_zero_byte">allow_zero_byte</a></code></li>
<li><code><a title="demjson3.json_options.any_type_at_start" href="#demjson3.json_options.any_type_at_start">any_type_at_start</a></code></li>
<li><code><a title="demjson3.json_options.binary_numbers" href="#demjson3.json_options.binary_numbers">binary_numbers</a></code></li>
<li><code><a title="demjson3.json_options.bom" href="#demjson3.json_options.bom">bom</a></code></li>
<li><code><a title="demjson3.json_options.comments" href="#demjson3.json_options.comments">comments</a></code></li>
<li><code><a title="demjson3.json_options.control_char_in_string" href="#demjson3.json_options.control_char_in_string">control_char_in_string</a></code></li>
<li><code><a title="demjson3.json_options.copy" href="#demjson3.json_options.copy">copy</a></code></li>
<li><code><a title="demjson3.json_options.copy_from" href="#demjson3.json_options.copy_from">copy_from</a></code></li>
<li><code><a title="demjson3.json_options.describe_behavior" href="#demjson3.json_options.describe_behavior">describe_behavior</a></code></li>
<li><code><a title="demjson3.json_options.duplicate_keys" href="#demjson3.json_options.duplicate_keys">duplicate_keys</a></code></li>
<li><code><a title="demjson3.json_options.encode_enum_as" href="#demjson3.json_options.encode_enum_as">encode_enum_as</a></code></li>
<li><code><a title="demjson3.json_options.extended_unicode_escapes" href="#demjson3.json_options.extended_unicode_escapes">extended_unicode_escapes</a></code></li>
<li><code><a title="demjson3.json_options.forbid_all_numeric_signs" href="#demjson3.json_options.forbid_all_numeric_signs">forbid_all_numeric_signs</a></code></li>
<li><code><a title="demjson3.json_options.forbid_any_type_at_start" href="#demjson3.json_options.forbid_any_type_at_start">forbid_any_type_at_start</a></code></li>
<li><code><a title="demjson3.json_options.forbid_behaviors" href="#demjson3.json_options.forbid_behaviors">forbid_behaviors</a></code></li>
<li><code><a title="demjson3.json_options.forbid_binary_numbers" href="#demjson3.json_options.forbid_binary_numbers">forbid_binary_numbers</a></code></li>
<li><code><a title="demjson3.json_options.forbid_bom" href="#demjson3.json_options.forbid_bom">forbid_bom</a></code></li>
<li><code><a title="demjson3.json_options.forbid_comments" href="#demjson3.json_options.forbid_comments">forbid_comments</a></code></li>
<li><code><a title="demjson3.json_options.forbid_control_char_in_string" href="#demjson3.json_options.forbid_control_char_in_string">forbid_control_char_in_string</a></code></li>
<li><code><a title="demjson3.json_options.forbid_duplicate_keys" href="#demjson3.json_options.forbid_duplicate_keys">forbid_duplicate_keys</a></code></li>
<li><code><a title="demjson3.json_options.forbid_extended_unicode_escapes" href="#demjson3.json_options.forbid_extended_unicode_escapes">forbid_extended_unicode_escapes</a></code></li>
<li><code><a title="demjson3.json_options.forbid_format_control_chars" href="#demjson3.json_options.forbid_format_control_chars">forbid_format_control_chars</a></code></li>
<li><code><a title="demjson3.json_options.forbid_hex_numbers" href="#demjson3.json_options.forbid_hex_numbers">forbid_hex_numbers</a></code></li>
<li><code><a title="demjson3.json_options.forbid_identifier_keys" href="#demjson3.json_options.forbid_identifier_keys">forbid_identifier_keys</a></code></li>
<li><code><a title="demjson3.json_options.forbid_initial_decimal_point" href="#demjson3.json_options.forbid_initial_decimal_point">forbid_initial_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.forbid_js_string_escapes" href="#demjson3.json_options.forbid_js_string_escapes">forbid_js_string_escapes</a></code></li>
<li><code><a title="demjson3.json_options.forbid_leading_zeros" href="#demjson3.json_options.forbid_leading_zeros">forbid_leading_zeros</a></code></li>
<li><code><a title="demjson3.json_options.forbid_non_numbers" href="#demjson3.json_options.forbid_non_numbers">forbid_non_numbers</a></code></li>
<li><code><a title="demjson3.json_options.forbid_non_portable" href="#demjson3.json_options.forbid_non_portable">forbid_non_portable</a></code></li>
<li><code><a title="demjson3.json_options.forbid_nonescape_characters" href="#demjson3.json_options.forbid_nonescape_characters">forbid_nonescape_characters</a></code></li>
<li><code><a title="demjson3.json_options.forbid_nonstring_keys" href="#demjson3.json_options.forbid_nonstring_keys">forbid_nonstring_keys</a></code></li>
<li><code><a title="demjson3.json_options.forbid_octal_numbers" href="#demjson3.json_options.forbid_octal_numbers">forbid_octal_numbers</a></code></li>
<li><code><a title="demjson3.json_options.forbid_omitted_array_elements" href="#demjson3.json_options.forbid_omitted_array_elements">forbid_omitted_array_elements</a></code></li>
<li><code><a title="demjson3.json_options.forbid_single_quoted_strings" href="#demjson3.json_options.forbid_single_quoted_strings">forbid_single_quoted_strings</a></code></li>
<li><code><a title="demjson3.json_options.forbid_trailing_comma" href="#demjson3.json_options.forbid_trailing_comma">forbid_trailing_comma</a></code></li>
<li><code><a title="demjson3.json_options.forbid_trailing_decimal_point" href="#demjson3.json_options.forbid_trailing_decimal_point">forbid_trailing_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.forbid_undefined_values" href="#demjson3.json_options.forbid_undefined_values">forbid_undefined_values</a></code></li>
<li><code><a title="demjson3.json_options.forbid_unicode_whitespace" href="#demjson3.json_options.forbid_unicode_whitespace">forbid_unicode_whitespace</a></code></li>
<li><code><a title="demjson3.json_options.forbid_zero_byte" href="#demjson3.json_options.forbid_zero_byte">forbid_zero_byte</a></code></li>
<li><code><a title="demjson3.json_options.format_control_chars" href="#demjson3.json_options.format_control_chars">format_control_chars</a></code></li>
<li><code><a title="demjson3.json_options.get_behavior" href="#demjson3.json_options.get_behavior">get_behavior</a></code></li>
<li><code><a title="demjson3.json_options.hex_numbers" href="#demjson3.json_options.hex_numbers">hex_numbers</a></code></li>
<li><code><a title="demjson3.json_options.identifier_keys" href="#demjson3.json_options.identifier_keys">identifier_keys</a></code></li>
<li><code><a title="demjson3.json_options.indentation_for_level" href="#demjson3.json_options.indentation_for_level">indentation_for_level</a></code></li>
<li><code><a title="demjson3.json_options.inf" href="#demjson3.json_options.inf">inf</a></code></li>
<li><code><a title="demjson3.json_options.initial_decimal_point" href="#demjson3.json_options.initial_decimal_point">initial_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.is_all" href="#demjson3.json_options.is_all">is_all</a></code></li>
<li><code><a title="demjson3.json_options.is_all_allow" href="#demjson3.json_options.is_all_allow">is_all_allow</a></code></li>
<li><code><a title="demjson3.json_options.is_all_forbid" href="#demjson3.json_options.is_all_forbid">is_all_forbid</a></code></li>
<li><code><a title="demjson3.json_options.is_all_warn" href="#demjson3.json_options.is_all_warn">is_all_warn</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_all_numeric_signs" href="#demjson3.json_options.is_allow_all_numeric_signs">is_allow_all_numeric_signs</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_any_type_at_start" href="#demjson3.json_options.is_allow_any_type_at_start">is_allow_any_type_at_start</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_binary_numbers" href="#demjson3.json_options.is_allow_binary_numbers">is_allow_binary_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_bom" href="#demjson3.json_options.is_allow_bom">is_allow_bom</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_comments" href="#demjson3.json_options.is_allow_comments">is_allow_comments</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_control_char_in_string" href="#demjson3.json_options.is_allow_control_char_in_string">is_allow_control_char_in_string</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_duplicate_keys" href="#demjson3.json_options.is_allow_duplicate_keys">is_allow_duplicate_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_extended_unicode_escapes" href="#demjson3.json_options.is_allow_extended_unicode_escapes">is_allow_extended_unicode_escapes</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_format_control_chars" href="#demjson3.json_options.is_allow_format_control_chars">is_allow_format_control_chars</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_hex_numbers" href="#demjson3.json_options.is_allow_hex_numbers">is_allow_hex_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_identifier_keys" href="#demjson3.json_options.is_allow_identifier_keys">is_allow_identifier_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_initial_decimal_point" href="#demjson3.json_options.is_allow_initial_decimal_point">is_allow_initial_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_js_string_escapes" href="#demjson3.json_options.is_allow_js_string_escapes">is_allow_js_string_escapes</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_leading_zeros" href="#demjson3.json_options.is_allow_leading_zeros">is_allow_leading_zeros</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_non_numbers" href="#demjson3.json_options.is_allow_non_numbers">is_allow_non_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_non_portable" href="#demjson3.json_options.is_allow_non_portable">is_allow_non_portable</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_nonescape_characters" href="#demjson3.json_options.is_allow_nonescape_characters">is_allow_nonescape_characters</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_nonstring_keys" href="#demjson3.json_options.is_allow_nonstring_keys">is_allow_nonstring_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_octal_numbers" href="#demjson3.json_options.is_allow_octal_numbers">is_allow_octal_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_omitted_array_elements" href="#demjson3.json_options.is_allow_omitted_array_elements">is_allow_omitted_array_elements</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_single_quoted_strings" href="#demjson3.json_options.is_allow_single_quoted_strings">is_allow_single_quoted_strings</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_trailing_comma" href="#demjson3.json_options.is_allow_trailing_comma">is_allow_trailing_comma</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_trailing_decimal_point" href="#demjson3.json_options.is_allow_trailing_decimal_point">is_allow_trailing_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_undefined_values" href="#demjson3.json_options.is_allow_undefined_values">is_allow_undefined_values</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_unicode_whitespace" href="#demjson3.json_options.is_allow_unicode_whitespace">is_allow_unicode_whitespace</a></code></li>
<li><code><a title="demjson3.json_options.is_allow_zero_byte" href="#demjson3.json_options.is_allow_zero_byte">is_allow_zero_byte</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_all_numeric_signs" href="#demjson3.json_options.is_forbid_all_numeric_signs">is_forbid_all_numeric_signs</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_any_type_at_start" href="#demjson3.json_options.is_forbid_any_type_at_start">is_forbid_any_type_at_start</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_binary_numbers" href="#demjson3.json_options.is_forbid_binary_numbers">is_forbid_binary_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_bom" href="#demjson3.json_options.is_forbid_bom">is_forbid_bom</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_comments" href="#demjson3.json_options.is_forbid_comments">is_forbid_comments</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_control_char_in_string" href="#demjson3.json_options.is_forbid_control_char_in_string">is_forbid_control_char_in_string</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_duplicate_keys" href="#demjson3.json_options.is_forbid_duplicate_keys">is_forbid_duplicate_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_extended_unicode_escapes" href="#demjson3.json_options.is_forbid_extended_unicode_escapes">is_forbid_extended_unicode_escapes</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_format_control_chars" href="#demjson3.json_options.is_forbid_format_control_chars">is_forbid_format_control_chars</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_hex_numbers" href="#demjson3.json_options.is_forbid_hex_numbers">is_forbid_hex_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_identifier_keys" href="#demjson3.json_options.is_forbid_identifier_keys">is_forbid_identifier_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_initial_decimal_point" href="#demjson3.json_options.is_forbid_initial_decimal_point">is_forbid_initial_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_js_string_escapes" href="#demjson3.json_options.is_forbid_js_string_escapes">is_forbid_js_string_escapes</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_leading_zeros" href="#demjson3.json_options.is_forbid_leading_zeros">is_forbid_leading_zeros</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_non_numbers" href="#demjson3.json_options.is_forbid_non_numbers">is_forbid_non_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_non_portable" href="#demjson3.json_options.is_forbid_non_portable">is_forbid_non_portable</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_nonescape_characters" href="#demjson3.json_options.is_forbid_nonescape_characters">is_forbid_nonescape_characters</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_nonstring_keys" href="#demjson3.json_options.is_forbid_nonstring_keys">is_forbid_nonstring_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_octal_numbers" href="#demjson3.json_options.is_forbid_octal_numbers">is_forbid_octal_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_omitted_array_elements" href="#demjson3.json_options.is_forbid_omitted_array_elements">is_forbid_omitted_array_elements</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_single_quoted_strings" href="#demjson3.json_options.is_forbid_single_quoted_strings">is_forbid_single_quoted_strings</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_trailing_comma" href="#demjson3.json_options.is_forbid_trailing_comma">is_forbid_trailing_comma</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_trailing_decimal_point" href="#demjson3.json_options.is_forbid_trailing_decimal_point">is_forbid_trailing_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_undefined_values" href="#demjson3.json_options.is_forbid_undefined_values">is_forbid_undefined_values</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_unicode_whitespace" href="#demjson3.json_options.is_forbid_unicode_whitespace">is_forbid_unicode_whitespace</a></code></li>
<li><code><a title="demjson3.json_options.is_forbid_zero_byte" href="#demjson3.json_options.is_forbid_zero_byte">is_forbid_zero_byte</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_all_numeric_signs" href="#demjson3.json_options.is_warn_all_numeric_signs">is_warn_all_numeric_signs</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_any_type_at_start" href="#demjson3.json_options.is_warn_any_type_at_start">is_warn_any_type_at_start</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_binary_numbers" href="#demjson3.json_options.is_warn_binary_numbers">is_warn_binary_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_bom" href="#demjson3.json_options.is_warn_bom">is_warn_bom</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_comments" href="#demjson3.json_options.is_warn_comments">is_warn_comments</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_control_char_in_string" href="#demjson3.json_options.is_warn_control_char_in_string">is_warn_control_char_in_string</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_duplicate_keys" href="#demjson3.json_options.is_warn_duplicate_keys">is_warn_duplicate_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_extended_unicode_escapes" href="#demjson3.json_options.is_warn_extended_unicode_escapes">is_warn_extended_unicode_escapes</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_format_control_chars" href="#demjson3.json_options.is_warn_format_control_chars">is_warn_format_control_chars</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_hex_numbers" href="#demjson3.json_options.is_warn_hex_numbers">is_warn_hex_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_identifier_keys" href="#demjson3.json_options.is_warn_identifier_keys">is_warn_identifier_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_initial_decimal_point" href="#demjson3.json_options.is_warn_initial_decimal_point">is_warn_initial_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_js_string_escapes" href="#demjson3.json_options.is_warn_js_string_escapes">is_warn_js_string_escapes</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_leading_zeros" href="#demjson3.json_options.is_warn_leading_zeros">is_warn_leading_zeros</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_non_numbers" href="#demjson3.json_options.is_warn_non_numbers">is_warn_non_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_non_portable" href="#demjson3.json_options.is_warn_non_portable">is_warn_non_portable</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_nonescape_characters" href="#demjson3.json_options.is_warn_nonescape_characters">is_warn_nonescape_characters</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_nonstring_keys" href="#demjson3.json_options.is_warn_nonstring_keys">is_warn_nonstring_keys</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_octal_numbers" href="#demjson3.json_options.is_warn_octal_numbers">is_warn_octal_numbers</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_omitted_array_elements" href="#demjson3.json_options.is_warn_omitted_array_elements">is_warn_omitted_array_elements</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_single_quoted_strings" href="#demjson3.json_options.is_warn_single_quoted_strings">is_warn_single_quoted_strings</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_trailing_comma" href="#demjson3.json_options.is_warn_trailing_comma">is_warn_trailing_comma</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_trailing_decimal_point" href="#demjson3.json_options.is_warn_trailing_decimal_point">is_warn_trailing_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_undefined_values" href="#demjson3.json_options.is_warn_undefined_values">is_warn_undefined_values</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_unicode_whitespace" href="#demjson3.json_options.is_warn_unicode_whitespace">is_warn_unicode_whitespace</a></code></li>
<li><code><a title="demjson3.json_options.is_warn_zero_byte" href="#demjson3.json_options.is_warn_zero_byte">is_warn_zero_byte</a></code></li>
<li><code><a title="demjson3.json_options.js_string_escapes" href="#demjson3.json_options.js_string_escapes">js_string_escapes</a></code></li>
<li><code><a title="demjson3.json_options.leading_zero_radix" href="#demjson3.json_options.leading_zero_radix">leading_zero_radix</a></code></li>
<li><code><a title="demjson3.json_options.leading_zero_radix_as_word" href="#demjson3.json_options.leading_zero_radix_as_word">leading_zero_radix_as_word</a></code></li>
<li><code><a title="demjson3.json_options.leading_zeros" href="#demjson3.json_options.leading_zeros">leading_zeros</a></code></li>
<li><code><a title="demjson3.json_options.make_decimal" href="#demjson3.json_options.make_decimal">make_decimal</a></code></li>
<li><code><a title="demjson3.json_options.make_float" href="#demjson3.json_options.make_float">make_float</a></code></li>
<li><code><a title="demjson3.json_options.make_int" href="#demjson3.json_options.make_int">make_int</a></code></li>
<li><code><a title="demjson3.json_options.nan" href="#demjson3.json_options.nan">nan</a></code></li>
<li><code><a title="demjson3.json_options.neginf" href="#demjson3.json_options.neginf">neginf</a></code></li>
<li><code><a title="demjson3.json_options.negzero_float" href="#demjson3.json_options.negzero_float">negzero_float</a></code></li>
<li><code><a title="demjson3.json_options.non_numbers" href="#demjson3.json_options.non_numbers">non_numbers</a></code></li>
<li><code><a title="demjson3.json_options.non_portable" href="#demjson3.json_options.non_portable">non_portable</a></code></li>
<li><code><a title="demjson3.json_options.nonescape_characters" href="#demjson3.json_options.nonescape_characters">nonescape_characters</a></code></li>
<li><code><a title="demjson3.json_options.nonstring_keys" href="#demjson3.json_options.nonstring_keys">nonstring_keys</a></code></li>
<li><code><a title="demjson3.json_options.octal_numbers" href="#demjson3.json_options.octal_numbers">octal_numbers</a></code></li>
<li><code><a title="demjson3.json_options.omitted_array_elements" href="#demjson3.json_options.omitted_array_elements">omitted_array_elements</a></code></li>
<li><code><a title="demjson3.json_options.reset_to_defaults" href="#demjson3.json_options.reset_to_defaults">reset_to_defaults</a></code></li>
<li><code><a title="demjson3.json_options.set_all" href="#demjson3.json_options.set_all">set_all</a></code></li>
<li><code><a title="demjson3.json_options.set_all_allow" href="#demjson3.json_options.set_all_allow">set_all_allow</a></code></li>
<li><code><a title="demjson3.json_options.set_all_forbid" href="#demjson3.json_options.set_all_forbid">set_all_forbid</a></code></li>
<li><code><a title="demjson3.json_options.set_all_warn" href="#demjson3.json_options.set_all_warn">set_all_warn</a></code></li>
<li><code><a title="demjson3.json_options.set_behavior" href="#demjson3.json_options.set_behavior">set_behavior</a></code></li>
<li><code><a title="demjson3.json_options.set_indent" href="#demjson3.json_options.set_indent">set_indent</a></code></li>
<li><code><a title="demjson3.json_options.single_quoted_strings" href="#demjson3.json_options.single_quoted_strings">single_quoted_strings</a></code></li>
<li><code><a title="demjson3.json_options.sort_keys" href="#demjson3.json_options.sort_keys">sort_keys</a></code></li>
<li><code><a title="demjson3.json_options.spaces_to_next_indent_level" href="#demjson3.json_options.spaces_to_next_indent_level">spaces_to_next_indent_level</a></code></li>
<li><code><a title="demjson3.json_options.strictness" href="#demjson3.json_options.strictness">strictness</a></code></li>
<li><code><a title="demjson3.json_options.suppress_warnings" href="#demjson3.json_options.suppress_warnings">suppress_warnings</a></code></li>
<li><code><a title="demjson3.json_options.trailing_comma" href="#demjson3.json_options.trailing_comma">trailing_comma</a></code></li>
<li><code><a title="demjson3.json_options.trailing_decimal_point" href="#demjson3.json_options.trailing_decimal_point">trailing_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.undefined_values" href="#demjson3.json_options.undefined_values">undefined_values</a></code></li>
<li><code><a title="demjson3.json_options.unicode_whitespace" href="#demjson3.json_options.unicode_whitespace">unicode_whitespace</a></code></li>
<li><code><a title="demjson3.json_options.values" href="#demjson3.json_options.values">values</a></code></li>
<li><code><a title="demjson3.json_options.warn_all_numeric_signs" href="#demjson3.json_options.warn_all_numeric_signs">warn_all_numeric_signs</a></code></li>
<li><code><a title="demjson3.json_options.warn_any_type_at_start" href="#demjson3.json_options.warn_any_type_at_start">warn_any_type_at_start</a></code></li>
<li><code><a title="demjson3.json_options.warn_behaviors" href="#demjson3.json_options.warn_behaviors">warn_behaviors</a></code></li>
<li><code><a title="demjson3.json_options.warn_binary_numbers" href="#demjson3.json_options.warn_binary_numbers">warn_binary_numbers</a></code></li>
<li><code><a title="demjson3.json_options.warn_bom" href="#demjson3.json_options.warn_bom">warn_bom</a></code></li>
<li><code><a title="demjson3.json_options.warn_comments" href="#demjson3.json_options.warn_comments">warn_comments</a></code></li>
<li><code><a title="demjson3.json_options.warn_control_char_in_string" href="#demjson3.json_options.warn_control_char_in_string">warn_control_char_in_string</a></code></li>
<li><code><a title="demjson3.json_options.warn_duplicate_keys" href="#demjson3.json_options.warn_duplicate_keys">warn_duplicate_keys</a></code></li>
<li><code><a title="demjson3.json_options.warn_extended_unicode_escapes" href="#demjson3.json_options.warn_extended_unicode_escapes">warn_extended_unicode_escapes</a></code></li>
<li><code><a title="demjson3.json_options.warn_format_control_chars" href="#demjson3.json_options.warn_format_control_chars">warn_format_control_chars</a></code></li>
<li><code><a title="demjson3.json_options.warn_hex_numbers" href="#demjson3.json_options.warn_hex_numbers">warn_hex_numbers</a></code></li>
<li><code><a title="demjson3.json_options.warn_identifier_keys" href="#demjson3.json_options.warn_identifier_keys">warn_identifier_keys</a></code></li>
<li><code><a title="demjson3.json_options.warn_initial_decimal_point" href="#demjson3.json_options.warn_initial_decimal_point">warn_initial_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.warn_js_string_escapes" href="#demjson3.json_options.warn_js_string_escapes">warn_js_string_escapes</a></code></li>
<li><code><a title="demjson3.json_options.warn_leading_zeros" href="#demjson3.json_options.warn_leading_zeros">warn_leading_zeros</a></code></li>
<li><code><a title="demjson3.json_options.warn_non_numbers" href="#demjson3.json_options.warn_non_numbers">warn_non_numbers</a></code></li>
<li><code><a title="demjson3.json_options.warn_non_portable" href="#demjson3.json_options.warn_non_portable">warn_non_portable</a></code></li>
<li><code><a title="demjson3.json_options.warn_nonescape_characters" href="#demjson3.json_options.warn_nonescape_characters">warn_nonescape_characters</a></code></li>
<li><code><a title="demjson3.json_options.warn_nonstring_keys" href="#demjson3.json_options.warn_nonstring_keys">warn_nonstring_keys</a></code></li>
<li><code><a title="demjson3.json_options.warn_octal_numbers" href="#demjson3.json_options.warn_octal_numbers">warn_octal_numbers</a></code></li>
<li><code><a title="demjson3.json_options.warn_omitted_array_elements" href="#demjson3.json_options.warn_omitted_array_elements">warn_omitted_array_elements</a></code></li>
<li><code><a title="demjson3.json_options.warn_single_quoted_strings" href="#demjson3.json_options.warn_single_quoted_strings">warn_single_quoted_strings</a></code></li>
<li><code><a title="demjson3.json_options.warn_trailing_comma" href="#demjson3.json_options.warn_trailing_comma">warn_trailing_comma</a></code></li>
<li><code><a title="demjson3.json_options.warn_trailing_decimal_point" href="#demjson3.json_options.warn_trailing_decimal_point">warn_trailing_decimal_point</a></code></li>
<li><code><a title="demjson3.json_options.warn_undefined_values" href="#demjson3.json_options.warn_undefined_values">warn_undefined_values</a></code></li>
<li><code><a title="demjson3.json_options.warn_unicode_whitespace" href="#demjson3.json_options.warn_unicode_whitespace">warn_unicode_whitespace</a></code></li>
<li><code><a title="demjson3.json_options.warn_zero_byte" href="#demjson3.json_options.warn_zero_byte">warn_zero_byte</a></code></li>
<li><code><a title="demjson3.json_options.zero_byte" href="#demjson3.json_options.zero_byte">zero_byte</a></code></li>
<li><code><a title="demjson3.json_options.zero_float" href="#demjson3.json_options.zero_float">zero_float</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.jsonlint" href="#demjson3.jsonlint">jsonlint</a></code></h4>
<ul class="">
<li><code><a title="demjson3.jsonlint.SUCCESS_FAIL" href="#demjson3.jsonlint.SUCCESS_FAIL">SUCCESS_FAIL</a></code></li>
<li><code><a title="demjson3.jsonlint.SUCCESS_OK" href="#demjson3.jsonlint.SUCCESS_OK">SUCCESS_OK</a></code></li>
<li><code><a title="demjson3.jsonlint.SUCCESS_WARNING" href="#demjson3.jsonlint.SUCCESS_WARNING">SUCCESS_WARNING</a></code></li>
<li><code><a title="demjson3.jsonlint.main" href="#demjson3.jsonlint.main">main</a></code></li>
<li><code><a title="demjson3.jsonlint.usage" href="#demjson3.jsonlint.usage">usage</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.position_marker" href="#demjson3.position_marker">position_marker</a></code></h4>
<ul class="two-column">
<li><code><a title="demjson3.position_marker.advance" href="#demjson3.position_marker.advance">advance</a></code></li>
<li><code><a title="demjson3.position_marker.at_end" href="#demjson3.position_marker.at_end">at_end</a></code></li>
<li><code><a title="demjson3.position_marker.at_start" href="#demjson3.position_marker.at_start">at_start</a></code></li>
<li><code><a title="demjson3.position_marker.char_position" href="#demjson3.position_marker.char_position">char_position</a></code></li>
<li><code><a title="demjson3.position_marker.column" href="#demjson3.position_marker.column">column</a></code></li>
<li><code><a title="demjson3.position_marker.copy" href="#demjson3.position_marker.copy">copy</a></code></li>
<li><code><a title="demjson3.position_marker.describe" href="#demjson3.position_marker.describe">describe</a></code></li>
<li><code><a title="demjson3.position_marker.line" href="#demjson3.position_marker.line">line</a></code></li>
<li><code><a title="demjson3.position_marker.rewind" href="#demjson3.position_marker.rewind">rewind</a></code></li>
<li><code><a title="demjson3.position_marker.text_after" href="#demjson3.position_marker.text_after">text_after</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="demjson3.utf32" href="#demjson3.utf32">utf32</a></code></h4>
<ul class="two-column">
<li><code><a title="demjson3.utf32.BOM_UTF32_BE" href="#demjson3.utf32.BOM_UTF32_BE">BOM_UTF32_BE</a></code></li>
<li><code><a title="demjson3.utf32.BOM_UTF32_LE" href="#demjson3.utf32.BOM_UTF32_LE">BOM_UTF32_LE</a></code></li>
<li><code><a title="demjson3.utf32.decode" href="#demjson3.utf32.decode">decode</a></code></li>
<li><code><a title="demjson3.utf32.encode" href="#demjson3.utf32.encode">encode</a></code></li>
<li><code><a title="demjson3.utf32.lookup" href="#demjson3.utf32.lookup">lookup</a></code></li>
<li><code><a title="demjson3.utf32.utf32be_decode" href="#demjson3.utf32.utf32be_decode">utf32be_decode</a></code></li>
<li><code><a title="demjson3.utf32.utf32be_encode" href="#demjson3.utf32.utf32be_encode">utf32be_encode</a></code></li>
<li><code><a title="demjson3.utf32.utf32le_decode" href="#demjson3.utf32.utf32le_decode">utf32le_decode</a></code></li>
<li><code><a title="demjson3.utf32.utf32le_encode" href="#demjson3.utf32.utf32le_encode">utf32le_encode</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>